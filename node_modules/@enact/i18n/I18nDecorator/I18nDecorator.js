"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.I18nDecorator = exports.I18nContextDecorator = exports.I18nContext = exports.contextTypes = exports["default"] = void 0;

var _dispatcher = require("@enact/core/dispatcher");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _locale = require("../locale");

var _index = _interopRequireDefault(require("../src/index.js"));

var _resBundle = require("../src/resBundle");

var _wrapIlibCallback = _interopRequireDefault(require("../src/wrapIlibCallback"));

var _getI18nClasses = _interopRequireDefault(require("./getI18nClasses"));

var _windowFocus = require("./windowFocus");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var join = function join(a, b) {
  return a && b ? a + ' ' + b : a || b || '';
};

var contextTypes = {
  rtl: _propTypes["default"].bool,
  updateLocale: _propTypes["default"].func
};
exports.contextTypes = contextTypes;

var I18nContext = _react["default"].createContext(null);
/**
 * Default config for `I18nDecorator`.
 *
 * @memberof i18n/I18nDecorator.I18nDecorator
 * @hocconfig
 */


exports.I18nContext = I18nContext;
var defaultConfig = {
  /**
   * Array of locales that should be treated as latin regardless of their script.
   *
   * @type {String[]}
   * @default	null
   * @public
   * @memberof i18n/I18nDecorator.I18nDecorator.defaultConfig
   */
  latinLanguageOverrides: null,

  /**
   * Array of locales that should be treated as non-latin regardless of their script.
   *
   * @type {String[]}
   * @default null
   * @public
   * @memberof i18n/I18nDecorator.I18nDecorator.defaultConfig
   */
  nonLatinLanguageOverrides: null,

  /**
   * Array of resource loaders to be invoked after a locale change.
   *
   * Each loader must be a function which accepts an object and returns either the resource when
   * `options.sync` is `true` or a `Promise` for the resource when `options.sync` is `false`.
   *
   * ```
   * resources: [
   *   (options) => new Promise((resolve, reject) => {
   *     fetchResource({onLoad: resolve, onError: reject});
   *   })
   * ]
   * ```
   *
   * If you need to handle the resource in some way on load, you can pass an object with an
   * `onLoad` member that will be called once all resources have been loaded. This should be used
   * if loading a resource has side effects that should only be applied once all loading has
   * completed.
   *
   * ```
   * resources: [
   *   {resource: (options) => { ... fetch ... }, onLoad: (res) => { ... apply side effect ... }}
   * ]
   * ```
   *
   * @type {Array<Function|Object>}
   * @default null
   * @public
   * @memberof i18n/I18nDecorator.I18nDecorator.defaultConfig
   */
  resources: null,

  /**
   * Retrieve i18n resource files synchronously
   *
   * @type {Boolean}
   * @default false
   * @public
   * @memberof i18n/I18nDecorator.I18nDecorator.defaultConfig
   */
  sync: false
};
/**
 * A higher-order component that is used to wrap the root element in an app. It provides an `rtl` member on the
 * context of the wrapped component, allowing the children to check the current text directionality as well as
 * an `updateLocale` method that can be used to update the current locale.
 *
 * There are no configurable options on this HOC.
 *
 * @class I18nDecorator
 * @memberof i18n/I18nDecorator
 * @hoc
 * @public
 */

var I18nDecorator = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class, _temp;

  var latinLanguageOverrides = config.latinLanguageOverrides,
      nonLatinLanguageOverrides = config.nonLatinLanguageOverrides,
      sync = config.sync; // Normalize the structure of the external resources to be an array of resource/onLoad pairs

  var extResources = Array.isArray(config.resources) ? config.resources.map(function (res) {
    if (!res) return;
    var fn = res.resource || res;
    var onLoad = res.onLoad;
    if (typeof fn !== 'function') return;
    return {
      resource: fn,
      onLoad: onLoad
    };
  }).filter(Boolean) : [];
  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(_class, _React$Component);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));

      _this.handleLocaleChange = function () {
        (0, _windowFocus.onWindowFocus)(_this.updateLocale);
      };

      _this.updateLocale = function (newLocale) {
        var state = _this.getDerivedStateForLocale(newLocale);

        if (sync) {
          _this.setState(state);
        } else {
          _this.loadResources(newLocale);

          _this.setState({
            resourcesLoaded: false
          });
        }
      };

      var ilibLocale = _index["default"].getLocale();

      var locale = props.locale && props.locale !== ilibLocale ? props.locale : ilibLocale;
      _this.loadResourceJob = new _util.Job(_this.setState.bind(_assertThisInitialized(_this)));
      _this.state = _this.getDerivedStateForLocale(locale);
      return _this;
    }

    _createClass(_class, [{
      key: "getChildContext",
      value: function getChildContext() {
        return {
          rtl: this.state.rtl,
          updateLocale: this.updateLocale
        };
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
          (0, _dispatcher.on)('languagechange', this.handleLocaleChange, window);
        }

        if (!sync) {
          this.loadResources(this.state.locale);
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.props.locale !== prevProps.locale) {
          var state = this.getDerivedStateForLocale(this.props.locale);

          if (sync) {
            // eslint-disable-next-line react/no-did-update-set-state
            this.setState(state);
          } else {
            this.loadResources(this.props.locale);
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.loadResourceJob.stop();

        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
          (0, _dispatcher.off)('languagechange', this.handleLocaleChange, window);
        }
      }
    }, {
      key: "getDerivedStateForLocale",
      value: function getDerivedStateForLocale(spec) {
        var locale = (0, _locale.updateLocale)(spec);
        var state = {
          locale: locale,
          resourcesLoaded: sync
        };

        if (sync) {
          var options = {
            locale: locale,
            sync: sync
          };
          state.rtl = (0, _wrapIlibCallback["default"])(_locale.isRtlLocale, options);
          state.classes = (0, _wrapIlibCallback["default"])(_getI18nClasses["default"], _objectSpread({}, options, {
            latinLanguageOverrides: latinLanguageOverrides,
            nonLatinLanguageOverrides: nonLatinLanguageOverrides
          }));
          var bundle = (0, _wrapIlibCallback["default"])(_resBundle.createResBundle, options);
          (0, _resBundle.setResBundle)(bundle);
          extResources.forEach(function (_ref) {
            var resource = _ref.resource,
                onLoad = _ref.onLoad;
            var result = resource(options);
            if (onLoad) onLoad(result);
          });
        }

        return state;
      }
    }, {
      key: "loadResources",
      value: function loadResources(locale) {
        var options = {
          sync: sync,
          locale: locale
        };
        var resources = Promise.all([(0, _wrapIlibCallback["default"])(_locale.isRtlLocale, options), (0, _wrapIlibCallback["default"])(_getI18nClasses["default"], _objectSpread({}, options, {
          latinLanguageOverrides: latinLanguageOverrides,
          nonLatinLanguageOverrides: nonLatinLanguageOverrides
        })), // move updating into a new method with call to setState
        (0, _wrapIlibCallback["default"])(_resBundle.createResBundle, options)].concat(_toConsumableArray(extResources.map(function (res) {
          return (0, _wrapIlibCallback["default"])(res.resource, options);
        })))).then(function (_ref2) {
          var _ref3 = _toArray(_ref2),
              rtl = _ref3[0],
              classes = _ref3[1],
              bundle = _ref3[2],
              userResources = _ref3.slice(3);

          (0, _resBundle.setResBundle)(bundle);
          extResources.forEach(function (_ref4, i) {
            var onLoad = _ref4.onLoad;
            return onLoad && onLoad(userResources[i]);
          });
          return {
            locale: locale,
            classes: classes,
            rtl: rtl,
            resourcesLoaded: true
          };
        }); // TODO: Resolve how to handle failed resource resquests
        // .catch(...);

        this.loadResourceJob.promise(resources);
      }
    }, {
      key: "render",
      value: function render() {
        var props = Object.assign({}, this.props);
        delete props.locale;
        props.className = join(this.state.classes, this.props.className);
        var value = {
          locale: this.state.locale,
          rtl: this.state.rtl,
          loaded: this.state.resourcesLoaded,
          updateLocale: this.updateLocale
        };
        return _react["default"].createElement(I18nContext.Provider, {
          value: value
        }, _react["default"].createElement(Wrapped, props));
      }
    }]);

    return _class;
  }(_react["default"].Component), _class.displayName = 'I18nDecorator', _class.propTypes =
  /** @lends i18n/I18nDecorator.I18nDecorator.prototype */
  {
    /**
     * Classname for a root app element.
     *
     * @type {String}
     * @public
     */
    className: _propTypes["default"].string,

    /**
     * A string with a {@link https://tools.ietf.org/html/rfc5646|BCP 47 language tag}.
     *
     * The system locale will be used by default.
     *
     * @type {String}
     * @public
     */
    locale: _propTypes["default"].string
  }, _class.childContextTypes = contextTypes, _temp;
});
exports.I18nDecorator = I18nDecorator;
var contextDefaultConfig = {
  localeProp: null,
  rtlProp: null,
  updateLocaleProp: null
};
var I18nContextDecorator = (0, _hoc["default"])(contextDefaultConfig, function (config, Wrapped) {
  var loadedProp = config.loadedProp,
      localeProp = config.localeProp,
      rtlProp = config.rtlProp,
      updateLocaleProp = config.updateLocaleProp; // eslint-disable-next-line no-shadow

  return function I18nContextDecorator(props) {
    return _react["default"].createElement(I18nContext.Consumer, null, function (i18nContext) {
      if (i18nContext) {
        var loaded = i18nContext.loaded,
            locale = i18nContext.locale,
            rtl = i18nContext.rtl,
            update = i18nContext.updateLocale;
        props = Object.assign({}, props);

        if (loadedProp) {
          props[loadedProp] = loaded;
        }

        if (localeProp) {
          props[localeProp] = locale;
        }

        if (rtlProp) {
          props[rtlProp] = rtl;
        }

        if (updateLocaleProp) {
          props[updateLocaleProp] = update;
        }
      }

      return _react["default"].createElement(Wrapped, props);
    });
  };
});
exports.I18nContextDecorator = I18nContextDecorator;
var _default = I18nDecorator;
exports["default"] = _default;