"use strict";

var _handle = require("../handle");

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

describe('handle', function () {
  var makeEvent = function makeEvent(payload) {
    return _objectSpread({
      preventDefault: jest.fn(),
      stopPropagation: jest.fn()
    }, payload);
  };

  var returnsTrue = function returnsTrue() {
    return true;
  };

  var returnsFalse = function returnsFalse() {
    return false;
  };

  test('should call only handler', function () {
    var handler = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler);
    callback(makeEvent());
    var expected = 1;
    var actual = handler.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should call multiple handlers', function () {
    var handler1 = jest.fn(returnsTrue);
    var handler2 = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler1, handler2);
    callback(makeEvent());
    var expected = true;
    var actual = handler1.mock.calls.length === 1 && handler2.mock.calls.length === 1;
    expect(actual).toBe(expected);
  });
  test('should skip non-function handlers', function () {
    var handler = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(null, void 0, 0, 'purple', handler);
    callback(makeEvent());
    var expected = 1;
    var actual = handler.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should not call handlers after one that returns false', function () {
    var handler1 = jest.fn(returnsTrue);
    var handler2 = jest.fn(returnsTrue);
    var callback = (0, _handle.handle)(handler1, returnsFalse, handler2);
    callback(makeEvent());
    var expected = 0;
    var actual = handler2.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should call stopPropagation on event', function () {
    var callback = (0, _handle.handle)(_handle.stop);
    var ev = makeEvent();
    callback(ev);
    var expected = 1;
    var actual = ev.stopPropagation.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should call preventDefault on event', function () {
    var callback = (0, _handle.handle)(_handle.preventDefault);
    var ev = makeEvent();
    callback(ev);
    var expected = 1;
    var actual = ev.preventDefault.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should call any method on event', function () {
    var callback = (0, _handle.handle)((0, _handle.callOnEvent)('customMethod'));
    var ev = makeEvent({
      customMethod: jest.fn()
    });
    callback(ev);
    var expected = 1;
    var actual = ev.customMethod.mock.calls.length;
    expect(actual).toBe(expected);
  });
  test('should only call handler for specified keyCode', function () {
    var keyCode = 13;
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forKeyCode)(keyCode), handler);
    callback(makeEvent());
    expect(handler).not.toHaveBeenCalled();
    callback(makeEvent({
      keyCode: keyCode
    }));
    expect(handler).toHaveBeenCalled();
  });
  test('should only call handler for specified event prop', function () {
    var prop = 'index';
    var value = 0;
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forEventProp)(prop, value), handler); // undefined shouldn't pass

    callback(makeEvent());
    expect(handler).not.toHaveBeenCalled(); // == check shouldn't pass

    callback(makeEvent(_defineProperty({}, prop, false)));
    expect(handler).not.toHaveBeenCalled(); // === should pass

    callback(makeEvent(_defineProperty({}, prop, value)));
    expect(handler).toHaveBeenCalled();
  });
  test('should only call handler for specified prop', function () {
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forProp)('checked', true), handler); // undefined shouldn't pass

    callback({}, {});
    expect(handler).not.toHaveBeenCalled(); // == check shouldn't pass

    callback({}, {
      checked: 1
    });
    expect(handler).not.toHaveBeenCalled(); // === should pass

    callback({}, {
      checked: true
    });
    expect(handler).toHaveBeenCalled();
  });
  test('should forward events to function specified in provided props', function () {
    var event = 'onMyClick';
    var prop = 'index';
    var propValue = 0;
    var spy = jest.fn();

    var props = _defineProperty({}, event, spy);

    var payload = _defineProperty({}, prop, propValue);

    (0, _handle.handle)((0, _handle.forward)(event))(payload, props);
    var expected = true;
    var actual = spy.mock.calls[0][0][prop] === propValue;
    expect(actual).toBe(expected);
  });
  test('should forwardWithPrevent events to function specified in provided props when preventDefault() hasn\'t been called', function () {
    var event = 'onMyClick';
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forwardWithPrevent)(event), handler);
    callback();
    expect(handler).toHaveBeenCalledTimes(1);
  });
  test('should not forwardWithPrevent events to function specified in provided props when preventDefault() has been called', function () {
    var event = 'onMyClick';
    var handler = jest.fn();
    var callback = (0, _handle.handle)((0, _handle.forwardWithPrevent)(event), handler); // should stop chain when `preventDefault()` has been called

    callback({}, {
      'onMyClick': function onMyClick(ev) {
        return ev.preventDefault();
      }
    });
    expect(handler).not.toHaveBeenCalled();
  });
  test('should include object props as second arg when bound', function () {
    var componentInstance = {
      context: {},
      props: {
        value: 1
      }
    };
    var handler = jest.fn();

    var h = _handle.handle.bind(componentInstance);

    var callback = h(handler);
    callback();
    var expected = 1;
    var actual = handler.mock.calls[0][1].value;
    expect(actual).toBe(expected);
  });
  test('should include object context as third arg when bound', function () {
    var componentInstance = {
      context: {
        value: 1
      },
      props: {}
    };
    var handler = jest.fn();

    var h = _handle.handle.bind(componentInstance);

    var callback = h(handler);
    callback();
    var expected = 1;
    var actual = handler.mock.calls[0][2].value;
    expect(actual).toBe(expected);
  });
  describe('finally', function () {
    test('should call the finally callback when handle returns true', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(returnsTrue)["finally"](finallyCallback);
      callback(makeEvent());
      var expected = 1;
      var actual = finallyCallback.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('should call the finally callback when handle returns false', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(returnsFalse)["finally"](finallyCallback);
      callback(makeEvent());
      var expected = 1;
      var actual = finallyCallback.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('should call the finally callback when handle throws an error', function () {
      var finallyCallback = jest.fn();
      var callback = (0, _handle.handle)(function () {
        throw new Error('Something has gone awry ...');
      })["finally"](finallyCallback);

      try {
        callback(makeEvent());
      } catch (e) {// we don't want the error to interrupt the test
      }

      var expected = 1;
      var actual = finallyCallback.mock.calls.length;
      expect(actual).toBe(expected);
    });
  });
  describe('#oneOf', function () {
    test('should call each handler until one passes', function () {
      var handler = jest.fn(returnsTrue);
      var h1 = [returnsFalse, handler];
      var h2 = [returnsTrue, handler];
      var callback = (0, _handle.oneOf)(h1, h1, h2);
      callback();
      var expected = 1;
      var actual = handler.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('should stop if the first handler passes', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([returnsTrue, handler], [returnsTrue, handler], [returnsTrue, handler]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls.length;
      expect(actual).toBe(expected);
    });
    test('should pass args to condition', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([handler, returnsTrue]);
      var ev = {
        value: 1
      };
      callback(ev);
      var expected = ev;
      var actual = handler.mock.calls[0][0];
      expect(actual).toBe(expected);
    });
    test('should pass args to handlers', function () {
      var handler = jest.fn(returnsTrue);
      var callback = (0, _handle.oneOf)([returnsTrue, handler]);
      var ev = {
        value: 1
      };
      callback(ev);
      var expected = ev;
      var actual = handler.mock.calls[0][0];
      expect(actual).toBe(expected);
    });
    test('should return true when the passed condition branch returns a truthy value', function () {
      var callback = (0, _handle.oneOf)([returnsTrue, function () {
        return 'ok';
      }]);
      var expected = true;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should return false when the passed condition branch returns a falsy value', function () {
      var callback = (0, _handle.oneOf)([returnsTrue, function () {
        return null;
      }]);
      var expected = false;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should return false when no conditions pass', function () {
      var callback = (0, _handle.oneOf)([returnsFalse, returnsTrue], [returnsFalse, returnsTrue]);
      var expected = false;
      var actual = callback();
      expect(actual).toBe(expected);
    });
    test('should support bound handlers', function () {
      var componentInstance = {
        props: {},
        context: {
          value: 1
        }
      };
      var handler = jest.fn();

      var h = _handle.handle.bind(componentInstance);

      var callback = (0, _handle.oneOf)([returnsTrue, h(handler)]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][2].value;
      expect(actual).toBe(expected);
    });
    test('should include object props as second arg when bound', function () {
      var componentInstance = {
        props: {
          value: 1
        },
        context: {}
      };
      var handler = jest.fn();

      var o = _handle.oneOf.bind(componentInstance);

      var callback = o([returnsTrue, handler]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][1].value;
      expect(actual).toBe(expected);
    });
    test('should include object context as third arg when bound', function () {
      var componentInstance = {
        props: {},
        context: {
          value: 1
        }
      };
      var handler = jest.fn();

      var o = _handle.oneOf.bind(componentInstance);

      var callback = o([returnsTrue, handler]);
      callback();
      var expected = 1;
      var actual = handler.mock.calls[0][2].value;
      expect(actual).toBe(expected);
    });
    test('should support finally callback', function () {
      var handler = jest.fn();
      var callback = (0, _handle.oneOf)([returnsFalse, returnsTrue], [returnsFalse, returnsTrue])["finally"](handler);
      callback();
      var expected = 1;
      var actual = handler.mock.calls.length;
      expect(actual).toBe(expected);
    });
  });
  describe('#adaptEvent', function () {
    test('should pass the adapted event payload to the provided handler', function () {
      var handler = jest.fn();

      var onlyValue = function onlyValue(_ref) {
        var value = _ref.value;
        return {
          value: value
        };
      };

      var ev = {
        value: 1,
        message: 'ok'
      };
      (0, _handle.adaptEvent)(onlyValue, handler)(ev);
      var expected = {
        value: 1
      };
      var actual = handler.mock.calls[0][0];
      expect(actual).toEqual(expected);
    });
    test('should pass additional arguments to the provided handler', function () {
      var handler = jest.fn();

      var returnOne = function returnOne() {
        return 1;
      };

      (0, _handle.adaptEvent)(returnOne, handler)(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
    test('should support bound adapter function', function () {
      var obj = {
        adapt: function adapt() {
          return 1;
        }
      };
      var handler = jest.fn();
      var fn = (0, _handle.adaptEvent)((0, _handle.call)('adapt'), handler).bind(obj);
      fn(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
    test('should support bound handler function', function () {
      var obj = {
        handler: jest.fn()
      };

      var returnOne = function returnOne() {
        return 1;
      };

      var fn = (0, _handle.adaptEvent)(returnOne, (0, _handle.call)('handler')).bind(obj);
      fn(0, 2, 3);
      var expected = [1, 2, 3];
      var actual = obj.handler.mock.calls[0];
      expect(actual).toEqual(expected);
    });
  });
});