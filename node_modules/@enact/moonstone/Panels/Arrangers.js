"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ActivityArranger = exports.AlwaysViewingArranger = void 0;

var _arrange = require("@enact/ui/ViewManager/arrange");

var _quadInOut = _interopRequireDefault(require("eases/quad-in-out"));

var _resolution = require("@enact/ui/resolution");

var _Breadcrumb = require("./Breadcrumb");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/*
 * Panel arrangers have a unique design requirement that varies their transition depending on the
 * direction (reverse) of the transition. This takes the two arrangement functions and returns
 * another function that picks which to call based on the value of `reverseTransition`.
 *
 * @param {Function} f forward function
 * @param {Function} b backward function
 * @returns {Function} Arrangement function
 * @private
 */
var forwardBackward = function forwardBackward(f, b) {
  return function (config) {
    var f2 = config.reverseTransition ? b : f;
    f2(config);
  };
};
/*
 * Utility method to apply the same easing and reset the transform before applying `fn`
 *
 * @param   {Function} fn Arrangement function
 * @returns {Function}    Composed arrangement function
 * @private
 */


var base = function base(fn) {
  return (0, _arrange.reverse)((0, _arrange.ease)(_quadInOut["default"], (0, _arrange.compose)(_arrange.clearTransform, fn)));
}; // Creating these here since they're composed below in forwardBackward


var slideInRight = base((0, _arrange.slideIn)('right'));
var slideOutLeft = base((0, _arrange.slideOut)('left')); // These are the arrangers for AlwaysViewing but also composed in Activity

var panelEnter = forwardBackward(slideInRight, (0, _arrange.endBy)(0.75, slideInRight));
var panelLeave = forwardBackward(slideOutLeft, (0, _arrange.endBy)(0.75, slideOutLeft)); // Always-Viewing Arranger

/**
 * Arranger that slides panels in from the right and out to the left
 *
 * @type {Arranger}
 * @private
 */

var AlwaysViewingArranger = {
  enter: panelEnter,
  leave: panelLeave
}; // Actvity Arranger

/*
 * Appends a transform that accounts for a single breadcrumb
 *
 * @param  {Node} node      DOM Node
 *
 * @returns {undefined}
 * @private
 */

exports.AlwaysViewingArranger = AlwaysViewingArranger;

var offsetForBreadcrumbs = function offsetForBreadcrumbs(_ref) {
  var node = _ref.node;
  var isFirst = node && node.dataset && node.dataset.index === '0';

  if (!isFirst) {
    var x = (0, _resolution.unit)((0, _resolution.scale)(_Breadcrumb.breadcrumbWidth), 'rem');
    (0, _arrange.appendTransform)("translateX(".concat(x, ")"), {
      node: node
    });
  }
}; // Adds the data-clip attribute to allow clipping when transitioning between non-zero panels
// CSS is enforced by Panels.module.less


var clipForBreadcrumbs = function clipForBreadcrumbs(_ref2) {
  var from = _ref2.from,
      node = _ref2.node,
      percent = _ref2.percent,
      to = _ref2.to;
  var viewport = node.parentNode;

  if (to === 0 || from === 0 || percent === 0 || percent === 1) {
    // remove clip when moving to or from the first panel and when a transition is completing
    delete viewport.dataset.clip;
  } else {
    viewport.dataset.clip = 'true';
  }
};
/**
 * Arranger that slides panels in from the right and out to the left allowing space for the single
 * breadcrumb when `to` index is greater than zero.
 *
 * @type {Arranger}
 * @private
 */


var ActivityArranger = {
  enter: (0, _arrange.compose)(panelEnter, (0, _arrange.reverse)(offsetForBreadcrumbs), clipForBreadcrumbs),
  leave: (0, _arrange.compose)(panelLeave, offsetForBreadcrumbs),
  // Need a stay arrangement in case the initial index for ActivityPanels is > 0 so the panel is
  // correctly offset for the breadcrumbs.
  stay: (0, _arrange.compose)(_arrange.clearTransform, offsetForBreadcrumbs)
};
exports.ActivityArranger = ActivityArranger;