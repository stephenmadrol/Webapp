"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Knob", {
  enumerable: true,
  get: function get() {
    return _Knob["default"];
  }
});
exports.SliderDecorator = exports.SliderBase = exports.Slider = exports["default"] = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _compose = _interopRequireDefault(require("ramda/src/compose"));

var _react = _interopRequireDefault(require("react"));

var _Changeable = _interopRequireDefault(require("../Changeable"));

var _ComponentOverride = _interopRequireDefault(require("../ComponentOverride"));

var _Touchable = _interopRequireDefault(require("../Touchable"));

var _Knob = _interopRequireDefault(require("./Knob"));

var _PositionDecorator = _interopRequireDefault(require("./PositionDecorator"));

var _SliderModule = _interopRequireDefault(require("./Slider.module.css"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * An unstyled, sliding range-selection component.
 *
 * @class SliderBase
 * @memberof ui/Slider
 * @ui
 * @public
 */
var SliderBase = (0, _kind["default"])({
  name: 'ui:Slider',
  propTypes:
  /** @lends ui/Slider.SliderBase.prototype */
  {
    /**
     * The component used to render the progress bar within the slider.
     *
     * The provided component will receive the following props from `Slider`
     *
     * * backgroundProgress - The value of `backgroundProgress`
     * * orientation        - The value of `orientation`
     * * progress           - The `value` as a proportion between `min` and `max`
     * * progressAnchor     - The value of `progressAnchor`
     *
     * This prop accepts either a Component (e.g. `MyProgress`} which will be instantiated with
     * the above props or a component instance (e.g. `<MyProgress customProp="value" />`) which
     * will have its props merged with the above props.
     *
     * @type {Component|Element}
     * @required
     * @public
     */
    progressBarComponent: _propTypes["default"].componentOverride.isRequired,

    /**
     * Background progress, as a proportion between `0` and `1`.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    backgroundProgress: _propTypes2["default"].number,

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal Elements and states of this component.
     *
     * The following classes are supported:
     *
     * * `slider`     - The root component class
     * * `knob`       - The knob node
     * * `horizontal` - Applied when `orientation` prop is `"horizontal"``
     * * `pressed`    - Applied when `pressed` prop is `true`
     * * `noFill`     - Applied when `noFill` prop is `true`
     * * `vertical`   - Applied when `orientation` prop is `"vertical"`
     *
     * @type {Object}
     * @public
     */
    css: _propTypes2["default"].object,

    /**
     * Disables component and does not generate events.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    disabled: _propTypes2["default"].bool,

    /**
     * Defines a custom knob component for the slider.
     *
     * By default, Slider will use its own implementation, {@link ui/Slider.Knob}.
     *
     * The following props are forwarded to the knob:
     *
     * * `className`        - A `knob` class applied by the slider
     * * `disabled`         - The value of `disabled`
     * * `orientation`      - The value of `orientation`
     * * `proportion`       - The `value` as a proportion between `min` and `max`
     * * `tooltipComponent` - The value of `tooltipComponent`
     * * `value`            - The value of `value`
     *
     * This prop accepts either a Component (e.g. `MyKnob`} which will be instantiated with
     * the above props or a component instance (e.g. `<MyKnob customProp="value" />`) which
     * will have its props merged with the above props.
     *
     * @see {@link ui/ComponentOverride}
     *
     * @type {Component|Element}
     * @default {@link ui/Slider.Knob}
     * @public
     */
    knobComponent: _propTypes["default"].componentOverride,

    /**
     * The maximum value of the slider.
     *
     * The range between `min` and `max` should be evenly divisible by
     * [step]{@link ui/Slider.SliderBase.step}.
     *
     * @type {Number}
     * @default 100
     * @public
     */
    max: _propTypes2["default"].number,

    /**
     * The minimum value of the slider.
     *
     * The range between `min` and `max` should be evenly divisible by
     * [step]{@link ui/Slider.SliderBase.step}.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    min: _propTypes2["default"].number,

    /**
     * Applies the style where the slider bar does not display filled.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    noFill: _propTypes2["default"].bool,

    /**
     * The orientation of the slider, either `"horizontal"` or `"vertical"`.
     *
     * @type {String}
     * @default "horizontal"
     * @public
     */
    orientation: _propTypes2["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Applies a pressed visual effect.
     *
     * @type {Boolean}
     * @public
     */
    pressed: _propTypes2["default"].bool,

    /**
     * Sets the point, as a proportion between 0 and 1, from which the slider is filled.
     *
     * Applies to both the slider's `value` and `backgroundProgress`. In both cases,
     * setting the value of `progressAnchor` will cause the slider to fill from that point
     * down, when `value` or `backgroundProgress` is proportionally less than the anchor, or up,
     * when `value` or `backgroundProgress` is proportionally greater than the anchor, rather
     * than always from the start of the slider.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    progressAnchor: _propTypes2["default"].number,

    /**
     * The amount to increment or decrement the value.
     *
     * It must evenly divide into the range designated by `min` and `max`.
     *
     * @type {Number}
     * @default 1
     * @public
     */
    step: _propTypes2["default"].number,

    /**
     * Adds a tooltip to the slider using the provided component.
     *
     * The following props are forwarded to the tooltip:
     *
     * * `children`    - The `value` prop from the slider
     * * `orientation` - The value of the `orientation` prop from the slider
     * * `proportion`  - The `value` as a proportion between `min` and `max`
     *
     * This prop accepts either a Component (e.g. `MyTooltip`} which will be instantiated with
     * the above props or a component instance (e.g. `<MyTooltip customProp="value" />`) which
     * will have its props merged with the above props.
     *
     * @see {@link ui/ComponentOverride}
     *
     * @type {Component|Element}
     * @public
     */
    tooltipComponent: _propTypes["default"].componentOverride,

    /**
     * The value of the slider.
     *
     * Defaults to the value of `min`.
     *
     * @type {Number}
     * @public
     */
    value: _propTypes2["default"].number
  },
  defaultProps: {
    disabled: false,
    knobComponent: _Knob["default"],
    min: 0,
    max: 100,
    noFill: false,
    orientation: 'horizontal',
    progressAnchor: 0,
    step: 1
  },
  styles: {
    css: _SliderModule["default"],
    className: 'slider',
    publicClassNames: true
  },
  computed: {
    className: function className(_ref) {
      var disabled = _ref.disabled,
          noFill = _ref.noFill,
          orientation = _ref.orientation,
          pressed = _ref.pressed,
          styler = _ref.styler;
      return styler.append(orientation, {
        disabled: disabled,
        noFill: noFill,
        pressed: pressed
      });
    },
    percent: function percent(_ref2) {
      var max = _ref2.max,
          min = _ref2.min,
          _ref2$value = _ref2.value,
          value = _ref2$value === void 0 ? min : _ref2$value;
      return (0, _utils.calcProportion)(min, max, value);
    },
    style: function style(_ref3) {
      var max = _ref3.max,
          min = _ref3.min,
          _style = _ref3.style,
          _ref3$value = _ref3.value,
          value = _ref3$value === void 0 ? min : _ref3$value;
      var proportion = (0, _utils.calcProportion)(min, max, value);
      return _objectSpread({}, _style, {
        '--ui-slider-proportion-end-knob': proportion
      });
    }
  },
  render: function render(_ref4) {
    var backgroundProgress = _ref4.backgroundProgress,
        css = _ref4.css,
        disabled = _ref4.disabled,
        knobComponent = _ref4.knobComponent,
        min = _ref4.min,
        orientation = _ref4.orientation,
        percent = _ref4.percent,
        progressBarComponent = _ref4.progressBarComponent,
        progressAnchor = _ref4.progressAnchor,
        tooltipComponent = _ref4.tooltipComponent,
        _ref4$value = _ref4.value,
        value = _ref4$value === void 0 ? min : _ref4$value,
        rest = _objectWithoutProperties(_ref4, ["backgroundProgress", "css", "disabled", "knobComponent", "min", "orientation", "percent", "progressBarComponent", "progressAnchor", "tooltipComponent", "value"]);

    delete rest.max;
    delete rest.noFill;
    delete rest.pressed;
    delete rest.step;
    return _react["default"].createElement("div", Object.assign({}, rest, {
      disabled: disabled
    }), _react["default"].createElement(_ComponentOverride["default"], {
      backgroundProgress: backgroundProgress,
      component: progressBarComponent,
      orientation: orientation,
      progress: percent,
      progressAnchor: progressAnchor
    }, _react["default"].createElement(_ComponentOverride["default"], {
      className: css.knob,
      component: knobComponent,
      disabled: disabled,
      orientation: orientation,
      proportion: percent,
      tooltipComponent: tooltipComponent,
      value: value
    })));
  }
});
/**
 * Adds touch and drag support to a [SliderBase]{@link ui/Slider.SliderBase}.
 *
 * @hoc
 * @memberof ui/Slider
 * @mixes ui/Changeable.Changeable
 * @mixes ui/Touchable.Touchable
 * @public
 */

exports.SliderBase = SliderBase;
var SliderDecorator = (0, _compose["default"])(_Changeable["default"], _PositionDecorator["default"], (0, _Touchable["default"])({
  activeProp: 'pressed'
}));
/**
 * A minimally-styled slider component with touch and drag support.
 *
 * @class Slider
 * @extends ui/Slider.SliderBase
 * @memberof ui/Slider
 * @mixes ui/Slider.SliderDecorator
 * @ui
 * @public
 */

/**
 * Called when the value is changed.
 *
 * @name onChange
 * @memberof ui/Slider.Slider.prototype
 * @type {Function}
 * @param {Object} event
 * @param {Number} event.value      Value of the slider
 * @param {Number} event.proportion Proportion of the value in terms of the min and max
 *                                  values
 * @public
 */

exports.SliderDecorator = SliderDecorator;
var Slider = SliderDecorator(SliderBase);
exports.Slider = Slider;
var _default = Slider;
exports["default"] = _default;