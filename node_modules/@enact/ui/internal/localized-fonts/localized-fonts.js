"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var fontMap = {};
var currentLocale = null; // Generate a single font-face rule

var buildFont = function buildFont(inOptions) {
  if (!inOptions && !inOptions.name) {
    return '';
  }

  var strOut = '@font-face { \n' + "  font-family: \"".concat(inOptions.name, "\";\n") + "  font-weight: ".concat(inOptions.weight || 'normal', ";\n");

  if (inOptions.localName) {
    strOut += "  src: local(\"".concat(inOptions.localName, "\");\n");
  }

  if (inOptions.unicodeRange) {
    strOut += "  unicode-range: ".concat(inOptions.unicodeRange, ";\n");
  }

  strOut += '} \n';
  return strOut;
}; // Generate a collection of font-face rules, in multiple font-variants


var buildFontSet = function buildFontSet(fontName, fonts, strLang, bitDefault) {
  var strOut = '',
      name = bitDefault ? fontName : fontName + ' ' + strLang;

  if (fonts[strLang].regular) {
    // Build Regular
    strOut += buildFont({
      name: name,
      localName: fonts[strLang].regular,
      weight: 400,
      unicodeRange: fonts[strLang].unicodeRange
    }); // Build Bold

    strOut += buildFont({
      name: name,
      localName: fonts[strLang].bold || fonts[strLang].regular,
      // fallback to regular
      weight: 700,
      unicodeRange: fonts[strLang].unicodeRange
    }); // Build Light

    strOut += buildFont({
      name: name,
      localName: fonts[strLang].light || fonts[strLang].regular,
      // fallback to regular
      weight: 300,
      unicodeRange: fonts[strLang].unicodeRange
    });
  }

  return strOut;
};

var buildFontDefinitionCss = function buildFontDefinitionCss(locale, buildOverrides) {
  var matchLang = locale.match(/\b([a-z]{2})\b/),
      language = matchLang && matchLang[1],
      matchReg = locale.match(/\b([A-Z]{2}|[0-9]{3})\b/),
      region = matchReg && matchReg[1];
  var fontDefinitionCss = ''; // Build all the fonts so they could be explicitly called

  for (var fontName in fontMap) {
    var fonts = fontMap[fontName];

    for (var lang in fonts) {
      if (!buildOverrides) {
        fontDefinitionCss += buildFontSet(fontName, fonts, lang);
      } else {
        // Set up the override for locale-specific font.
        // la = language, re = region; `la-RE`
        var _lang$split = lang.split('-'),
            _lang$split2 = _slicedToArray(_lang$split, 2),
            la = _lang$split2[0],
            re = _lang$split2[1];

        if (la === language) {
          if (!re || re && re === region) {
            fontDefinitionCss += buildFontSet(fontName, fonts, lang, true);
          }
        }
      }
    }
  }

  return fontDefinitionCss;
};

var insertFontDefinitionCss = function insertFontDefinitionCss(styleId, fontDefinitionCss) {
  if (typeof document !== 'undefined') {
    // Normal execution in a browser window
    var styleElem = document.getElementById(styleId);

    if (!styleElem) {
      styleElem = document.createElement('style');
      styleElem.setAttribute('id', styleId);
      styleElem.setAttribute('type', 'text/css');
      document.head.appendChild(styleElem);
    }

    styleElem.innerHTML = fontDefinitionCss;
  } else {
    var tag = "<style type=\"text/css\" id=\"".concat(styleId, "\">").concat(fontDefinitionCss, "</style>"); // We're rendering without the DOM; return the font definition stylesheet element string.

    return tag;
  }
};

function fontGenerator(locale) {
  var styleId = 'localized-fonts';

  if (typeof document !== 'undefined' && document.getElementById(styleId)) {
    return;
  }

  return insertFontDefinitionCss(styleId, buildFontDefinitionCss(locale));
}

function fontOverrideGenerator(locale) {
  return insertFontDefinitionCss('localized-fonts-override', buildFontDefinitionCss(locale, true));
}
/**
 * Generates locale-specific font rules allowing any locale to have its own custom font. Each
 * locale-font from the configuration block (defined in this file) is generated at run-time. If the
 * locale you're currently in is in the locale-font list an additional `@font-face` rule will be
 * generated that will override the standard font.
 *
 * In addition to the standard override-font being generated, named region-specific fonts are also
 * generated. This lets you incorporate language specific fonts when you're outside of one of those
 * regions; useful in a language list context where you want the name of each language to be
 * represented by that language's designated font.
 *
 * Below is example genarated-output of the Urdu ("ur") locale-font.
 *
 * ```css
 * &#64;font-face {
 * 	font-family: 'Custom Font ur';
 * 	font-weight: 500;
 * 	src: local('CustomFont_Urdu');
 * 	unicode-range: U+0600-U+06FF, U+FE70-U+FEFE, U+FB50-U+FDFF;
 * }
 * &#64;font-face {
 * 	font-family: 'Custom Font ur Bold';
 * 	font-weight: 700;
 * 	src: local('CustomFont_Urdu');
 * 	unicode-range: U+0600-U+06FF, U+FE70-U+FEFE, U+FB50-U+FDFF;
 * }
 * &#64;font-face {
 * 	font-family: 'Custom Font ur Light';
 * 	font-weight: 300;
 * 	src: local('CustomFont_Urdu');
 * 	unicode-range: U+0600-U+06FF, U+FE70-U+FEFE, U+FB50-U+FDFF;
 * }
 * ```
 *
 * @param {String} locale Locale string in the format
 * @returns {String} An HTML fragment of the `<style>` when prerendering
 *
 * @public
 */


function generateFontRules(locale) {
  if (!locale || locale === currentLocale) {
    return;
  }

  currentLocale = locale;
  return fontGenerator(locale);
}

function generateFontOverrideRules(locale) {
  if (!locale) {
    return;
  }

  return fontOverrideGenerator(locale);
}
/**
 * Adds a localed font to the font map
 *
 * ```
 * addLocalizedFont('My Theme Font', {
 *   'ur': {
 *      regular: 'My Theme Urdu',
 *      unicodeRange:
 *        'U+600-6FF,' +
 *        'U+FE70-FEFE,' +
 *        'U+FB50-FDFF'
 *    }
 * })
 * ```
 *
 * @param {String} name  Name of the font
 * @param {Object} fonts Object mapping font names and unicode ranges to locales
 *
 * @public
 */


function addLocalizedFont(name, fonts) {
  fontMap[name] = fonts;

  if (currentLocale) {
    fontGenerator(currentLocale);
  }
}
/**
 * Removes a localized font from the font map
 *
 * @param   {String} name Name of the font
 *
 * @public
 */


function removeLocalizedFont(name) {
  delete fontMap[name];

  if (currentLocale) {
    fontGenerator(currentLocale);
  }
}

module.exports = generateFontRules;
module.exports.generateFontRules = generateFontRules;
module.exports.generateFontOverrideRules = generateFontOverrideRules;
module.exports.addLocalizedFont = addLocalizedFont;
module.exports.removeLocalizedFont = removeLocalizedFont;