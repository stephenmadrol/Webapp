"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarqueeDecorator = exports["default"] = void 0;

var _direction = _interopRequireDefault(require("direction"));

var _dispatcher = require("@enact/core/dispatcher");

var _handle = require("@enact/core/handle");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _keymap = require("@enact/core/keymap");

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _shallowEqual = _interopRequireDefault(require("recompose/shallowEqual"));

var _Resizable = require("../Resizable");

var _MarqueeBase = _interopRequireDefault(require("./MarqueeBase"));

var _MarqueeController = require("./MarqueeController");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Default configuration parameters for {@link ui/Marquee.MarqueeDecorator}
 *
 * @type {Object}
 * @memberof ui/Marquee.MarqueeDecorator
 * @hocconfig
 */
var defaultConfig = {
  /**
   * Property containing the callback to stop the animation when `marqueeOn` is `'focus'`
   *
   * @type {String}
   * @default 'onBlur'
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  blur: 'onBlur',

  /**
   * Optional CSS class name to customize the marquee `component`
   *
   * @type {String}
   * @default null
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  className: null,

  /**
   * The base marquee component wrapping the content.
   *
   * @type {Component}
   * @default ui/Marquee.Marquee
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  component: _MarqueeBase["default"],

  /**
   * Property containing the callback to start the animation when `marqueeOn` is `'hover'`
   *
   * @type {String}
   * @default 'onMouseEnter'
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  enter: 'onMouseEnter',

  /**
   * Property containing the callback to start the animation when `marqueeOn` is `'focus'`
   *
   * @type {String}
   * @default 'onFocus'
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  focus: 'onFocus',

  /**
  * Invalidate the distance if any property (like 'inline') changes.
  * Expects an array of props which on change trigger invalidateMetrics.
  *
  * @type {String[]}
  * @default ['remeasure']
  * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
  */
  invalidateProps: ['remeasure'],

  /**
   * Property containing the callback to stop the animation when `marqueeOn` is `'hover'`
   *
   * @type {String}
   * @default 'onMouseLeave'
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  leave: 'onMouseLeave',

  /**
   * A function that determines the text directionality of a string.
   *
   * Returns:
   * * `'rtl'` if the text should marquee to the right
   * * `'ltr'` if the text should marquee to the left
   *
   * @type {Function}
   * @kind member
   * @memberof ui/Marquee.MarqueeDecorator.defaultConfig
   */
  marqueeDirection: function marqueeDirection(str) {
    return (0, _direction["default"])(str) === 'rtl' ? 'rtl' : 'ltr';
  }
};
/*
 * Checks whether any of the invalidateProps has changed or not
 *
 * @param {String[]} propList An array of invalidateProps
 * @param {Object} prev Previous props
 * @param {Object} next Next props
 * @returns {Boolean} `true` if any of the props changed
 * @private
 */

var didPropChange = function didPropChange(propList, prev, next) {
  var hasPropsChanged = propList.map(function (i) {
    return prev[i] !== next[i];
  });
  return hasPropsChanged.indexOf(true) !== -1;
};
/*
 * There's only one timer shared for Marquee so we need to keep track of what we may be using it
 * for. We may need to clean up certain things as we move among states.
 */


var TimerState = {
  CLEAR: 0,
  // No timers pending
  START_PENDING: 1,
  // A start request is pending
  RESET_PENDING: 2,
  // Marquee finished, waiting for reset delay
  SYNCSTART_PENDING: 3 // Waiting to alert Controller that we want to start marqueeing

};
/**
 * A higher-order component that provides marquee functionalities.
 *
 * @class MarqueeDecorator
 * @memberof ui/Marquee
 * @hoc
 * @public
 */

var MarqueeDecorator = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class, _temp;

  var blur = config.blur,
      configClassName = config.className,
      MarqueeComponent = config.component,
      enter = config.enter,
      focus = config.focus,
      invalidateProps = config.invalidateProps,
      leave = config.leave,
      marqueeDirection = config.marqueeDirection; // Generate functions to forward events to containers

  var forwardBlur = (0, _handle.forward)(blur);
  var forwardFocus = (0, _handle.forward)(focus);
  var forwardEnter = (0, _handle.forward)(enter);
  var forwardLeave = (0, _handle.forward)(leave);

  var determineTextDirection = function determineTextDirection(node, rtl, forceDirection) {
    // Text directionality is a function of locale direction (rtl), content (node.textContent),
    // and props (forceDirection) in increasing order of significance.
    if (forceDirection) {
      rtl = forceDirection === 'rtl';
    } else if (node) {
      rtl = marqueeDirection(node.textContent) === 'rtl';
    }

    return rtl;
  };

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(_class, _React$Component);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
      _this.promoteJob = new _util.Job(function () {
        _this.setState(function (state) {
          return state.promoted ? null : {
            promoted: true
          };
        });
      });
      _this.demoteJob = new _util.Job(function () {
        _this.setState(function (state) {
          return !state.animating && state.promoted ? {
            promoted: false
          } : null;
        });
      });

      _this.start = function () {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.marqueeDelay;

        if (_this.props.marqueeDisabled) {
          // if marquee isn't necessary, do not set `animating` but return `true` to mark it
          // complete if it's synchronized so it doesn't block other instances.
          return true;
        } else if (!_this.state.animating) {
          // Don't need to worry about this.timerState because if we're sync, we were just
          // told to start, so our state is correct already. If we're not sync, this will
          // restart us anyhow. If we were waiting to tell sync to start us, someone else in
          // our group already did it.
          _this.setTimeout(function () {
            _this.calculateMetrics();

            if (!_this.contentFits) {
              _this.setState({
                promoted: true,
                animating: true
              });
            } else if (_this.sync) {
              _this.context.complete(_assertThisInitialized(_this));
            }
          }, delay, TimerState.START_PENDING);
        }
      };

      _this.stop = function () {
        _this.clearTimeout();

        if (_this.state.animating) {
          _this.setState({
            animating: false
          });
        }

        _this.demote();
      };

      _this.tryStartingAnimation = function (delay) {
        if (_this.state.animating || _this.timerState !== TimerState.CLEAR) return;

        _this.startAnimation(delay);
      };

      _this.startAnimation = function (delay) {
        _this.promote(delay);

        if (_this.sync) {
          // If we're running a timer for anything, we should let that finish, unless it's
          // another syncstart request.  We should probably check to see if the start request
          // is further in the future than we are so we can choose the nearer one. But, we're
          // assuming the condition is we're waiting on render delay and someone just hovered
          // us, so we can start with the (hopefully) faster hover delay.
          if (_this.timerState !== TimerState.CLEAR && _this.timerState !== TimerState.SYNCSTART_PENDING) {
            return;
          }

          _this.setTimeout(function () {
            _this.context.start();
          }, delay, TimerState.SYNCSTART_PENDING);
        } else {
          _this.start(delay);
        }
      };

      _this.restartAnimation = function () {
        _this.setState({
          animating: false
        }); // synchronized Marquees defer to the controller to restart them


        if (_this.sync) {
          _this.context.complete(_assertThisInitialized(_this));
        } else if (!_this.state.animating) {
          _this.startAnimation();
        }
      };

      _this.resetAnimation = function () {
        var marqueeResetDelay = Math.max(40, _this.props.marqueeResetDelay); // If we're already timing a start action, don't reset.  Start actions will clear us if
        // sync.

        if (_this.timerState === TimerState.CLEAR) {
          _this.setTimeout(_this.restartAnimation, marqueeResetDelay, TimerState.RESET_PENDING);
        }
      };

      _this.cancelAnimation = function () {
        if (_this.sync) {
          _this.context.cancel(_assertThisInitialized(_this));

          return;
        }

        _this.stop();
      };

      _this.handleResize = function () {
        if (_this.node && !_this.props.marqueeDisabled) {
          _this.invalidateMetrics();

          if (_this.state.animating) {
            _this.cancelAnimation();

            _this.resetAnimation();
          }
        }
      };

      _this.handleMarqueeComplete = function () {
        _this.resetAnimation();
      };

      _this.handleFocus = function (ev) {
        _this.isFocused = true;

        if (!_this.sync) {
          if (!_this.state.animating) {
            _this.startAnimation();
          }
        }

        forwardFocus(ev, _this.props);
      };

      _this.handleBlur = function (ev) {
        _this.promoteJob.stop();

        forwardBlur(ev, _this.props);

        if (_this.isFocused) {
          _this.isFocused = false;

          if (!_this.sync && !(_this.isHovered && (_this.props.disabled || _this.props.marqueeOn === 'hover'))) {
            _this.cancelAnimation();
          }
        }
      };

      _this.handleEnter = function (ev) {
        _this.isHovered = true;

        if (_this.props.disabled || _this.props.marqueeOn === 'hover') {
          if (_this.sync) {
            _this.context.enter(_assertThisInitialized(_this));
          } else if (!_this.state.animating) {
            _this.startAnimation();
          }
        }

        forwardEnter(ev, _this.props);
      };

      _this.handleLeave = function (ev) {
        _this.promoteJob.stop();

        _this.handleUnhover();

        forwardLeave(ev, _this.props);
      };

      _this.handlePointerHide = function (_ref) {
        var keyCode = _ref.keyCode;

        if ((0, _keymap.is)('pointerHide', keyCode)) {
          _this.handleUnhover();
        }
      };

      _this.cacheNode = function (node) {
        _this.node = node;
      };

      _this.state = {
        animating: false,
        overflow: 'ellipsis',
        promoted: false,
        rtl: determineTextDirection(null, props.rtl, props.forceDirection)
      };
      _this.sync = false;
      _this.timerState = TimerState.CLEAR;
      _this.distance = null;
      _this.contentFits = false;
      _this.resizeRegistry = null;
      return _this;
    }

    _createClass(_class, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this.context && this.context.register) {
          this.sync = true;
          this.context.register(this, {
            start: this.start,
            stop: this.stop
          });
        }

        this.validateTextDirection();

        if (this.props.marqueeOn === 'render') {
          this.startAnimation(this.props.marqueeOnRenderDelay);
        }

        (0, _dispatcher.on)('keydown', this.handlePointerHide);
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        return !(0, _shallowEqual["default"])(this.state, nextState) || !(0, _shallowEqual["default"])(this.props, nextProps);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        var _this$props = this.props,
            children = _this$props.children,
            disabled = _this$props.disabled,
            forceDirection = _this$props.forceDirection,
            locale = _this$props.locale,
            marqueeOn = _this$props.marqueeOn,
            marqueeDisabled = _this$props.marqueeDisabled,
            marqueeSpeed = _this$props.marqueeSpeed,
            rtl = _this$props.rtl;
        var forceRestartMarquee = false;

        if (prevProps.locale !== locale || prevProps.rtl !== rtl || !(0, _shallowEqual["default"])(prevProps.children, children) || invalidateProps && didPropChange(invalidateProps, prevProps, this.props)) {
          // restart marqueeOn="render" marquees or synced marquees that were animating
          forceRestartMarquee = marqueeOn === 'render' || this.sync && (this.state.animating || this.timerState > TimerState.CLEAR);
          this.invalidateMetrics();
          this.cancelAnimation();
        } else if (prevProps.marqueeOn !== marqueeOn || prevProps.marqueeDisabled !== marqueeDisabled || prevProps.marqueeSpeed !== marqueeSpeed || prevProps.forceDirection !== forceDirection) {
          this.cancelAnimation();
        } else if (disabled && this.isHovered && marqueeOn === 'focus' && this.sync) {
          this.context.enter(this);
        }

        this.validateTextDirection();

        if (forceRestartMarquee || this.shouldStartMarquee()) {
          this.tryStartingAnimation(this.props.marqueeOn === 'render' ? this.props.marqueeOnRenderDelay : this.props.marqueeDelay);
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearTimeout();
        this.promoteJob.stop();
        this.demoteJob.stop();

        if (this.sync) {
          this.context.unregister(this);
        }

        if (this.resizeRegistry) {
          this.resizeRegistry.unregister(this.handleResize);
        }

        (0, _dispatcher.off)('keydown', this.handlePointerHide);
      }
    }, {
      key: "demote",
      value: function demote() {
        this.promoteJob.stop();

        if (this.state.promoted) {
          this.demoteJob.idle();
        }
      }
    }, {
      key: "promote",
      value: function promote() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props.marqueeDelay;
        this.demoteJob.stop();
        this.promoteJob.startAfter(Math.max(0, delay - 200));
      }
      /*
       * Clears the timer
       *
       * @returns {undefined}
       */

    }, {
      key: "clearTimeout",
      value: function clearTimeout() {
        if (window && this.timer) {
          window.clearTimeout(this.timer);
          this.timer = null;
        }

        this.timerState = TimerState.CLEAR;
      }
      /*
       * Starts a new timer
       *
       * @param {Function} fn   Callback
       * @param {Number}   time Delay in milliseconds
       * @returns {undefined}
       */

    }, {
      key: "setTimeout",
      value: function setTimeout(fn) {
        var _this2 = this;

        var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TimerState.CLEAR;
        this.clearTimeout();

        if (window) {
          this.timerState = state;
          this.timer = window.setTimeout(function () {
            _this2.timerState = TimerState.CLEAR;
            fn();
          }, time);
        }
      }
      /*
       * Checks to see if the children changed during a condition that should cause us to re-check
       * the animation state
       *
       * @returns {Boolean} - `true` if a possible marquee condition exists
       */

    }, {
      key: "shouldStartMarquee",
      value: function shouldStartMarquee() {
        var _this$props2 = this.props,
            disabled = _this$props2.disabled,
            marqueeDisabled = _this$props2.marqueeDisabled,
            marqueeOn = _this$props2.marqueeOn;
        return !marqueeDisabled && (marqueeOn === 'render' || !this.sync && (this.isFocused && marqueeOn === 'focus' && !disabled || this.isHovered && (marqueeOn === 'hover' || marqueeOn === 'focus' && disabled)));
      }
      /*
       * Invalidates marquee metrics requiring them to be recalculated
       *
       * @returns {undefined}
       */

    }, {
      key: "invalidateMetrics",
      value: function invalidateMetrics() {
        // Null distance is the special value to allow recalculation
        this.distance = null; // Assume the marquee does not fit until calculations show otherwise

        this.contentFits = false;
        this.setState(function (state) {
          return state.overflow === 'ellipsis' ? null : {
            overflow: 'ellipsis'
          };
        });
      }
      /*
      * Determines if the component should marquee and the distance to animate
      *
      * @returns {undefined}
      */

    }, {
      key: "calculateMetrics",
      value: function calculateMetrics() {
        var node = this.node; // TODO: absolute showing check (or assume that it won't be rendered if it isn't showing?)

        if (node && this.distance == null && !this.props.marqueeDisabled) {
          this.distance = this.calculateDistance(node);
          this.contentFits = !this.shouldAnimate(this.distance);
          var overflow = this.calculateTextOverflow(this.distance);
          this.setState(function (state) {
            return state.overflow === overflow ? null : {
              overflow: overflow
            };
          });
        }
      }
      /*
       * Calculates the distance the marquee must travel to reveal all of the content
       *
       * @param	{DOMNode}	node	DOM Node to measure
       * @returns	{Number}			Distance to travel in pixels
       */

    }, {
      key: "calculateDistance",
      value: function calculateDistance(node) {
        var rect = node.getBoundingClientRect();
        var distance = Math.abs(node.scrollWidth - rect.width);
        return distance;
      }
      /*
       * A custom overflow-determining method to reflect real-world truncation/ellipsis
       * calculation. This catches an edge case that the browser typically does not, where the
       * size of the text area is the same size as the container (zero distance difference), but
       * the browser still inserts an ellipsis due to a non-visible part of the last glyph's
       * render box overflowing the parent container size.
       * This scenario should not induce a marquee animation or ellipsis, so we directly set
       * Marquee to not use an ellipsis, and instead just clip the non-visible part of the glyph.
       *
       * @param	{Number}	distance	Amount of overflow in pixels
       * @returns	{String}				text-overflow value
       */

    }, {
      key: "calculateTextOverflow",
      value: function calculateTextOverflow(distance) {
        return distance < 1 ? 'clip' : 'ellipsis';
      }
      /*
       * Calculates if the marquee should animate
       *
       * @param	{Number}	distance	Amount of overflow in pixels
       * @returns	{Boolean}				`true` if it should animated
       */

    }, {
      key: "shouldAnimate",
      value: function shouldAnimate(distance) {
        return distance >= 1;
      }
      /*
       * Starts the animation without synchronizing
       *
       * @param	{Number}	[delay]	Milliseconds to wait before animating
       * @returns	{undefined}
       */

    }, {
      key: "handleUnhover",
      value: function handleUnhover() {
        this.isHovered = false;

        if (this.props.disabled || this.props.marqueeOn === 'hover') {
          if (this.sync) {
            this.context.leave(this);
          } else {
            this.cancelAnimation();
          }
        }
      }
    }, {
      key: "validateTextDirection",
      value: function validateTextDirection() {
        var _this3 = this;

        this.setState(function (state, props) {
          var rtl = determineTextDirection(_this3.node, props.rtl, props.forceDirection);
          return state.rtl === rtl ? null : {
            rtl: rtl
          };
        });
      }
    }, {
      key: "renderMarquee",
      value: function renderMarquee() {
        var _this$props3 = this.props,
            alignment = _this$props3.alignment,
            children = _this$props3.children,
            disabled = _this$props3.disabled,
            marqueeOn = _this$props3.marqueeOn,
            marqueeSpeed = _this$props3.marqueeSpeed,
            rest = _objectWithoutProperties(_this$props3, ["alignment", "children", "disabled", "marqueeOn", "marqueeSpeed"]);

        var marqueeOnFocus = marqueeOn === 'focus';
        var marqueeOnHover = marqueeOn === 'hover';
        var marqueeOnRender = marqueeOn === 'render';

        if (marqueeOnFocus && !disabled) {
          rest[focus] = this.handleFocus;
        } // TODO: cancel others on hover


        if (marqueeOnHover || marqueeOnFocus) {
          rest[enter] = this.handleEnter;
          rest[leave] = this.handleLeave;
        }

        if (marqueeOnRender) {
          rest[enter] = this.handleEnter;
        }

        delete rest.forceDirection;
        delete rest.locale;
        delete rest.marqueeCentered;
        delete rest.marqueeDelay;
        delete rest.marqueeDisabled;
        delete rest.marqueeOnRenderDelay;
        delete rest.marqueeResetDelay;
        delete rest.marqueeSpeed;
        delete rest.remeasure;
        delete rest.rtl;
        return _react["default"].createElement(Wrapped, Object.assign({}, rest, {
          onBlur: this.handleBlur,
          disabled: disabled
        }), _react["default"].createElement(MarqueeComponent, {
          alignment: alignment,
          animating: this.state.animating,
          className: configClassName,
          clientRef: this.cacheNode,
          distance: this.distance,
          onMarqueeComplete: this.handleMarqueeComplete,
          overflow: this.state.overflow,
          rtl: this.state.rtl,
          speed: marqueeSpeed,
          willAnimate: this.state.promoted
        }, children));
      }
    }, {
      key: "renderWrapped",
      value: function renderWrapped() {
        var props = Object.assign({}, this.props);
        delete props.alignment;
        delete props.forceDirection;
        delete props.locale;
        delete props.marqueeCentered;
        delete props.marqueeDelay;
        delete props.marqueeDisabled;
        delete props.marqueeOn;
        delete props.marqueeOnRenderDelay;
        delete props.marqueeResetDelay;
        delete props.marqueeSpeed;
        delete props.remeasure;
        delete props.rtl;
        return _react["default"].createElement(Wrapped, props);
      }
    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        return _react["default"].createElement(_Resizable.ResizeContext.Consumer, null, function (register) {
          if (!_this4.resizeRegistry && register) {
            _this4.resizeRegistry = register(_this4.handleResize);
          }

          if (_this4.props.marqueeDisabled) {
            return _this4.renderWrapped();
          } else {
            return _this4.renderMarquee();
          }
        });
      }
    }]);

    return _class;
  }(_react["default"].Component), _class.displayName = 'ui:MarqueeDecorator', _class.propTypes =
  /** @lends ui/Marquee.MarqueeDecorator.prototype */
  {
    /**
     * Text alignment value of the marquee. Valid values are `'left'`, `'right'` and `'center'`.
     *
     * @type {String}
     * @public
     */
    alignment: _propTypes["default"].oneOf(['left', 'right', 'center']),

    /**
     * Children to be marqueed
     *
     * @type {Node}
     * @public
     */
    children: _propTypes["default"].node,

    /**
     * Passed through to the wrapped component.
     *
     * Does not affect Marquee behavior except that components that are `marqueeOn="focus"`
     * will be treated as if they were `marqueeOn="hover"`, to allow disabled (and thus,
     * unfocusable) components to marquee.
     *
     * @type {Boolean}
     * @public
     */
    disabled: _propTypes["default"].bool,

    /**
     * Forces the `direction` of the marquee.
     *
     * Valid values are `'rtl'` and `'ltr'`. This includes non-text elements as well.
     * The default behavior, if this prop is unset, is to evaluate the text content for
     * directionality using {@link i18n/util.isRtlText}.
     *
     * @type {String}
     * @public
     */
    forceDirection: _propTypes["default"].oneOf(['rtl', 'ltr']),

    /**
     * The current locale as a
     * {@link https://tools.ietf.org/html/rfc5646|BCP 47 language tag}.
     *
     * @type {String}
     * @public
     */
    locale: _propTypes["default"].string,

    /**
     * Number of milliseconds to wait before starting marquee when `marqueeOn` is `'hover'` or
     * `'focus'` or before restarting any marquee.
     *
     * @type {Number}
     * @default 1000
     * @public
     */
    marqueeDelay: _propTypes["default"].number,

    /**
     * Disables all marquee behavior and removes supporting markup.
     *
     * @type {Boolean}
     */
    marqueeDisabled: _propTypes["default"].bool,

    /**
     * Determines what triggers the marquee to start its animation.
     *
     * Valid values are `'focus'`, `'hover'` and `'render'`. The default is `'focus'`.
     *
     * @type {String}
     * @default 'focus'
     * @public
     */
    marqueeOn: _propTypes["default"].oneOf(['focus', 'hover', 'render']),

    /**
     * Number of milliseconds to wait before starting marquee the first time.
     *
     * Has no effect if `marqueeOn` is not `'render'`
     *
     * @type {Number}
     * @default 1000
     * @public
     */
    marqueeOnRenderDelay: _propTypes["default"].number,

    /**
     * Number of milliseconds to wait before resetting the marquee position after it
     * finishes.
     *
     * A minimum of 40 milliseconds is enforced.
     *
     * @type {Number}
     * @default 1000
     * @public
     */
    marqueeResetDelay: _propTypes["default"].number,

    /**
     * Rate of marquee measured in pixels/second.
     *
     * @type {Number}
     * @default 60
     * @public
     */
    marqueeSpeed: _propTypes["default"].number,

    /**
     * Used to signal for a remeasurement inside of marquee.
     *
     * The value must change for the remeasurement to take place. The value
     * type is `any` because it does not matter. It is only used to check for changes.
     *
     * @private
     */
    remeasure: _propTypes["default"].any,

    /**
     * Indicates the text directionality of the current locale is right-to-left
     *
     * @type {String}
     * @public
     */
    rtl: _propTypes["default"].bool
  }, _class.defaultProps = {
    marqueeDelay: 1000,
    marqueeOn: 'focus',
    marqueeOnRenderDelay: 1000,
    marqueeResetDelay: 1000,
    marqueeSpeed: 60
  }, _class.contextType = _MarqueeController.MarqueeControllerContext, _temp;
});
exports.MarqueeDecorator = MarqueeDecorator;
var _default = MarqueeDecorator;
exports["default"] = _default;