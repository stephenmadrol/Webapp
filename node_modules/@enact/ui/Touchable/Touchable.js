"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "configure", {
  enumerable: true,
  get: function get() {
    return _config.configure;
  }
});
exports.Touchable = exports["default"] = void 0;

var _handle = require("@enact/core/handle");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _dispatcher = require("@enact/core/dispatcher");

var _complement = _interopRequireDefault(require("ramda/src/complement"));

var _platform = _interopRequireDefault(require("@enact/core/platform"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _config = require("./config");

var _state = require("./state");

var _ClickAllow = _interopRequireDefault(require("./ClickAllow"));

var _Drag = require("./Drag");

var _Flick = require("./Flick");

var _Hold = require("./Hold");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var getEventCoordinates = function getEventCoordinates(ev) {
  var x = ev.clientX,
      y = ev.clientY,
      type = ev.type;

  if (type.indexOf('touch') === 0) {
    x = ev.targetTouches[0].clientX;
    y = ev.targetTouches[0].clientY;
  }

  return {
    x: x,
    y: y
  };
}; // Establish a standard payload for onDown/onUp/onTap events and pass it along to a handler


var makeTouchableEvent = function makeTouchableEvent(type) {
  return function (ev) {
    var target = ev.target,
        currentTarget = ev.currentTarget;
    var clientX = ev.clientX,
        clientY = ev.clientY,
        pageX = ev.pageX,
        pageY = ev.pageY;

    if (ev.changedTouches) {
      clientX = ev.changedTouches[0].clientX;
      clientY = ev.changedTouches[0].clientY;
      pageX = ev.changedTouches[0].pageX;
      pageY = ev.changedTouches[0].pageY;
    }

    return {
      type: type,
      target: target,
      currentTarget: currentTarget,
      clientX: clientX,
      clientY: clientY,
      pageX: pageX,
      pageY: pageY
    };
  };
};

var isEnabled = (0, _handle.forProp)('disabled', false);
var handleDown = (0, _handle.handle)(isEnabled, (0, _handle.adaptEvent)(makeTouchableEvent('onDown'), (0, _handle.forwardWithPrevent)('onDown')), (0, _handle.call)('activate'), (0, _handle.call)('startGesture')).named('handleDown');
var handleUp = (0, _handle.handle)(isEnabled, (0, _handle.call)('endGesture'), (0, _handle.call)('isTracking'), (0, _handle.adaptEvent)(makeTouchableEvent('onUp'), (0, _handle.forwardWithPrevent)('onUp')), (0, _handle.adaptEvent)(makeTouchableEvent('onTap'), (0, _handle.forward)('onTap')))["finally"]((0, _handle.call)('deactivate')).named('handleUp');
var handleEnter = (0, _handle.handle)(isEnabled, (0, _handle.forProp)('noResume', false), (0, _handle.call)('enterGesture'), (0, _handle.call)('isPaused'), (0, _handle.call)('activate')).named('handleEnter');
var handleLeave = (0, _handle.handle)(isEnabled, (0, _handle.call)('leaveGesture'), (0, _handle.oneOf)([(0, _handle.forProp)('noResume', false), (0, _handle.call)('pause')], [_handle.returnsTrue, (0, _handle.call)('deactivate')])).named('handleLeave'); // Mouse event handlers

var handleMouseDown = (0, _handle.handle)((0, _handle.forward)('onMouseDown'), (0, _handle.call)('shouldAllowMouseEvent'), handleDown);
var handleMouseEnter = (0, _handle.handle)((0, _handle.forward)('onMouseEnter'), handleEnter);
var handleMouseMove = (0, _handle.handle)((0, _handle.forward)('onMouseMove'), (0, _handle.call)('moveGesture'));
var handleMouseLeave = (0, _handle.handle)((0, _handle.forward)('onMouseLeave'), handleLeave);
var handleMouseUp = (0, _handle.handle)((0, _handle.returnsTrue)((0, _handle.call)('setLastMouseUp')), (0, _handle.forward)('onMouseUp'), handleUp);
var handleClick = (0, _handle.handle)(isEnabled, // wrapping another handler to always forward onClick but, if onTap should occur, it should
// occur first to keep in sync with the up handler which emits onTap first
(0, _handle.handle)((0, _handle.call)('shouldAllowTap'), (0, _handle.call)('activate'), handleUp)["finally"]((0, _handle.forward)('onClick'))); // Touch event handlers

var handleTouchStart = (0, _handle.handle)((0, _handle.forward)('onTouchStart'), handleDown);
var handleTouchMove = (0, _handle.handle)((0, _handle.forward)('onTouchMove'), (0, _handle.call)('isTracking'), // we don't receive enter/leave events during a touch so we have to simulate them by
// detecting when the touch leaves the boundary. oneOf returns the value of whichever
// branch it follows so we append moveHold to either to handle moves that aren't
// entering or leaving
(0, _handle.adaptEvent)(makeTouchableEvent('onMove'), (0, _handle.forward)('onMove')), (0, _handle.oneOf)([(0, _handle.call)('hasTouchLeftTarget'), handleLeave], [_handle.returnsTrue, handleEnter])["finally"]((0, _handle.call)('moveGesture')));
var handleTouchEnd = (0, _handle.handle)((0, _handle.forward)('onTouchEnd'), // block the next mousedown to prevent duplicate touchable events
(0, _handle.returnsTrue)((0, _handle.call)('setLastTouchEnd')), (0, _handle.call)('isTracking'), (0, _complement["default"])((0, _handle.call)('hasTouchLeftTarget')), handleUp); // Global touchend/mouseup event handler to deactivate the component

var handleGlobalUp = (0, _handle.handle)((0, _handle.call)('isTracking'), (0, _handle.call)('deactivate'))["finally"]((0, _handle.call)('endGesture'));
var handleGlobalMove = (0, _handle.handle)((0, _handle.call)('isTracking'), (0, _handle.call)('containsCurrentTarget'), (0, _handle.call)('moveGesture'));
var handleBlur = (0, _handle.handle)((0, _handle.forward)('onBlur'), (0, _handle.call)('hasFocus'), (0, _handle.call)('blurGesture'));
/**
 * Default config for `Touchable`.
 *
 * @memberof ui/Touchable.Touchable
 * @hocconfig
 */

var defaultConfig = {
  /**
   * Configures the prop name to pass the active state to the wrapped component
   *
   * @type {String}
   * @default null
   * @memberof ui/Touchable.Touchable.defaultConfig
   */
  activeProp: null
};
/**
 * A higher-order component that provides a consistent set of pointer events -- `onDown`, `onUp`,
 * and `onTap` -- across mouse and touch interfaces along with support for common gestures including
 * `onFlick`, `onDrag`, `onHold`, and `onHoldPulse`.
 *
 * @class Touchable
 * @memberof ui/Touchable
 * @hoc
 * @public
 */

var Touchable = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class, _temp;

  var activeProp = config.activeProp;
  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(_class, _React$Component);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
      _this.state = {
        active: _state.States.Inactive,
        prevDisabled: props.disabled
      };
      _this.config = (0, _config.mergeConfig)({
        drag: props.dragConfig,
        flick: props.flickConfig,
        hold: props.holdConfig
      });
      _this.target = null;
      _this.targetHadFocus = false;
      _this.handle = _handle.handle.bind(_assertThisInitialized(_this));
      _this.drag = new _Drag.Drag();
      _this.flick = new _Flick.Flick();
      _this.hold = new _Hold.Hold();
      _this.clickAllow = new _ClickAllow["default"]();
      handleClick.bindAs(_assertThisInitialized(_this), 'handleClick');
      handleBlur.bindAs(_assertThisInitialized(_this), 'handleBlur');
      handleMouseDown.bindAs(_assertThisInitialized(_this), 'handleMouseDown');
      handleMouseEnter.bindAs(_assertThisInitialized(_this), 'handleMouseEnter');
      handleMouseMove.bindAs(_assertThisInitialized(_this), 'handleMouseMove');
      handleMouseLeave.bindAs(_assertThisInitialized(_this), 'handleMouseLeave');
      handleMouseUp.bindAs(_assertThisInitialized(_this), 'handleMouseUp');
      handleTouchStart.bindAs(_assertThisInitialized(_this), 'handleTouchStart');
      handleTouchMove.bindAs(_assertThisInitialized(_this), 'handleTouchMove');
      handleTouchEnd.bindAs(_assertThisInitialized(_this), 'handleTouchEnd');
      handleGlobalUp.bindAs(_assertThisInitialized(_this), 'handleGlobalUp');
      handleGlobalMove.bindAs(_assertThisInitialized(_this), 'handleGlobalMove');
      return _this;
    }

    _createClass(_class, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        // ensure we clean up our internal state
        if (_platform["default"].touch) {
          (0, _dispatcher.on)('touchend', this.handleGlobalUp, document);
        }

        (0, _dispatcher.on)('mouseup', this.handleGlobalUp, document);
        (0, _dispatcher.on)('mousemove', this.handleGlobalMove, document);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!prevProps.disabled && this.props.disabled) {
          this.clearTarget();
          this.hold.end();
        }

        this.config = (0, _config.mergeConfig)({
          drag: this.props.dragConfig,
          flick: this.props.flickConfig,
          hold: this.props.holdConfig
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearTarget();
        this.hold.end();

        if (_platform["default"].touch) {
          (0, _dispatcher.off)('touchend', this.handleGlobalUp, document);
        }

        (0, _dispatcher.off)('mouseup', this.handleGlobalUp, document);
        (0, _dispatcher.off)('mousemove', this.handleGlobalMove, document);
      } // State Management

    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target = target;

        if (_platform["default"].touch) {
          (0, _dispatcher.on)('contextmenu', _handle.preventDefault);
          this.targetBounds = this.target.getBoundingClientRect();
        }
      }
    }, {
      key: "clearTarget",
      value: function clearTarget() {
        if (_platform["default"].touch) {
          (0, _dispatcher.off)('contextmenu', _handle.preventDefault);
          this.targetBounds = null;
        }

        this.target = null;
      }
    }, {
      key: "activate",
      value: function activate(ev) {
        this.setTarget(ev.currentTarget);

        if (activeProp) {
          this.setState(_state.activate);
        }

        return true;
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.clearTarget();

        if (activeProp) {
          this.setState(_state.deactivate);
        }

        return true;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (activeProp) {
          this.setState(_state.pause);
        }

        return true;
      } // Gesture Support

    }, {
      key: "startGesture",
      value: function startGesture(ev, props) {
        var coords = getEventCoordinates(ev);
        var _this$config = this.config,
            hold = _this$config.hold,
            flick = _this$config.flick,
            drag = _this$config.drag;
        this.hold.begin(hold, props, coords);
        this.flick.begin(flick, props, coords);
        this.drag.begin(drag, props, coords, this.target);
        this.targetHadFocus = this.target === document.activeElement;
        return true;
      }
    }, {
      key: "moveGesture",
      value: function moveGesture(ev) {
        var coords = getEventCoordinates(ev);
        this.hold.move(coords);
        this.flick.move(coords);
        this.drag.move(coords);
        return true;
      }
    }, {
      key: "enterGesture",
      value: function enterGesture() {
        this.drag.enter();
        this.hold.enter();
        return true;
      }
    }, {
      key: "leaveGesture",
      value: function leaveGesture() {
        this.drag.leave();
        this.hold.leave();
        return true;
      }
    }, {
      key: "blurGesture",
      value: function blurGesture() {
        this.targetHadFocus = false;
        this.hold.blur();
        this.flick.blur();
        this.drag.blur();
        return true;
      }
    }, {
      key: "endGesture",
      value: function endGesture() {
        this.targetHadFocus = false;
        this.hold.end();
        this.flick.end();
        this.drag.end();
        return true;
      } // Event handler utilities

    }, {
      key: "isTracking",
      value: function isTracking() {
        // verify we had a target and the up target is still within the current node
        return this.target;
      }
    }, {
      key: "isPaused",
      value: function isPaused() {
        return this.state.active === _state.States.Paused;
      }
    }, {
      key: "hasFocus",
      value: function hasFocus() {
        return this.targetHadFocus;
      }
    }, {
      key: "hasTouchLeftTarget",
      value: function hasTouchLeftTarget(ev) {
        var _this2 = this;

        return Array.from(ev.changedTouches).reduce(function (hasLeft, _ref) {
          var pageX = _ref.pageX,
              pageY = _ref.pageY;
          var _this2$targetBounds = _this2.targetBounds,
              left = _this2$targetBounds.left,
              right = _this2$targetBounds.right,
              top = _this2$targetBounds.top,
              bottom = _this2$targetBounds.bottom;
          return hasLeft && left > pageX || right < pageX || top > pageY || bottom < pageY;
        }, true);
      }
    }, {
      key: "containsCurrentTarget",
      value: function containsCurrentTarget(_ref2) {
        var target = _ref2.target;
        return !this.target.contains(target);
      }
    }, {
      key: "shouldAllowMouseEvent",
      value: function shouldAllowMouseEvent(ev) {
        return this.clickAllow.shouldAllowMouseEvent(ev);
      }
    }, {
      key: "shouldAllowTap",
      value: function shouldAllowTap(ev) {
        return this.clickAllow.shouldAllowTap(ev);
      }
    }, {
      key: "setLastMouseUp",
      value: function setLastMouseUp(ev) {
        this.clickAllow.setLastMouseUp(ev);
      }
    }, {
      key: "setLastTouchEnd",
      value: function setLastTouchEnd(ev) {
        this.clickAllow.setLastTouchEnd(ev);
      }
    }, {
      key: "addHandlers",
      value: function addHandlers(props) {
        props.onClick = this.handleClick;
        props.onMouseDown = this.handleMouseDown;
        props.onMouseLeave = this.handleMouseLeave;
        props.onMouseMove = this.handleMouseMove;
        props.onMouseEnter = this.handleMouseEnter;
        props.onMouseUp = this.handleMouseUp;
        props.onBlur = this.handleBlur;

        if (_platform["default"].touch) {
          props.onTouchStart = this.handleTouchStart;
          props.onTouchMove = this.handleTouchMove;
          props.onTouchEnd = this.handleTouchEnd;
        }
      }
    }, {
      key: "render",
      value: function render() {
        var props = Object.assign({}, this.props);
        this.addHandlers(props);
        delete props.dragConfig;
        delete props.flickConfig;
        delete props.holdConfig;
        delete props.noResume;
        delete props.onDown;
        delete props.onFlick;
        delete props.onHold;
        delete props.onHoldEnd;
        delete props.onHoldPulse;
        delete props.onTap;
        delete props.onUp;

        if (activeProp) {
          props[activeProp] = this.state.active !== _state.States.Inactive;
        }

        return _react["default"].createElement(Wrapped, props);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var disabled = props.disabled;
        var prevDisabled = state.prevDisabled;

        if (prevDisabled !== disabled) {
          return _objectSpread({}, activeProp && !prevDisabled && disabled && (0, _state.deactivate)(state), {
            prevDisabled: disabled
          });
        }

        return null;
      }
    }]);

    return _class;
  }(_react["default"].Component), _class.displayName = 'Touchable', _class.propTypes =
  /** @lends ui/Touchable.Touchable.prototype */
  {
    /**
     * Disables the component.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    disabled: _propTypes["default"].bool,

    /**
     * Instance-specific overrides of the drag configuration.
     *
     * @see ui/Touchable.configure
     * @type {Object}
     * @public
     */
    dragConfig: _Drag.dragConfigPropType,

    /**
     * Instance-specific overrides of the flick configuration.
     *
     * @see ui/Touchable.configure
     * @type {Object}
     * @public
     */
    flickConfig: _Flick.flickConfigPropType,

    /**
     * Instance-specific overrides of the hold configuration.
     *
     * @see ui/Touchable.configure
     * @type {Object}
     * @public
     */
    holdConfig: _Hold.holdConfigPropType,

    /**
     * Prevents resuming the touch events and gestures when re-entering the component.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    noResume: _propTypes["default"].bool,

    /**
     * Event handler for 'down' pointer events.
     *
     * @type {Function}
     * @public
     */
    onDown: _propTypes["default"].func,

    /**
     * Event handler for a drag gesture.
     *
    	 * Event payload includes:
     *
     * * `type` - Type of event, `'onDrag'`
     * * `x` - Horizontal position of the drag, relative to the viewport
     * * `y` - Vertical position of the drag, relative to the viewport
     *
     * @type {Function}
     * @public
     */
    onDrag: _propTypes["default"].func,

    /**
     * Event handler for the end of a drag gesture.
     *
    	 * Event payload includes:
     *
     * * `type` - Type of event, `'onDragEnd'`
     *
     * @type {Function}
     * @public
     */
    onDragEnd: _propTypes["default"].func,

    /**
     * Event handler for the start of a drag gesture.
     *
    	 * Event payload includes:
     *
     * * `type` - Type of event, `'onDragStart'`
     * * `x` - Horizontal position of the drag, relative to the viewport
     * * `y` - Vertical position of the drag, relative to the viewport
     *
     * @type {Function}
     * @public
     */
    onDragStart: _propTypes["default"].func,

    /**
     * Event handler for a flick gesture.
     *
     * Event payload includes:
     *
     * * `type` - Type of event, `'onFlick'`
     * * `direction` - Primary direction of the flick, either `'horizontal'` or `'vertical'`
     * * `velocity` - Velocity of flick
     * * `velocityX` - Velocity of flick along te horizontal axis
     * * `velocityY` - Velocity of flick along te vertical axis
     *
     * @type {Function}
     * @public
     */
    onFlick: _propTypes["default"].func,

    /**
     * Event handler for hold events.
     *
     * Event payload includes:
     *
     * * `type` - Type of event, `'onHold'`
     * * `name` - The name of the hold as configured in the events list
     * * `time` - Time, in milliseconds, configured for this hold which may vary slightly
     *            from time since the hold began
     *
     * @type {Function}
     * @public
     */
    onHold: _propTypes["default"].func,

    /**
     * Event handler for the end of hold events.
     *
     * Event payload includes:
     *
     * * `type` - Type of event, `'onHoldEnd'`
     * * `time` - Time, in milliseconds, since the hold began
     *
     * @type {Function}
     * @public
     */
    onHoldEnd: _propTypes["default"].func,

    /**
     * Event handler for hold pulse events
     *
     * Event payload includes:
     *
     * * `type` - Type of event, `'onHoldPulse'`
     * * `time` - Time, in milliseconds, since the hold began
     *
     * @type {Function}
     * @public
     */
    onHoldPulse: _propTypes["default"].func,

    /**
     * Event handler for 'tap' pointer events
     *
     * @type {Function}
     * @public
     */
    onTap: _propTypes["default"].func,

    /**
     * Event handler for 'up' pointer events
     *
     * @type {Function}
     * @public
     */
    onUp: _propTypes["default"].func
  }, _class.defaultProps = {
    disabled: false,
    noResume: false
  }, _temp;
});
exports.Touchable = Touchable;
var _default = Touchable;
exports["default"] = _default;