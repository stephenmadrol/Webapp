"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dragConfigPropType = exports.Drag = exports.defaultDragConfig = exports["default"] = void 0;

var _clamp = _interopRequireDefault(require("ramda/src/clamp"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tracking = {
  Untracked: 0,
  Active: 1,
  Paused: 2
};

var Drag = function Drag() {
  var _this = this;

  _classCallCheck(this, Drag);

  this.dragConfig = null;

  this.isDragging = function () {
    return _this.dragConfig != null;
  };

  this.setContainerBounds = function (node) {
    var _this$dragConfig = _this.dragConfig,
        isGlobal = _this$dragConfig.global,
        boxSizing = _this$dragConfig.boxSizing;
    var bounds = null;
    if (!node) return;

    if (isGlobal) {
      bounds = {
        minX: 0,
        minY: 0,
        maxX: window.innerWidth,
        maxY: window.innerHeight
      };
    } else {
      bounds = node.getBoundingClientRect(); // adjust for padding when using content-box

      if (boxSizing === 'content-box') {
        var computedStyle = window.getComputedStyle(node);
        bounds = {
          minX: bounds.left + parseInt(computedStyle.paddingLeft),
          minY: bounds.top + parseInt(computedStyle.paddingTop),
          maxX: bounds.right - parseInt(computedStyle.paddingRight),
          maxY: bounds.bottom - parseInt(computedStyle.paddingBottom)
        };
      }
    }

    _this.bounds = bounds;
  };

  this.updatePosition = function (clientX, clientY) {
    var _this$bounds = _this.bounds,
        maxX = _this$bounds.maxX,
        maxY = _this$bounds.maxY,
        minX = _this$bounds.minX,
        minY = _this$bounds.minY;
    var x = (0, _clamp["default"])(minX, maxX, clientX) - minX;
    var y = (0, _clamp["default"])(minY, maxY, clientY) - minY;

    if (x !== _this.x || y !== _this.y) {
      _this.x = x;
      _this.y = y;
      return true;
    }

    return false;
  };

  this.begin = function (config, _ref, coords, node) {
    var noResume = _ref.noResume,
        onDrag = _ref.onDrag,
        onDragEnd = _ref.onDragEnd,
        onDragStart = _ref.onDragStart;
    if (!onDrag && !onDragStart && !onDragEnd) return;
    var x = coords.x,
        y = coords.y;
    _this.tracking = Tracking.Untracked;
    _this.startX = x;
    _this.startY = y;
    _this.dragConfig = _objectSpread({}, config, {
      node: node,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd,
      onDrag: onDrag,
      resume: !noResume
    });

    _this.setContainerBounds(node);

    _this.move(coords);
  };

  this.move = function (coords) {
    if (!_this.isDragging()) return;
    var _this$dragConfig2 = _this.dragConfig,
        moveTolerance = _this$dragConfig2.moveTolerance,
        onDrag = _this$dragConfig2.onDrag,
        onDragStart = _this$dragConfig2.onDragStart;

    if (_this.tracking === Tracking.Untracked) {
      var dx = coords.x - _this.startX;
      var dy = coords.y - _this.startY;

      if (Math.sqrt(dx * dx + dy * dy) >= moveTolerance) {
        _this.tracking = Tracking.Active;

        if (onDragStart) {
          onDragStart(_objectSpread({
            type: 'onDragStart'
          }, coords));
        }
      }
    } else if (onDrag && _this.tracking === Tracking.Active && _this.updatePosition(coords)) {
      onDrag(_objectSpread({
        type: 'onDrag'
      }, coords));
    }
  };

  this.blur = function () {
    if (!_this.isDragging()) return;

    if (!_this.dragConfig.global) {
      _this.end();
    }
  };

  this.end = function () {
    if (!_this.isDragging()) return;
    var onDragEnd = _this.dragConfig.onDragEnd;

    if (onDragEnd && _this.tracking !== Tracking.Untracked) {
      onDragEnd({
        type: 'onDragEnd'
      });
    }

    _this.tracking = Tracking.Untracked;
    _this.dragConfig = null;
  };

  this.enter = function () {
    if (!_this.isDragging()) return;

    if (_this.dragConfig.resume && _this.tracking === Tracking.Paused) {
      _this.tracking = Tracking.Active;
    }
  };

  this.leave = function () {
    if (!_this.isDragging()) return;

    if (!_this.dragConfig.global && _this.tracking === Tracking.Active) {
      _this.tracking = Tracking.Paused;
    }
  };
};

exports.Drag = Drag;
var defaultDragConfig = {
  boxSizing: 'border-box',
  global: false,
  moveTolerance: 16
};
exports.defaultDragConfig = defaultDragConfig;

var dragConfigPropType = _propTypes["default"].shape({
  boxSizing: _propTypes["default"].string,
  global: _propTypes["default"].bool,
  moveTolerance: _propTypes["default"].number
});

exports.dragConfigPropType = dragConfigPropType;
var _default = Drag;
exports["default"] = _default;