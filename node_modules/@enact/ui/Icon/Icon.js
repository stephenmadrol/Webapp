"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Icon = exports["default"] = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _resolution = _interopRequireDefault(require("../resolution"));

var _IconModule = _interopRequireDefault(require("./Icon.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Merges consumer styles with the image `src` resolved through the resolution independence module.
 *
 * @function
 * @param	{Object}		style	Style object
 * @param	{String|Object}	src		URI to image or object of URIs
 *
 * @returns	{Object}				Original style object with backgroundImage updated
 * @private
 */
var mergeStyle = function mergeStyle(style, src) {
  var updated = Object.assign({}, style);

  var source = _resolution["default"].selectSrc(src);

  if (src && src !== 'none' && src !== 'inherit' && src !== 'initial') {
    source = "url(".concat(source, ")");
  }

  updated.backgroundImage = source;
  return updated;
};
/**
 * Tests if a character is a single printable character
 *
 * @function
 * @param	{String}	c	Character to test
 *
 * @returns	{Boolean}		`true` if c is a single character
 * @private
 */


var isSingleCharacter = function isSingleCharacter(c) {
  return c.length === 1 || // check for 4-byte Unicode character
  c.length === 2 && c.charCodeAt() !== c.codePointAt();
};
/**
 * A basic icon component structure without any behaviors applied to it.
 *
 * @class Icon
 * @memberof ui/Icon
 * @ui
 * @public
 */


var Icon = (0, _kind["default"])({
  name: 'ui:Icon',
  propTypes:
  /** @lends ui/Icon.Icon.prototype */
  {
    /**
     * The icon content.
     *
     * May be specified as either:
     *
     * * A string that represents an icon from the [iconList]{@link ui/Icon.Icon.iconList},
     * * An HTML entity string, Unicode reference or hex value (in the form '0x...'),
     * * A URL specifying path to an icon image, or
     * * An object representing a resolution independent resource (See {@link ui/resolution}).
     *
     * @type {String|Object}
     * @public
     */
    children: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].object]),

    /**
     * Customizes the component by mapping the supplied collection of CSS class names to the
     * corresponding internal Elements and states of this component.
     *
     * The following classes are supported:
     *
     * * `icon` - The root component class
     * * `dingbat` - Applied when the value of [`icon`]{@link ui/Icon.Icon.icon} is not
     *   found in [iconList]{@link ui/Icon.Icon.iconList}
     * * `small` - Applied when `small` prop is `true`
     * * `pressed` - Applied when `pressed` prop is `true`
     *
     * @type {Object}
     * @public
     */
    css: _propTypes["default"].object,

    /**
     * The full list (hash) of supported icons.
     *
     * The keys of this hash are the unique names of each icon. The values are the unicode
     * characters to insert in the icon. These will typically map to glyphs in your icon-font.
     * The format of the keys can be character, glyph, or entity reference that correctly
     * renders in a React + JSX string.
     *
     * @type {Object}
     * @default {}
     * @public
     */
    iconList: _propTypes["default"].object,

    /**
     * Applies the `pressed` CSS class.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    pressed: _propTypes["default"].bool,

    /**
     * Applies the `small` CSS class.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    small: _propTypes["default"].bool
  },
  defaultProps: {
    iconList: {},
    pressed: false,
    small: false
  },
  styles: {
    css: _IconModule["default"],
    className: 'icon',
    publicClassNames: true
  },
  computed: {
    className: function className(_ref) {
      var icon = _ref.children,
          iconList = _ref.iconList,
          pressed = _ref.pressed,
          small = _ref.small,
          styler = _ref.styler;
      return styler.append({
        // If the icon isn't in our known set, apply our custom font class
        dingbat: !(icon in iconList),
        pressed: pressed,
        small: small
      });
    },
    iconProps: function iconProps(_ref2) {
      var iconProp = _ref2.children,
          iconList = _ref2.iconList,
          style = _ref2.style;
      var icon = iconList[iconProp];

      if (!icon) {
        if (typeof iconProp == 'string') {
          if (iconProp.indexOf('&#x') === 0) {
            // Converts a hex reference in HTML entity form: &#x99999;
            icon = parseInt(iconProp.slice(3, -1), 16);
          } else if (iconProp.indexOf('&#') === 0) {
            // Convert an HTML entity: &#99999;
            icon = parseInt(iconProp.slice(2, -1));
          } else if (iconProp.indexOf("\\u") === 0) {
            // Convert a unicode reference: \u99999;
            icon = parseInt(iconProp.slice(2), 16);
          } else if (iconProp.indexOf('0x') === 0) {
            // Converts a hex reference in string form
            icon = String.fromCodePoint(iconProp);
          } else if (isSingleCharacter(iconProp)) {
            // A single character is assumed to be an explicit icon string
            icon = iconProp;
          } else {
            // for a path or URI, add it to style
            style = mergeStyle(style, iconProp);
          }
        } else if (_typeof(iconProp) === 'object') {
          style = mergeStyle(style, iconProp);
        }
      }

      if (typeof icon == 'number') {
        // Converts a hex reference in number form
        icon = String.fromCodePoint(icon);
      }

      return {
        children: icon,
        style: style
      };
    }
  },
  render: function render(_ref3) {
    var iconProps = _ref3.iconProps,
        rest = _objectWithoutProperties(_ref3, ["iconProps"]);

    delete rest.iconList;
    delete rest.pressed;
    delete rest.small;
    return _react["default"].createElement("div", Object.assign({
      "aria-hidden": true
    }, rest, iconProps));
  }
});
exports.Icon = Icon;
var _default = Icon;
exports["default"] = _default;