"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Toggleable = exports["default"] = void 0;

var _handle = require("@enact/core/handle");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _util = require("@enact/core/util");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _warning = _interopRequireDefault(require("warning"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Default config for `Toggleable`.
 *
 * @memberof ui/Toggleable.Toggleable
 * @hocconfig
 */
var defaultConfig = {
  /**
   * Configures the event name that activates the component.
   *
   * **Note**: When using `activate`/`deactivate`, the event payload will only forward the original
   * event and not include toggled `prop` value. Use `toggle` to receive toggled value from the
   * event payload.
   *
   * Example:
   * ```
   * const ToggleItem = Toggleable({activate: 'onFocus', deactivate: 'onBlur'}, Item);
   *
   * handleEvent = (ev) => {
   * 	// do something with `ev.selected` here
   * }
   *
   * <ToggleItem onToggle={handleEvent}>This is a toggle item</Item>
   *
   * @type {String}
   * @memberof ui/Toggleable.Toggleable.defaultConfig
   */
  activate: null,

  /**
   * Configures the event name that deactivates the component.
   *
   * **Note**: When using `activate`/`deactivate`, the event payload will only forward the original
   * event and not include toggled `prop` value. Use `toggle` to receive toggled value from the
   * event payload.
   *
   * Example:
   * ```
   * const ToggleItem = Toggleable({activate: 'onFocus', deactivate: 'onBlur'}, Item);
   *
   * handleEvent = (ev) => {
   * 	// do something with `ev.selected` here
   * }
   *
   * <ToggleItem onToggle={handleEvent}>This is a toggle item</Item>
   * ```
   * @type {String}
   * @memberof ui/Toggleable.Toggleable.defaultConfig
   */
  deactivate: null,

  /**
   * Configures the property that is passed to the wrapped component when toggled.
   *
   * @type {String}
   * @default 'selected'
   * @memberof ui/Toggleable.Toggleable.defaultConfig
   */
  prop: 'selected',

  /**
   * Configures the event name that toggles the component.
   *
   * The payload includes a toggled Boolean value of `prop`.
   *
   * **Note**: The payload will override the original event. If a native event is set, then the native
   * event payload will be lost.
   *
   * @type {String}
   * @default 'onToggle'
   * @memberof ui/Toggleable.Toggleable.defaultConfig
   */
  toggle: 'onToggle',

  /**
   * Allows you to remap the incoming `toggle` callback to an event name of your choosing.
   *
   * For example, run `onToggle` when the wrapped component has an `onClick` property and you've specified
   * `onClick` here.
   *
   * @type {String}
   * @default null
   * @memberof ui/Toggleable.Toggleable.defaultConfig
   */
  toggleProp: null
};
/**
 * A higher-order component that applies a 'toggleable' behavior to its wrapped component.
 *
 * Its default event and property can be configured when applied to a component.
 *
 * Example:
 * ```
 * const ToggleItem = Toggleable({toggleProp: 'onClick'}, Item);
 * ```
 *
 * @class Toggleable
 * @memberof ui/Toggleable
 * @hoc
 * @public
 */

var ToggleableHOC = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class, _temp, _class$propTypes;

  var activate = config.activate,
      deactivate = config.deactivate,
      prop = config.prop,
      toggle = config.toggle,
      toggleProp = config.toggleProp;
  var defaultPropKey = 'default' + (0, _util.cap)(prop);
  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(Toggleable, _React$Component);

    function Toggleable(_props) {
      var _this;

      _classCallCheck(this, Toggleable);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Toggleable).call(this, _props));
      _this.handle = _handle.handle.bind(_assertThisInitialized(_this));

      _this.forwardWithState = function (evName) {
        return function (ev, props) {
          return (0, _handle.forward)(evName, _defineProperty({}, prop, !_this.state.active), props);
        };
      };

      _this.updateActive = function (active) {
        if (!_this.state.controlled) {
          _this.setState({
            active: active
          });
        }
      };

      _this.handleActivate = _this.handle((0, _handle.forProp)('disabled', false), (0, _handle.forward)(activate), _this.forwardWithState(toggle), function () {
        return _this.updateActive(true);
      });
      _this.handleDeactivate = _this.handle((0, _handle.forProp)('disabled', false), (0, _handle.forward)(deactivate), _this.forwardWithState(toggle), function () {
        return _this.updateActive(false);
      });
      _this.handleToggle = _this.handle((0, _handle.forProp)('disabled', false), toggleProp ? (0, _handle.forward)(toggleProp) : null, _this.forwardWithState(toggle), function () {
        return _this.updateActive(!_this.state.active);
      });
      _this.state = {
        rendered: false,
        active: null,
        controlled: prop in _props
      };
      process.env.NODE_ENV !== "production" ? (0, _warning["default"])(!(prop in _props && defaultPropKey in _props), "Do not specify both '".concat(prop, "' and '").concat(defaultPropKey, "' for Toggleable instances.\n\t\t\t\t'").concat(defaultPropKey, "' will be ignored unless '").concat(prop, "' is 'null' or 'undefined'.")) : void 0;
      return _this;
    }

    _createClass(Toggleable, [{
      key: "render",
      value: function render() {
        var props = Object.assign({}, this.props);

        if (toggleProp || toggle) {
          // Supporting only one of the toggleProp or toggle, but we don't want both applying.
          delete props[toggle];
          props[toggleProp || toggle] = this.handleToggle;
        }

        if (activate) props[activate] = this.handleActivate;
        if (deactivate) props[deactivate] = this.handleDeactivate;
        if (prop) props[prop] = this.state.active;
        delete props[defaultPropKey];
        return _react["default"].createElement(Wrapped, props);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        if (state.rendered === false) {
          return {
            rendered: true,
            active: Boolean(props[prop] != null ? props[prop] : props[defaultPropKey])
          };
        } else if (state.controlled) {
          return {
            active: Boolean(props[prop])
          };
        }

        process.env.NODE_ENV !== "production" ? (0, _warning["default"])(!(typeof props[prop] !== 'undefined'), "'".concat(prop, "' specified for an uncontrolled instance of Toggleable and will be\n\t\t\t\tignored. To make this instance of Toggleable controlled, '").concat(prop, "' should be\n\t\t\t\tspecified at creation.")) : void 0;
        return null;
      }
    }]);

    return Toggleable;
  }(_react["default"].Component), _class.propTypes = (_class$propTypes = {}, _defineProperty(_class$propTypes, defaultPropKey, _propTypes["default"].bool), _defineProperty(_class$propTypes, "disabled", _propTypes["default"].bool), _defineProperty(_class$propTypes, prop, _propTypes["default"].bool), _defineProperty(_class$propTypes, toggle, _propTypes["default"].func), _class$propTypes), _class.defaultProps = {
    disabled: false
  }, _temp;
});
exports.Toggleable = ToggleableHOC;
var _default = ToggleableHOC;
exports["default"] = _default;