"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FloatingLayerBase = exports.FloatingLayer = exports["default"] = void 0;

var _dispatcher = require("@enact/core/dispatcher");

var _handle = require("@enact/core/handle");

var _invariant = _interopRequireDefault(require("invariant"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _Cancelable = _interopRequireDefault(require("../Cancelable"));

var _FloatingLayerDecorator = require("./FloatingLayerDecorator");

var _Scrim = _interopRequireDefault(require("./Scrim"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var forwardWithType = function forwardWithType(type) {
  return (0, _handle.adaptEvent)(function () {
    return {
      type: type
    };
  }, (0, _handle.forward)(type));
};

var forwardDismiss = forwardWithType('onDismiss');
var forwardClose = forwardWithType('onClose');
var forwardOpen = forwardWithType('onOpen');
/**
 * A component that creates an entry point to the new render tree.
 *
 * This is used for modal components such as popups.
 *
 * @class FloatingLayerBase
 * @memberof ui/FloatingLayer
 * @ui
 * @public
 */

var FloatingLayerBase =
/*#__PURE__*/
function (_React$Component) {
  _inherits(FloatingLayerBase, _React$Component);

  function FloatingLayerBase(props) {
    var _this;

    _classCallCheck(this, FloatingLayerBase);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FloatingLayerBase).call(this, props));
    _this.handleNotify = (0, _handle.oneOf)([(0, _handle.forEventProp)('action', 'close'), (0, _handle.call)('handleClose')], [(0, _handle.forEventProp)('action', 'mount'), (0, _handle.call)('setFloatingLayer')]).bind(_assertThisInitialized(_this));
    _this.handleClose = (0, _handle.handle)((0, _handle.forProp)('open', true), forwardDismiss).bind(_assertThisInitialized(_this));
    _this.handleClick = (0, _handle.handle)((0, _handle.forProp)('noAutoDismiss', false), (0, _handle.forProp)('open', true), (0, _handle.forward)('onDismiss')).bind(_assertThisInitialized(_this));

    _this.handleScroll = function (ev) {
      var currentTarget = ev.currentTarget;
      currentTarget.scrollTop = 0;
      currentTarget.scrollLeft = 0;
    };

    _this.stopPropagation = function (ev) {
      ev.nativeEvent.stopImmediatePropagation();

      if (_this.props.children.props.onClick) {
        _this.props.children.props.onClick();
      }
    };

    _this.node = null;
    _this.state = {
      nodeRendered: false
    };
    return _this;
  }

  _createClass(FloatingLayerBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Must register first in order to obtain the floating layer node reference before tryinging
      // to render into it
      if (this.context && typeof this.context === 'function') {
        this.controller = this.context(this.handleNotify.bind(this));
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props = this.props,
          open = _this$props.open,
          scrimType = _this$props.scrimType;

      if (prevProps.open && !open) {
        // when open changes to false, forward close
        forwardClose(null, this.props);
      } else if (!prevProps.open && open && !this.state.nodeRendered) {
        // when open changes to true and node hasn't rendered, render it
        this.renderNode();
      } else if (this.state.nodeRendered && (!prevState.nodeRendered || prevState.nodeRendered && open && !prevProps.open)) {
        // when node has been rendered and either it was just rendered in this update cycle or
        // the open prop changed in this cycle, forward open
        forwardOpen(null, this.props);
      }

      if (scrimType === 'none') {
        if (!prevProps.open && open) {
          (0, _dispatcher.on)('click', this.handleClick);
        } else if (prevProps.open && !open) {
          (0, _dispatcher.off)('click', this.handleClick);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.node && this.floatingLayer) {
        this.floatingLayer.removeChild(this.node);
        this.node = null;
        this.floatingLayer = null;
      }

      (0, _dispatcher.off)('click', this.handleClick);

      if (this.controller) {
        this.controller.unregister();
      }
    }
  }, {
    key: "setFloatingLayer",
    value: function setFloatingLayer(_ref) {
      var floatingLayer = _ref.floatingLayer;
      var isNewLayer = !this.floatingLayer && floatingLayer;
      this.floatingLayer = floatingLayer; // the first time we have a valid floating layer container and this instance is set to open,
      // we need to render the layer.

      if (isNewLayer && this.props.open && !this.state.nodeRendered) {
        this.renderNode();
      }
    }
  }, {
    key: "renderNode",
    value: function renderNode() {
      var floatLayerClassName = this.props.floatLayerClassName;
      if (this.node) return;
      !this.floatingLayer ? process.env.NODE_ENV !== "production" ? (0, _invariant["default"])(false, 'FloatingLayer cannot be used outside the subtree of a FloatingLayerDecorator') : invariant(false) : void 0;
      this.node = document.createElement('div');
      this.node.className = floatLayerClassName;
      this.node.style.zIndex = 100;
      this.floatingLayer.appendChild(this.node);
      (0, _dispatcher.on)('scroll', this.handleScroll, this.node); // render children when this.node is inserted in the DOM tree.

      this.setState({
        nodeRendered: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          children = _this$props2.children,
          open = _this$props2.open,
          scrimType = _this$props2.scrimType,
          rest = _objectWithoutProperties(_this$props2, ["children", "open", "scrimType"]);

      delete rest.floatLayerClassName;
      delete rest.floatLayerId;
      delete rest.noAutoDismiss;
      delete rest.onClose;
      delete rest.onDismiss;
      delete rest.onOpen;

      if (open && this.state.nodeRendered) {
        return _reactDom["default"].createPortal(_react["default"].createElement("div", rest, scrimType !== 'none' ? _react["default"].createElement(_Scrim["default"], {
          type: scrimType,
          onClick: this.handleClick
        }) : null, _react["default"].cloneElement(children, {
          onClick: this.stopPropagation
        })), this.node);
      }

      return null;
    }
  }]);

  return FloatingLayerBase;
}(_react["default"].Component);

exports.FloatingLayerBase = FloatingLayerBase;
FloatingLayerBase.displayName = 'FloatingLayer';
FloatingLayerBase.propTypes =
/** @lends ui/FloatingLayer.FloatingLayerBase.prototype */
{
  /**
   * CSS classes for FloatingLayer.
   *
   * @type {String}
   * @default 'enact-fit enact-clip enact-untouchable'
   * @public
   */
  floatLayerClassName: _propTypes["default"].string,

  /**
   * Element id for floating layer.
   *
   * @type {String}
   * @default 'floatLayer'
   * @public
   */
  floatLayerId: _propTypes["default"].string,

  /**
   * Prevents FloatingLayer from hiding when the user presses `ESC` key.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  noAutoDismiss: _propTypes["default"].bool,

  /**
   * Called when floating layer is closed.
   *
   * @type {Function}
   * @public
   */
  onClose: _propTypes["default"].func,

  /**
   * Called when a closing action is invoked.
   *
   * These actions may include pressing cancel/back (e.g. `ESC`) key or programmatically closing
   * by `FloatingLayerDecorator`. When cancel key is pressed, the function will only invoke if
   * `noAutoDismiss` is set to `false`.
   *
   * @type {Function}
   * @public
   */
  onDismiss: _propTypes["default"].func,

  /**
   * Called when floating layer is opened. It will only be invoked for the first render.
   *
   * @type {Function}
   * @public
   */
  onOpen: _propTypes["default"].func,

  /**
   * Renders the floating layer and its components.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  open: _propTypes["default"].bool,

  /**
   * The scrim type that overlays FloatingLayer.
   *
   * It can be either `'transparent'`, `'translucent'`, or `'none'`.
   *
   * @type {String}
   * @default 'translucent'
   * @public
   */
  scrimType: _propTypes["default"].oneOf(['transparent', 'translucent', 'none'])
};
FloatingLayerBase.contextType = _FloatingLayerDecorator.FloatingLayerContext;
FloatingLayerBase.defaultProps = {
  floatLayerClassName: 'enact-fit enact-clip enact-untouchable',
  floatLayerId: 'floatLayer',
  noAutoDismiss: false,
  open: false,
  scrimType: 'translucent'
};
var handleCancel = (0, _handle.handle)( // can't use forProp safely since either could be undefined ~= false
function (ev, _ref2) {
  var open = _ref2.open,
      noAutoDismiss = _ref2.noAutoDismiss,
      onDismiss = _ref2.onDismiss;
  return open && !noAutoDismiss && onDismiss;
}, forwardDismiss, _handle.stop);
/**
 * FloatingLayer that mixes {@link ui/Cancelable.Cancelable} to handle FloatingLayer dismissal.
 *
 * This is used for modal components such as popups.
 *
 * @class FloatingLayer
 * @memberof ui/FloatingLayer
 * @ui
 * @extends ui/FloatingLayer.FloatingLayerBase
 * @mixes ui/Cancelable.Cancelable
 * @public
 */

var FloatingLayer = (0, _Cancelable["default"])({
  modal: true,
  onCancel: handleCancel
}, FloatingLayerBase);
exports.FloatingLayer = FloatingLayer;
var _default = FloatingLayer;
exports["default"] = _default;