"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Cell", {
  enumerable: true,
  get: function get() {
    return _Cell.Cell;
  }
});
Object.defineProperty(exports, "CellBase", {
  enumerable: true,
  get: function get() {
    return _Cell.CellBase;
  }
});
Object.defineProperty(exports, "CellDecorator", {
  enumerable: true,
  get: function get() {
    return _Cell.CellDecorator;
  }
});
exports.Row = exports.LayoutDecorator = exports.LayoutBase = exports.Layout = exports.Column = exports["default"] = void 0;

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _propTypes = _interopRequireDefault(require("@enact/core/internal/prop-types"));

var _propTypes2 = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _ForwardRef = _interopRequireDefault(require("../ForwardRef"));

var _Cell = require("./Cell");

var _LayoutModule = _interopRequireDefault(require("./Layout.module.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * A container for `Cell`s.
 *
 * A stateless component that acts as a containing area for [Cells]{@link ui/Layout.Cell} to be
 * positioned in a row or a column (horizontally or vertically, respectively. It supports an
 * [orientation]{@link ui/Layout.Layout#orientation} property for laying-out its contents
 * (`Cells`) in an organized, readable way.
 *
 * Example:
 * ```
 * import Input from '@enact/moonstone/Input';
 * import css from './LayoutExample.less';
 * ...
 * <fieldset>
 * 	<Layout align="center">
 * 		<Cell component="label" size="40%" className={css.label} shrink>First Name</Cell>
 * 		<Cell component={Input} placeholder="First" className={css.input} />
 * 	</Layout>
 * 	<Layout align="center">
 * 		<Cell component="label" size="40%" className={css.label} shrink>Last Name</Cell>
 * 		<Cell component={Input} placeholder="Last" className={css.input} />
 * 	</Layout>
 * </fieldset>
 * ```
 *
 * @class LayoutBase
 * @ui
 * @memberof ui/Layout
 * @public
 */
var LayoutBase = (0, _kind["default"])({
  name: 'LayoutBase',
  propTypes:
  /** @lends ui/Layout.LayoutBase.prototype */
  {
    /**
     * The alignment of children.
     *
     * Aligns the children [Cells]{@link ui/Layout.Cell} vertically in the case of a horizontal
     * layout or horizontally in the case of a vertical layout. `"start"`, `"center"` and
     * `"end"` are the most commonly used, although all values of `align-items` are supported.
     * `"start"` refers to the top in a horizontal layout, and left in a vertical LTR layout
     * `"end"` refers to the bottom in a horizontal layout, and right in a vertical LTR layout
     * `"start"` and `"end"` reverse places when in a vertical layout in a RTL locale.
     * This includes support for `align-parts` which is shorthand for combining `align-items`
     * and `justify-content` into a single property, separated by a space, in that order.
     * This allows you to specify both the horizontal and vertical alignment in one property,
     * separated by a space.
     *
     * @type {String}
     * @public
     */
    align: _propTypes2["default"].string,

    /**
     * Only [Cell]{@link ui/Layout.Cell} components are supported as children.
     *
     * @type {Any}
     * @public
     */
    children: _propTypes2["default"].any,

    /**
     * The type of component to use to render as the `Layout`. May be a DOM node name (e.g 'div',
     * 'span', etc.) or a custom component.
     *
     * @type {String|Component}
     * @default 'div'
     * @public
     */
    component: _propTypes["default"].renderable,

    /**
     * Called with a reference to [component]{@link ui/Layout.Layout#component}
     *
     * @type {Function}
     * @private
     */
    componentRef: _propTypes2["default"].func,

    /**
     * Allows this `Layout` to have following siblings drawn on the same line as itself
     * instead of carving out the entire horizontal space for itself.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    inline: _propTypes2["default"].bool,

    /**
     * The orientation of the `Layout`, i.e. how the children [Cells]{@link ui/Layout.Cell} are
     * positioned on the screen. Must be either `'horizontal'` or `'vertical'`.
     *
     * @type {String}
     * @default 'horizontal'
     * @public
     */
    orientation: _propTypes2["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Sets the Layout's `flex-wrap` values.
     *
     * Determines how a Layout handles its cells if there are more than fit in the available
     * space. This works like a normal `Boolean` prop, but also accepts strings for customization
     * beyond the basic on/off support. In addition to `true` and `false`, the following strings
     * are supported: 'wrap', 'nowrap', 'reverse'. 'reverse' performs standard line wrapping but
     * additional lines are placed above/before the preceding line instead of below/after.
     *
     * @type {Boolean|String}
     * @public
     */
    wrap: _propTypes2["default"].oneOfType([_propTypes2["default"].bool, _propTypes2["default"].oneOf(['reverse', 'nowrap', 'wrap'])])
  },
  defaultProps: {
    component: 'div',
    inline: false,
    orientation: 'horizontal',
    wrap: false
  },
  styles: {
    css: _LayoutModule["default"],
    className: 'layout'
  },
  computed: {
    className: function className(_ref) {
      var inline = _ref.inline,
          orientation = _ref.orientation,
          wrap = _ref.wrap,
          styler = _ref.styler;
      return styler.append(orientation, {
        inline: inline,
        nowrap: wrap === false || wrap === 'nowrap',
        wrap: wrap === true || wrap === 'wrap',
        wrapReverse: wrap === 'wrapReverse'
      });
    },
    style: function style(_ref2) {
      var align = _ref2.align,
          _style = _ref2.style;
      if (!align) return _style; // This is effectively a polyfill for the upcoming `place-items` prop which is shorthand
      // for align-items and justify-items together

      var alignParts = align.split(' ');
      return _objectSpread({}, _style, {
        alignItems: (0, _Cell.toFlexAlign)(alignParts[0]),
        justifyContent: (0, _Cell.toFlexAlign)(alignParts[1])
      });
    }
  },
  render: function render(_ref3) {
    var Component = _ref3.component,
        componentRef = _ref3.componentRef,
        rest = _objectWithoutProperties(_ref3, ["component", "componentRef"]);

    delete rest.align;
    delete rest.inline;
    delete rest.orientation;
    delete rest.wrap;
    return _react["default"].createElement(Component, Object.assign({
      ref: componentRef
    }, rest));
  }
});
/**
 * Applies Layout behaviors.
 *
 * @hoc
 * @memberof ui/Layout
 * @mixes ui/ForwardRef.ForwardRef
 * @public
 */

exports.LayoutBase = LayoutBase;
var LayoutDecorator = (0, _ForwardRef["default"])({
  prop: 'componentRef'
});
/**
 * A container for `Cell`s.
 *
 * A stateless component that acts as a containing area for [Cells]{@link ui/Layout.Cell} to be
 * positioned in a row or a column (horizontally or vertically, respectively. It supports an
 * [orientation]{@link ui/Layout.Layout#orientation} property for laying-out its contents
 * (`Cells`) in an organized, readable way.
 *
 * Example:
 * ```
 * import Input from '@enact/moonstone/Input';
 * import css from './LayoutExample.less';
 * ...
 * <fieldset>
 * 	<Layout align="center">
 * 		<Cell component="label" size="40%" className={css.label} shrink>First Name</Cell>
 * 		<Cell component={Input} placeholder="First" className={css.input} />
 * 	</Layout>
 * 	<Layout align="center">
 * 		<Cell component="label" size="40%" className={css.label} shrink>Last Name</Cell>
 * 		<Cell component={Input} placeholder="Last" className={css.input} />
 * 	</Layout>
 * </fieldset>
 * ```
 *
 * @class Layout
 * @memberof ui/Layout
 * @extends ui/Layout.LayoutBase
 * @mixes ui/ForwardRef.ForwardRef
 * @ui
 * @public
 */

exports.LayoutDecorator = LayoutDecorator;
var Layout = LayoutDecorator(LayoutBase);
/**
 * A {@link ui/Layout.Layout} that positions its [Cells]{@link ui/Layout.Cell} vertically.
 *
 * @class Column
 * @memberof ui/Layout
 * @extends ui/Layout.Layout
 * @mixes ui/ForwardRef.ForwardRef
 * @ui
 * @public
 */

exports.Layout = Layout;
var Column = LayoutDecorator(function (props) {
  return LayoutBase.inline(_objectSpread({}, props, {
    orientation: 'vertical'
  }));
});
/**
 * A {@link ui/Layout.Layout} that positions its [Cells]{@link ui/Layout.Cell} horizontally.
 *
 * @class Row
 * @memberof ui/Layout
 * @extends ui/Layout.Layout
 * @mixes ui/ForwardRef.ForwardRef
 * @ui
 * @public
 */

exports.Column = Column;
var Row = LayoutDecorator(function (props) {
  return LayoutBase.inline(_objectSpread({}, props, {
    orientation: 'horizontal'
  }));
});
exports.Row = Row;
var _default = LayoutBase;
exports["default"] = _default;