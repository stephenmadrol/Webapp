"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slottable = exports["default"] = void 0;

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _kind = _interopRequireDefault(require("@enact/core/kind"));

var _react = _interopRequireDefault(require("react"));

var _warning = _interopRequireDefault(require("warning"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// ** WARNING ** This is an intentional but likely dangerous hack necessary to clone a child while
// omitting the `slot` property. It relies on the black box structure of a React element which could
// change breaking this code. Without it, the slot property will cascade to a DOM node causing a
// React warning.
var cloneElement = function cloneElement(child) {
  var newProps = Object.assign({}, child.props);
  delete newProps.slot;
  return _react["default"].createElement(child.type, newProps);
};

var distributeChild = function distributeChild(child, index, slots, props) {
  var c, slot;

  var hasSlot = function hasSlot(name) {
    return slots.indexOf(name) !== -1;
  };

  if (!_react["default"].isValidElement(child)) {
    return false;
  } else if (child.props.slot) {
    var hasUserSlot = hasSlot(slot = child.props.slot);
    process.env.NODE_ENV !== "production" ? (0, _warning["default"])(hasUserSlot, 'The slot "%s" specified on %s does not exist', child.props.slot, typeof child.type === 'string' ? child.type : child.type.name || child.type.displayName || 'component') : void 0;

    if (hasUserSlot) {
      c = cloneElement(child);
    }
  } else if (hasSlot(slot = child.type.defaultSlot)) {
    c = child;
  } else if (hasSlot(slot = child.type)) {
    var propNames = Object.keys(child.props);

    if (propNames.length === 1 && propNames[0] === 'children') {
      c = child.props.children;
    } else {
      c = child;
    }
  }

  if (c) {
    var prop = props[slot];

    if (prop) {
      if (Array.isArray(prop)) {
        prop.push(c);
      } else {
        prop = [prop, c];
      }
    } else {
      prop = c;
    }

    props[slot] = prop;
    return true;
  }

  return false;
};

var distribute = function distribute(slots, props) {
  if (slots) {
    var children = [];

    var adjusted = _objectSpread({}, props);

    _react["default"].Children.forEach(props.children, function (child, index) {
      if (!distributeChild(child, index, slots, adjusted)) {
        children.push(child);
      }
    });

    adjusted.children = children.length > 0 ? children : null;
    return adjusted;
  }

  return props;
};

var defaultConfig = {
  slots: null
};
/**
 * A higher-order component that allows wrapped components to separate children into pre-designated 'slots'.
 *
 * To use `Slottable`, you must configure it by passing in a config object with the `slots` member set to an
 * array of slot names.  Any children whose `slot` or `defaultSlot` property matches a named slot or whose
 * type matches a named slot will be placed into a property of the same name on the wrapped component.
 *
 * @class Slottable
 * @memberof ui/Slottable
 * @hoc
 * @public
 */

var Slottable = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var slots = config.slots;
  return (0, _kind["default"])({
    name: 'Slottable',
    render: function render(props) {
      var adjusted = distribute(slots, props);
      return _react["default"].createElement(Wrapped, adjusted);
    }
  });
});
exports.Slottable = Slottable;
var _default = Slottable;
exports["default"] = _default;