"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VirtualListBaseNative = exports.VirtualListBase = exports.ScrollableVirtualListNative = exports.ScrollableVirtualList = exports.gridListItemSizeShape = exports["default"] = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _equals = _interopRequireDefault(require("ramda/src/equals"));

var _platform = require("@enact/core/platform");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _Scrollable = _interopRequireDefault(require("../Scrollable"));

var _ScrollableNative = _interopRequireDefault(require("../Scrollable/ScrollableNative"));

var _VirtualListModule = _interopRequireDefault(require("./VirtualList.module.css"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var nop = function nop() {},
    JS = 'JS',
    Native = 'Native';
/**
 * The shape for the grid list item size
 * in a list for [VirtualGridList]{@link ui/VirtualList.VirtualGridList}.
 *
 * @typedef {Object} gridListItemSizeShape
 * @memberof ui/VirtualList
 * @property {Number}    minWidth    The minimum width of the grid list item.
 * @property {Number}    minHeight    The minimum height of the grid list item.
 * @public
 */


var gridListItemSizeShape = _propTypes["default"].shape({
  minHeight: _propTypes["default"].number.isRequired,
  minWidth: _propTypes["default"].number.isRequired
});
/**
 * The base version of the virtual list component.
 *
 * @class VirtualListBase
 * @memberof ui/VirtualList
 * @ui
 * @public
 */


exports.gridListItemSizeShape = gridListItemSizeShape;

var VirtualListBaseFactory = function VirtualListBaseFactory(type) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_Component) {
    _inherits(VirtualListCore, _Component);

    /* No displayName here. We set displayName to returned components of this factory function. */
    function VirtualListCore(_props) {
      var _this;

      _classCallCheck(this, VirtualListCore);

      var nextState = null;
      _this = _possibleConstructorReturn(this, _getPrototypeOf(VirtualListCore).call(this, _props));
      _this.scrollBounds = {
        clientWidth: 0,
        clientHeight: 0,
        scrollWidth: 0,
        scrollHeight: 0,
        maxLeft: 0,
        maxTop: 0
      };
      _this.moreInfo = {
        firstVisibleIndex: null,
        lastVisibleIndex: null
      };
      _this.primary = null;
      _this.secondary = null;
      _this.isPrimaryDirectionVertical = true;
      _this.isItemSized = false;
      _this.dimensionToExtent = 0;
      _this.threshold = 0;
      _this.maxFirstIndex = 0;
      _this.curDataSize = 0;
      _this.hasDataSizeChanged = false;
      _this.cc = [];
      _this.scrollPosition = 0;

      _this.isVertical = function () {
        return _this.isPrimaryDirectionVertical;
      };

      _this.isHorizontal = function () {
        return !_this.isPrimaryDirectionVertical;
      };

      _this.getScrollBounds = function () {
        return _this.scrollBounds;
      };

      _this.getMoreInfo = function () {
        return _this.moreInfo;
      };

      _this.getItemPosition = function (index) {
        var stickTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'start';

        var _assertThisInitialize = _assertThisInitialized(_this),
            primary = _assertThisInitialize.primary,
            position = _this.getGridPosition(index),
            offset = stickTo === 'start' ? 0 : primary.clientSize - primary.itemSize;

        position.primaryPosition -= offset;
        return _this.gridPositionToItemPosition(position);
      };

      _this.gridPositionToItemPosition = function (_ref) {
        var primaryPosition = _ref.primaryPosition,
            secondaryPosition = _ref.secondaryPosition;
        return _this.isPrimaryDirectionVertical ? {
          left: secondaryPosition,
          top: primaryPosition
        } : {
          left: primaryPosition,
          top: secondaryPosition
        };
      };

      _this.getXY = function (primaryPosition, secondaryPosition) {
        return _this.isPrimaryDirectionVertical ? {
          x: secondaryPosition,
          y: primaryPosition
        } : {
          x: primaryPosition,
          y: secondaryPosition
        };
      };

      _this.getClientSize = function (node) {
        return {
          clientWidth: node.clientWidth,
          clientHeight: node.clientHeight
        };
      };

      _this.getStatesAndUpdateBounds = function (props) {
        var firstIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var dataSize = props.dataSize,
            overhang = props.overhang,
            updateStatesAndBounds = props.updateStatesAndBounds,
            _assertThisInitialize2 = _assertThisInitialized(_this),
            dimensionToExtent = _assertThisInitialize2.dimensionToExtent,
            primary = _assertThisInitialize2.primary,
            moreInfo = _assertThisInitialize2.moreInfo,
            scrollPosition = _assertThisInitialize2.scrollPosition,
            numOfItems = Math.min(dataSize, dimensionToExtent * (Math.ceil(primary.clientSize / primary.gridSize) + overhang)),
            wasFirstIndexMax = _this.maxFirstIndex < moreInfo.firstVisibleIndex - dimensionToExtent && firstIndex === _this.maxFirstIndex,
            dataSizeDiff = dataSize - _this.curDataSize;

        var newFirstIndex = firstIndex;
        _this.maxFirstIndex = Math.ceil((dataSize - numOfItems) / dimensionToExtent) * dimensionToExtent;
        _this.curDataSize = dataSize; // reset children

        _this.cc = [];

        _this.calculateScrollBounds(props);

        _this.updateMoreInfo(dataSize, scrollPosition);

        if (!(updateStatesAndBounds && updateStatesAndBounds({
          cbScrollTo: props.cbScrollTo,
          numOfItems: numOfItems,
          dataSize: dataSize,
          moreInfo: moreInfo
        }))) {
          newFirstIndex = _this.calculateFirstIndex(props, wasFirstIndexMax, dataSizeDiff, firstIndex);
        }

        return {
          firstIndex: newFirstIndex,
          numOfItems: numOfItems
        };
      };

      _this.setContainerSize = function () {
        if (_this.contentRef.current) {
          _this.contentRef.current.style.width = _this.scrollBounds.scrollWidth + (_this.isPrimaryDirectionVertical ? -1 : 0) + 'px';
          _this.contentRef.current.style.height = _this.scrollBounds.scrollHeight + (_this.isPrimaryDirectionVertical ? 0 : -1) + 'px';
        }
      };

      _this.getItemNode = function (index) {
        var ref = _this.itemContainerRef.current;
        return ref ? ref.children[index % _this.state.numOfItems] : null;
      };

      _this.applyStyleToNewNode = function (index) {
        var _this2;

        var _this$props = _this.props,
            itemRenderer = _this$props.itemRenderer,
            getComponentProps = _this$props.getComponentProps,
            key = index % _this.state.numOfItems,
            itemElement = itemRenderer(_objectSpread({}, _this.props.childProps, {
          key: key,
          index: index
        })),
            componentProps = getComponentProps && getComponentProps(index) || {};

        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        _this.cc[key] = _react["default"].cloneElement(itemElement, _objectSpread({}, componentProps, {
          className: (0, _classnames["default"])(_VirtualListModule["default"].listItem, itemElement.props.className),
          style: _objectSpread({}, itemElement.props.style, (_this2 = _this).composeStyle.apply(_this2, rest))
        }));
      };

      _this.applyStyleToHideNode = function (index) {
        var key = index % _this.state.numOfItems;
        _this.cc[key] = _react["default"].createElement("div", {
          key: key,
          style: {
            display: 'none'
          }
        });
      };

      _this.getScrollHeight = function () {
        return _this.isPrimaryDirectionVertical ? _this.getVirtualScrollDimension() : _this.scrollBounds.clientHeight;
      };

      _this.getScrollWidth = function () {
        return _this.isPrimaryDirectionVertical ? _this.scrollBounds.clientWidth : _this.getVirtualScrollDimension();
      };

      _this.getVirtualScrollDimension = function () {
        var _assertThisInitialize3 = _assertThisInitialized(_this),
            dimensionToExtent = _assertThisInitialize3.dimensionToExtent,
            primary = _assertThisInitialize3.primary,
            curDataSize = _assertThisInitialize3.curDataSize,
            spacing = _this.props.spacing;

        return Math.ceil(curDataSize / dimensionToExtent) * primary.gridSize - spacing;
      };

      _this.syncClientSize = function () {
        var _assertThisInitialize4 = _assertThisInitialized(_this),
            props = _assertThisInitialize4.props,
            node = _this.containerRef.current;

        if (!props.clientSize && !node) {
          return false;
        }

        var _ref2 = props.clientSize || _this.getClientSize(node),
            clientWidth = _ref2.clientWidth,
            clientHeight = _ref2.clientHeight,
            _assertThisInitialize5 = _assertThisInitialized(_this),
            scrollBounds = _assertThisInitialize5.scrollBounds;

        if (clientWidth !== scrollBounds.clientWidth || clientHeight !== scrollBounds.clientHeight) {
          _this.calculateMetrics(props);

          _this.setState(_this.getStatesAndUpdateBounds(props));

          _this.setContainerSize();

          return true;
        }

        return false;
      };

      _this.mergeClasses = function (className) {
        var containerClass = null;

        if (type === Native) {
          containerClass = _this.isPrimaryDirectionVertical ? _VirtualListModule["default"].vertical : _VirtualListModule["default"].horizontal;
        }

        return (0, _classnames["default"])(_VirtualListModule["default"].virtualList, containerClass, className);
      };

      _this.containerRef = _react["default"].createRef();
      _this.contentRef = _react["default"].createRef();
      _this.itemContainerRef = _react["default"].createRef();

      if (_props.clientSize) {
        _this.calculateMetrics(_props);

        nextState = _this.getStatesAndUpdateBounds(_props);
      }

      _this.state = _objectSpread({
        firstIndex: 0,
        numOfItems: 0,
        prevChildProps: null,
        prevFirstIndex: 0,
        updateFrom: 0,
        updateTo: 0
      }, nextState);
      return _this;
    }

    _createClass(VirtualListCore, [{
      key: "componentDidMount",
      // Calculate metrics for VirtualList after the 1st render to know client W/H.
      value: function componentDidMount() {
        if (!this.props.clientSize) {
          this.calculateMetrics(this.props); // eslint-disable-next-line react/no-did-mount-set-state

          this.setState(this.getStatesAndUpdateBounds(this.props));
        }

        this.setContainerSize();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        // TODO: remove `this.hasDataSizeChanged` and fix ui/Scrollable*
        this.hasDataSizeChanged = prevProps.dataSize !== this.props.dataSize;

        if (prevProps.direction !== this.props.direction || prevProps.overhang !== this.props.overhang || prevProps.spacing !== this.props.spacing || !(0, _equals["default"])(prevProps.itemSize, this.props.itemSize)) {
          this.calculateMetrics(this.props); // eslint-disable-next-line react/no-did-update-set-state

          this.setState(this.getStatesAndUpdateBounds(this.props));
          this.setContainerSize();
        } else if (this.hasDataSizeChanged) {
          var newState = this.getStatesAndUpdateBounds(this.props, this.state.firstIndex); // eslint-disable-next-line react/no-did-update-set-state

          this.setState(newState);
          this.setContainerSize();
        } else if (prevProps.rtl !== this.props.rtl) {
          var _this$getXY = this.getXY(this.scrollPosition, 0),
              x = _this$getXY.x,
              y = _this$getXY.y;

          if (type === Native) {
            this.scrollToPosition(x, y, this.props.rtl);
          } else {
            this.setScrollPosition(x, y, this.props.rtl);
          }
        }
      }
    }, {
      key: "getGridPosition",
      value: function getGridPosition(index) {
        var dimensionToExtent = this.dimensionToExtent,
            primary = this.primary,
            secondary = this.secondary,
            primaryPosition = Math.floor(index / dimensionToExtent) * primary.gridSize,
            secondaryPosition = index % dimensionToExtent * secondary.gridSize;
        return {
          primaryPosition: primaryPosition,
          secondaryPosition: secondaryPosition
        };
      }
    }, {
      key: "calculateMetrics",
      value: function calculateMetrics(props) {
        var clientSize = props.clientSize,
            direction = props.direction,
            itemSize = props.itemSize,
            spacing = props.spacing,
            node = this.containerRef.current;

        if (!clientSize && !node) {
          return;
        }

        var _ref3 = clientSize || this.getClientSize(node),
            clientWidth = _ref3.clientWidth,
            clientHeight = _ref3.clientHeight,
            heightInfo = {
          clientSize: clientHeight,
          minItemSize: itemSize.minHeight || null,
          itemSize: itemSize
        },
            widthInfo = {
          clientSize: clientWidth,
          minItemSize: itemSize.minWidth || null,
          itemSize: itemSize
        };

        var primary, secondary, dimensionToExtent, thresholdBase;
        this.isPrimaryDirectionVertical = direction === 'vertical';

        if (this.isPrimaryDirectionVertical) {
          primary = heightInfo;
          secondary = widthInfo;
        } else {
          primary = widthInfo;
          secondary = heightInfo;
        }

        dimensionToExtent = 1;
        this.isItemSized = primary.minItemSize && secondary.minItemSize;

        if (this.isItemSized) {
          // the number of columns is the ratio of the available width plus the spacing
          // by the minimum item width plus the spacing
          dimensionToExtent = Math.max(Math.floor((secondary.clientSize + spacing) / (secondary.minItemSize + spacing)), 1); // the actual item width is a ratio of the remaining width after all columns
          // and spacing are accounted for and the number of columns that we know we should have

          secondary.itemSize = Math.floor((secondary.clientSize - spacing * (dimensionToExtent - 1)) / dimensionToExtent); // the actual item height is related to the item width

          primary.itemSize = Math.floor(primary.minItemSize * (secondary.itemSize / secondary.minItemSize));
        }

        primary.gridSize = primary.itemSize + spacing;
        secondary.gridSize = secondary.itemSize + spacing;
        thresholdBase = primary.gridSize * 2;
        this.threshold = {
          min: -Infinity,
          max: thresholdBase,
          base: thresholdBase
        };
        this.dimensionToExtent = dimensionToExtent;
        this.primary = primary;
        this.secondary = secondary; // reset

        this.scrollPosition = 0;

        if (type === JS && this.contentRef.current) {
          this.contentRef.current.style.transform = null;
        }
      }
    }, {
      key: "calculateFirstIndex",
      value: function calculateFirstIndex(props, wasFirstIndexMax, dataSizeDiff, firstIndex) {
        var overhang = props.overhang,
            dimensionToExtent = this.dimensionToExtent,
            isPrimaryDirectionVertical = this.isPrimaryDirectionVertical,
            maxFirstIndex = this.maxFirstIndex,
            primary = this.primary,
            scrollBounds = this.scrollBounds,
            scrollPosition = this.scrollPosition,
            threshold = this.threshold,
            gridSize = primary.gridSize;
        var newFirstIndex = firstIndex;

        if (wasFirstIndexMax && dataSizeDiff > 0) {
          // If dataSize increased from bottom, we need adjust firstIndex
          // If this is a gridlist and dataSizeDiff is smaller than 1 line, we are adjusting firstIndex without threshold change.
          if (dimensionToExtent > 1 && dataSizeDiff < dimensionToExtent) {
            newFirstIndex = maxFirstIndex;
          } else {
            // For other bottom adding case, we need to update firstIndex and threshold.
            var maxPos = isPrimaryDirectionVertical ? scrollBounds.maxTop : scrollBounds.maxLeft,
                maxOfMin = maxPos - threshold.base,
                numOfUpperLine = Math.floor(overhang / 2),
                firstIndexFromPosition = Math.floor(scrollPosition / gridSize),
                expectedFirstIndex = Math.max(0, firstIndexFromPosition - numOfUpperLine); // To navigate with 5way, we need to adjust firstIndex to the next line
            // since at the bottom we have num of overhang lines for upper side but none for bottom side
            // So we add numOfUpperLine at the top and rest lines at the bottom

            newFirstIndex = Math.min(maxFirstIndex, expectedFirstIndex * dimensionToExtent); // We need to update threshold also since we moved the firstIndex

            threshold.max = Math.min(maxPos, threshold.max + gridSize);
            threshold.min = Math.min(maxOfMin, threshold.max - gridSize);
          }
        } else {
          // Other cases, we can keep the min value between firstIndex and maxFirstIndex. No need to change threshold
          newFirstIndex = Math.min(firstIndex, maxFirstIndex);
        }

        return newFirstIndex;
      }
    }, {
      key: "calculateScrollBounds",
      value: function calculateScrollBounds(props) {
        var clientSize = props.clientSize,
            node = this.containerRef.current;

        if (!clientSize && !node) {
          return;
        }

        var scrollBounds = this.scrollBounds,
            isPrimaryDirectionVertical = this.isPrimaryDirectionVertical,
            _ref4 = clientSize || this.getClientSize(node),
            clientWidth = _ref4.clientWidth,
            clientHeight = _ref4.clientHeight;

        var maxPos;
        scrollBounds.clientWidth = clientWidth;
        scrollBounds.clientHeight = clientHeight;
        scrollBounds.scrollWidth = this.getScrollWidth();
        scrollBounds.scrollHeight = this.getScrollHeight();
        scrollBounds.maxLeft = Math.max(0, scrollBounds.scrollWidth - clientWidth);
        scrollBounds.maxTop = Math.max(0, scrollBounds.scrollHeight - clientHeight); // correct position

        maxPos = isPrimaryDirectionVertical ? scrollBounds.maxTop : scrollBounds.maxLeft;
        this.syncThreshold(maxPos);

        if (this.scrollPosition > maxPos) {
          this.props.cbScrollTo({
            position: isPrimaryDirectionVertical ? {
              y: maxPos
            } : {
              x: maxPos
            },
            animate: false
          });
        }
      }
    }, {
      key: "updateMoreInfo",
      value: function updateMoreInfo(dataSize, primaryPosition) {
        var dimensionToExtent = this.dimensionToExtent,
            moreInfo = this.moreInfo,
            _this$primary = this.primary,
            itemSize = _this$primary.itemSize,
            gridSize = _this$primary.gridSize,
            clientSize = _this$primary.clientSize;

        if (dataSize <= 0) {
          moreInfo.firstVisibleIndex = null;
          moreInfo.lastVisibleIndex = null;
        } else {
          moreInfo.firstVisibleIndex = (Math.floor((primaryPosition - itemSize) / gridSize) + 1) * dimensionToExtent;
          moreInfo.lastVisibleIndex = Math.min(dataSize - 1, Math.ceil((primaryPosition + clientSize) / gridSize) * dimensionToExtent - 1);
        }
      }
    }, {
      key: "syncThreshold",
      value: function syncThreshold(maxPos) {
        var threshold = this.threshold;

        if (threshold.max > maxPos) {
          if (maxPos < threshold.base) {
            threshold.max = threshold.base;
            threshold.min = -Infinity;
          } else {
            threshold.max = maxPos;
            threshold.min = maxPos - threshold.base;
          }
        }
      } // Native only

    }, {
      key: "scrollToPosition",
      value: function scrollToPosition(x, y) {
        var rtl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.rtl;

        if (this.containerRef.current) {
          if (rtl) {
            x = _platform.platform.ios || _platform.platform.safari ? -x : this.scrollBounds.maxLeft - x;
          }

          this.containerRef.current.scrollTo(x, y);
        }
      } // JS only

    }, {
      key: "setScrollPosition",
      value: function setScrollPosition(x, y) {
        var rtl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.rtl;

        if (this.contentRef.current) {
          this.contentRef.current.style.transform = "translate3d(".concat(rtl ? x : -x, "px, -").concat(y, "px, 0)");
          this.didScroll(x, y);
        }
      }
    }, {
      key: "didScroll",
      value: function didScroll(x, y) {
        var dataSize = this.props.dataSize,
            firstIndex = this.state.firstIndex,
            isPrimaryDirectionVertical = this.isPrimaryDirectionVertical,
            threshold = this.threshold,
            dimensionToExtent = this.dimensionToExtent,
            maxFirstIndex = this.maxFirstIndex,
            scrollBounds = this.scrollBounds,
            gridSize = this.primary.gridSize,
            maxPos = isPrimaryDirectionVertical ? scrollBounds.maxTop : scrollBounds.maxLeft;
        var newFirstIndex = firstIndex,
            pos;

        if (isPrimaryDirectionVertical) {
          pos = y;
        } else {
          pos = x;
        }

        if (pos > threshold.max || pos < threshold.min) {
          var overhangBefore = Math.floor(this.props.overhang / 2),
              firstExtent = Math.max(0, Math.min(Math.floor(maxFirstIndex / dimensionToExtent), Math.floor((pos - gridSize * overhangBefore) / gridSize)));
          var newThresholdMin, newThresholdMax;
          newFirstIndex = firstExtent * dimensionToExtent;
          newThresholdMin = (firstExtent + overhangBefore) * gridSize;
          newThresholdMax = newThresholdMin + gridSize;
          threshold.min = newFirstIndex === 0 ? -Infinity : newThresholdMin;
          threshold.max = newFirstIndex === maxFirstIndex ? Infinity : newThresholdMax;
        }

        this.syncThreshold(maxPos);
        this.scrollPosition = pos;
        this.updateMoreInfo(dataSize, pos);

        if (firstIndex !== newFirstIndex) {
          this.setState({
            firstIndex: newFirstIndex
          });
        }
      }
    }, {
      key: "composeStyle",
      value: function composeStyle(width, height, primaryPosition, secondaryPosition) {
        var _this$getXY2 = this.getXY(primaryPosition, secondaryPosition),
            x = _this$getXY2.x,
            y = _this$getXY2.y,
            style = {
          position: 'absolute',

          /* FIXME: RTL / this calculation only works for Chrome */
          transform: "translate3d(".concat(this.props.rtl ? -x : x, "px, ").concat(y, "px, 0)")
        };

        if (this.isItemSized) {
          style.width = width;
          style.height = height;
        }

        return style;
      }
    }, {
      key: "positionItems",
      value: function positionItems() {
        var dataSize = this.props.dataSize,
            _this$state = this.state,
            firstIndex = _this$state.firstIndex,
            numOfItems = _this$state.numOfItems,
            cc = this.cc,
            isPrimaryDirectionVertical = this.isPrimaryDirectionVertical,
            dimensionToExtent = this.dimensionToExtent,
            primary = this.primary,
            secondary = this.secondary;
        var hideTo = 0,
            updateFrom = cc.length ? this.state.updateFrom : firstIndex,
            updateTo = cc.length ? this.state.updateTo : firstIndex + numOfItems;

        if (updateFrom >= updateTo) {
          return;
        } else if (updateTo > dataSize) {
          hideTo = updateTo;
          updateTo = dataSize;
        }

        var width,
            height,
            _this$getGridPosition = this.getGridPosition(updateFrom),
            primaryPosition = _this$getGridPosition.primaryPosition,
            secondaryPosition = _this$getGridPosition.secondaryPosition;

        width = (isPrimaryDirectionVertical ? secondary.itemSize : primary.itemSize) + 'px';
        height = (isPrimaryDirectionVertical ? primary.itemSize : secondary.itemSize) + 'px'; // positioning items

        for (var i = updateFrom, j = updateFrom % dimensionToExtent; i < updateTo; i++) {
          this.applyStyleToNewNode(i, width, height, primaryPosition, secondaryPosition);

          if (++j === dimensionToExtent) {
            secondaryPosition = 0;
            primaryPosition += primary.gridSize;
            j = 0;
          } else {
            secondaryPosition += secondary.gridSize;
          }
        }

        for (var _i = updateTo; _i < hideTo; _i++) {
          this.applyStyleToHideNode(_i);
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            className = _this$props2.className,
            voiceFocused = _this$props2['data-webos-voice-focused'],
            voiceGroupLabel = _this$props2['data-webos-voice-group-label'],
            itemsRenderer = _this$props2.itemsRenderer,
            style = _this$props2.style,
            rest = _objectWithoutProperties(_this$props2, ["className", "data-webos-voice-focused", "data-webos-voice-group-label", "itemsRenderer", "style"]),
            cc = this.cc,
            itemContainerRef = this.itemContainerRef,
            primary = this.primary,
            containerClasses = this.mergeClasses(className);

        delete rest.cbScrollTo;
        delete rest.childProps;
        delete rest.clientSize;
        delete rest.dataSize;
        delete rest.direction;
        delete rest.getComponentProps;
        delete rest.isVerticalScrollbarVisible;
        delete rest.itemRenderer;
        delete rest.itemSize;
        delete rest.onUpdate;
        delete rest.overhang;
        delete rest.pageScroll;
        delete rest.rtl;
        delete rest.spacing;
        delete rest.updateStatesAndBounds;

        if (primary) {
          this.positionItems();
        }

        return _react["default"].createElement("div", {
          className: containerClasses,
          "data-webos-voice-focused": voiceFocused,
          "data-webos-voice-group-label": voiceGroupLabel,
          ref: this.containerRef,
          style: style
        }, _react["default"].createElement("div", Object.assign({}, rest, {
          ref: this.contentRef
        }), itemsRenderer({
          cc: cc,
          itemContainerRef: itemContainerRef,
          primary: primary
        })));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var shouldInvalidate = state.prevFirstIndex === state.firstIndex || state.prevChildProps !== props.childProps,
            diff = state.firstIndex - state.prevFirstIndex,
            updateTo = -state.numOfItems >= diff || diff > 0 || shouldInvalidate ? state.firstIndex + state.numOfItems : state.prevFirstIndex,
            updateFrom = 0 >= diff || diff >= state.numOfItems || shouldInvalidate ? state.firstIndex : state.prevFirstIndex + state.numOfItems,
            nextUpdateFromAndTo = state.updateFrom !== updateFrom || state.updateTo !== updateTo ? {
          updateFrom: updateFrom,
          updateTo: updateTo
        } : null;
        return _objectSpread({}, nextUpdateFromAndTo, {
          prevChildProps: props.childProps,
          prevFirstIndex: state.firstIndex
        });
      }
    }]);

    return VirtualListCore;
  }(_react.Component), _class.propTypes =
  /** @lends ui/VirtualList.VirtualListBase.prototype */
  {
    /**
     * The rendering function called for each item in the list.
     *
     * > **Note**: The list does **not** always render a component whenever its render function is called
     * due to performance optimization.
     *
     * Example:
     * ```
     * renderItem = ({index, ...rest}) => {
     * 	delete rest.data;
     *
     * 	return (
     * 		<MyComponent index={index} {...rest} />
     * 	);
     * }
     * ```
     *
     * @type {Function}
     * @param {Object}     event
     * @param {Number}     event.data-index    It is required for `Spotlight` 5-way navigation. Pass to the root element in the component.
     * @param {Number}     event.index    The index number of the component to render
     * @param {Number}     event.key    It MUST be passed as a prop to the root element in the component for DOM recycling.
     *
     * @required
     * @public
     */
    itemRenderer: _propTypes["default"].func.isRequired,

    /**
     * The size of an item for the list; valid values are either a number for `VirtualList`
     * or an object that has `minWidth` and `minHeight` for `VirtualGridList`.
     *
     * @type {Number|ui/VirtualList.gridListItemSizeShape}
     * @required
     * @private
     */
    itemSize: _propTypes["default"].oneOfType([_propTypes["default"].number, gridListItemSizeShape]).isRequired,

    /**
     * The render function for the items.
     *
     * @type {Function}
     * @required
     * @private
     */
    itemsRenderer: _propTypes["default"].func.isRequired,

    /**
     * Callback method of scrollTo.
     * Normally, [Scrollable]{@link ui/Scrollable.Scrollable} should set this value.
     *
     * @type {Function}
     * @private
     */
    cbScrollTo: _propTypes["default"].func,

    /**
     * Additional props included in the object passed to the `itemsRenderer` callback.
     *
     * @type {Object}
     * @public
     */
    childProps: _propTypes["default"].object,

    /**
     * Client size of the list; valid values are an object that has `clientWidth` and `clientHeight`.
     *
     * @type {Object}
     * @property {Number}    clientHeight    The client height of the list.
     * @property {Number}    clientWidth    The client width of the list.
     * @public
     */
    clientSize: _propTypes["default"].shape({
      clientHeight: _propTypes["default"].number.isRequired,
      clientWidth: _propTypes["default"].number.isRequired
    }),

    /**
     * Activates the component for voice control.
     *
     * @type {Boolean}
     * @private
     */
    'data-webos-voice-focused': _propTypes["default"].bool,

    /**
     * The voice control group label.
     *
     * @type {String}
     * @private
     */
    'data-webos-voice-group-label': _propTypes["default"].string,

    /**
     * The number of items of data the list contains.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    dataSize: _propTypes["default"].number,

    /**
     * The layout direction of the list.
     *
     * Valid values are:
     * * `'horizontal'`, and
     * * `'vertical'`.
     *
     * @type {String}
     * @default 'vertical'
     * @public
     */
    direction: _propTypes["default"].oneOf(['horizontal', 'vertical']),

    /**
     * Called to get the props for list items.
     *
     * @type {Function}
     * @private
     */
    getComponentProps: _propTypes["default"].func,

    /**
     * Number of spare DOM node.
     * `3` is good for the default value experimentally and
     * this value is highly recommended not to be changed by developers.
     *
     * @type {Number}
     * @default 3
     * @private
     */
    overhang: _propTypes["default"].number,

    /**
     * When `true`, the list will scroll by page.  Otherwise the list will scroll by item.
     *
     * @type {Boolean}
     * @default false
     * @private
     */
    pageScroll: _propTypes["default"].bool,

    /**
     * `true` if RTL, `false` if LTR.
     *
     * @type {Boolean}
     * @private
     */
    rtl: _propTypes["default"].bool,

    /**
     * The spacing between items.
     *
     * @type {Number}
     * @default 0
     * @public
     */
    spacing: _propTypes["default"].number,

    /**
     * Called to execute additional logic in a themed component when updating states and bounds.
     *
     * @type {Function}
     * @private
     */
    updateStatesAndBounds: _propTypes["default"].func
  }, _class.defaultProps = {
    cbScrollTo: nop,
    dataSize: 0,
    direction: 'vertical',
    overhang: 3,
    pageScroll: false,
    spacing: 0
  }, _temp;
};
/**
 * A basic base component for
 * [VirtualList]{@link ui/VirtualList.VirtualList} and [VirtualGridList]{@link ui/VirtualList.VirtualGridList}.
 *
 * @class VirtualListBase
 * @memberof ui/VirtualList
 * @ui
 * @private
 */


var VirtualListBase = VirtualListBaseFactory(JS);
exports.VirtualListBase = VirtualListBase;
VirtualListBase.displayName = 'ui:VirtualListBase';
/**
 * A basic base component for
 * [VirtualListNative]{@link ui/VirtualList.VirtualListNative} and [VirtualGridListNative]{@link ui/VirtualList.VirtualGridListNative}.
 *
 * @class VirtualListBaseNative
 * @memberof ui/VirtualList
 * @ui
 * @private
 */

var VirtualListBaseNative = VirtualListBaseFactory(Native);
exports.VirtualListBaseNative = VirtualListBaseNative;
VirtualListBaseNative.displayName = 'ui:VirtualListBaseNative';

var ScrollableVirtualList = function ScrollableVirtualList(props) {
  return _react["default"].createElement(_Scrollable["default"], Object.assign({}, props, {
    childRenderer: function childRenderer(_ref5) {
      var initChildRef = _ref5.initChildRef,
          rest = _objectWithoutProperties(_ref5, ["initChildRef"]);

      return (// eslint-disable-line react/jsx-no-bind
        _react["default"].createElement(VirtualListBase, Object.assign({}, rest, {
          itemsRenderer: function itemsRenderer(_ref6) {
            var cc = _ref6.cc,
                itemContainerRef = _ref6.itemContainerRef;
            return (// eslint-disable-line react/jsx-no-bind
              cc.length ? _react["default"].createElement("div", {
                ref: itemContainerRef,
                role: "list"
              }, cc) : null
            );
          },
          ref: initChildRef
        }))
      );
    }
  }));
};

exports.ScrollableVirtualList = ScrollableVirtualList;
ScrollableVirtualList.propTypes = {
  direction: _propTypes["default"].oneOf(['horizontal', 'vertical'])
};
ScrollableVirtualList.defaultProps = {
  direction: 'vertical'
};

var ScrollableVirtualListNative = function ScrollableVirtualListNative(props) {
  return _react["default"].createElement(_ScrollableNative["default"], Object.assign({}, props, {
    childRenderer: function childRenderer(_ref7) {
      var initChildRef = _ref7.initChildRef,
          rest = _objectWithoutProperties(_ref7, ["initChildRef"]);

      return (// eslint-disable-line react/jsx-no-bind
        _react["default"].createElement(VirtualListBaseNative, Object.assign({}, rest, {
          itemsRenderer: function itemsRenderer(_ref8) {
            var cc = _ref8.cc,
                itemContainerRef = _ref8.itemContainerRef;
            return (// eslint-disable-line react/jsx-no-bind
              cc.length ? _react["default"].createElement("div", {
                ref: itemContainerRef,
                role: "list"
              }, cc) : null
            );
          },
          ref: initChildRef
        }))
      );
    }
  }));
};

exports.ScrollableVirtualListNative = ScrollableVirtualListNative;
ScrollableVirtualListNative.propTypes =
/** @lends ui/VirtualList.VirtualListBaseNative.prototype */
{
  /**
   * The layout direction of the list.
   *
   * Valid values are:
   * * `'horizontal'`, and
   * * `'vertical'`.
   *
   * @type {String}
   * @default 'vertical'
   * @public
   */
  direction: _propTypes["default"].oneOf(['horizontal', 'vertical'])
};
ScrollableVirtualListNative.defaultProps = {
  direction: 'vertical'
};
var _default = VirtualListBase;
exports["default"] = _default;