"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNavigableTarget = getNavigableTarget;
exports.getTargetByContainer = getTargetByContainer;
exports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;
exports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;
exports.getTargetBySelector = getTargetBySelector;
exports.isFocusable = isFocusable;

var _last = _interopRequireDefault(require("ramda/src/last"));

var _container = require("./container");

var _navigate = _interopRequireDefault(require("./navigate"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function isFocusable(elem) {
  var containers = (0, _container.getContainersForNode)(elem);
  var verifySelector = true;

  for (var i = containers.length - 1; i >= 0; i--) {
    var containerId = containers[i];

    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {
      return false;
    } // only verify selector for the first (immediate ancestor) container


    verifySelector = false;
  }

  return true;
}

function getContainersToSearch(containerId) {
  var range = [];

  var addRange = function addRange(id) {
    var config = (0, _container.getContainerConfig)(id);

    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {
      range.push(id);
    }
  };

  if (containerId) {
    addRange(containerId);
  } else {
    addRange((0, _container.getDefaultContainer)());
    addRange((0, _container.getLastContainer)());

    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);
  }

  return range;
}

function getTargetByContainer(containerId) {
  return getContainersToSearch(containerId).reduce(function (next, id) {
    return next || (0, _container.getContainerFocusTarget)(id);
  }, null);
}

function getTargetBySelector(selector) {
  if (!selector) return null;

  if (selector.charAt(0) === '@') {
    var containerId = selector.length === 1 ? null : selector.substr(1);
    return getTargetByContainer(containerId);
  }

  var next = (0, _utils.parseSelector)(selector)[0];

  if (next) {
    var nextContainerIds = (0, _container.getContainersForNode)(next);

    if ((0, _container.isNavigable)(next, (0, _last["default"])(nextContainerIds), true)) {
      return next;
    }
  }

  return null;
}

function isRestrictedContainer(containerId) {
  var config = (0, _container.getContainerConfig)(containerId);
  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');
}

function getSpottableDescendantsWithoutContainers(containerId, containerIds) {
  return (0, _container.getSpottableDescendants)(containerId).filter(function (n) {
    return !(0, _container.isContainer)(n) || containerIds.indexOf(n.dataset.spotlightId) === -1;
  });
}

function filterRects(elementRects, boundingRect) {
  if (!boundingRect) {
    return elementRects;
  } // remove elements that are outside of boundingRect, if specified


  return elementRects.filter(function (rect) {
    if ((0, _container.isContainer)(rect.element)) {
      // For containers, test intersection since they may be larger than the bounding rect
      return (0, _utils.intersects)(boundingRect, rect);
    } else {
      // For elements, use contains with the center to include mostly visible elements
      return (0, _utils.contains)(boundingRect, rect.center);
    }
  }).map(function (rect) {
    var topUpdate = rect.top < boundingRect.top;
    var bottomUpdate = rect.bottom > boundingRect.bottom;
    var leftUpdate = rect.left < boundingRect.left;
    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and
    // recalculate the center based on the new bounds.

    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {
      var updated = _objectSpread({}, rect, {
        center: _objectSpread({}, rect.center)
      });

      if (topUpdate) updated.top = boundingRect.top;
      if (bottomUpdate) updated.bottom = boundingRect.bottom;
      if (leftUpdate) updated.left = boundingRect.left;
      if (rightUpdate) updated.right = boundingRect.right;

      if (leftUpdate || rightUpdate) {
        var centerX = updated.left + (updated.right - updated.left) / 2;
        updated.center.x = updated.center.left = updated.center.right = centerX;
      }

      if (topUpdate || bottomUpdate) {
        var centerY = updated.top + (updated.bottom - updated.top) / 2;
        updated.center.y = updated.center.top = updated.center.bottom = centerY;
      }

      return updated;
    }

    return rect;
  });
}

function getContainerContainingRect(elementRects, elementRect) {
  // find candidates that are containers and *visually* contain element
  var overlapping = elementRects.filter(function (rect) {
    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);
  }); // if the next element is a container AND the current element is *visually* contained within
  // one of the candidate element, we need to ignore container `enterTo` preferences and
  // retrieve its spottable descendants and try to navigate to them.

  if (overlapping.length) {
    return overlapping[0].element.dataset.spotlightId;
  }

  return false;
}

function getOverflowContainerRect(containerId) {
  // if the target container has overflowing content, update the boundingRect to match its
  // bounds to prevent finding elements within the container's hierarchy but not visible.
  // This filter only applies when waterfalling to prevent filtering out elements that share
  // a container tree with `element`
  var nextConfig = (0, _container.getContainerConfig)(containerId);

  if (nextConfig && nextConfig.overflow) {
    return (0, _utils.getContainerRect)(containerId);
  }
}

function getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {
  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds);
  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;

  var _loop2 = function _loop2() {
    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container
    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.

    if (overlappingContainerId) {
      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element.dataset.spotlightId !== overlappingContainerId;
        });
        return "continue";
      } // found a target so break out and return


      return "break";
    } // try to navigate from position to one of the candidates in containerId


    next = (0, _navigate["default"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it

    if (next && (0, _container.isContainer)(next)) {
      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary

      var lastNavigated = next;
      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element !== lastNavigated;
        });
        return "continue";
      }
    } // If we've met every condition and haven't explicitly retried the search via `continue`,
    // break out and return


    return "break";
  };

  _loop: while (elementRects.length > 0) {
    var _ret = _loop2();

    switch (_ret) {
      case "continue":
        continue;

      case "break":
        break _loop;
    }
  }

  return next;
}

function getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {
  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds); // shortcut for previous target from element if it were saved

  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);

  if (previous && elements.indexOf(previous) !== -1) {
    return previous;
  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an
  // spotlight container with `overflow: true` to be treated as if it were outside of the
  // container. The result is that the candidates, `elements` are filtered by the bounds of the
  // overflow container effectively hiding those that have overflowed and are visually hidden.
  //
  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to
  // escape the Scrollable from paging controls rather than focusing contents that are out of view


  if (element.dataset.spotlightOverflow === 'ignore') {
    boundingRect = getOverflowContainerRect(containerId) || boundingRect;
  }

  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;

  var _loop4 = function _loop4() {
    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within
    // one of the candidate elements, we need to ignore container `enterTo` preferences and
    // retrieve its spottable descendants and try to navigate to them.

    if (overlappingContainerId) {
      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element.dataset.spotlightId !== overlappingContainerId;
        });
        return "continue";
      } // found a target so break out and return


      return "break";
    } // try to navigate from element to one of the candidates in containerId


    next = (0, _navigate["default"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container,

    if (next && (0, _container.isContainer)(next)) {
      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary

      var lastNavigated = next; // and it is restricted, return its target

      if (isRestrictedContainer(nextContainerId)) {
        next = getTargetByContainer(nextContainerId);
      } else {
        // otherwise, recurse into it
        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);
      }

      if (!next) {
        elementRects = elementRects.filter(function (rect) {
          return rect.element !== lastNavigated;
        });
        return "continue";
      }
    } // If we've met every condition and haven't explicitly retried the search via `continue`,
    // break out and return


    return "break";
  };

  _loop3: while (elementRects.length > 0) {
    var _ret2 = _loop4();

    switch (_ret2) {
      case "continue":
        continue;

      case "break":
        break _loop3;
    }
  }

  return next;
}

function getTargetByDirectionFromElement(direction, element) {
  var extSelector = element.getAttribute('data-spot-' + direction);

  if (typeof extSelector === 'string') {
    return getTargetBySelector(extSelector);
  }

  var elementRect = (0, _utils.getRect)(element);
  return (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {
    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);

    if (!result) {
      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current
      // `direction`, we return the current element to prevent further searches for a
      // target in this reduction.

      if (result === false) {
        result = element;
      }
    }

    return result;
  }, null);
}

function getTargetByDirectionFromPosition(direction, position, containerId) {
  var pointerRect = (0, _utils.getPointRect)(position);
  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {
    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);
  }, null);
}
/**
 * Returns the target identified by the selector configured for the container identified by
 * `containerId` for the given `direction`. If the selector is an empty string, the method returns
 * `false` indicating that navigation isn't allowed out of the container in that direction.
 *
 * @param   {String}        containerId  Identifier for a container
 * @param   {String}        direction    Direction to navigate (up, down, left, right)
 *
 * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed
 * @private
 */


function getLeaveForTarget(containerId, direction) {
  var config = (0, _container.getContainerConfig)(containerId);

  if (config) {
    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];

    if (typeof target === 'string') {
      if (target === '') {
        return false;
      }

      return getTargetBySelector(target);
    }

    var nextContainerIds = (0, _container.getContainersForNode)(target);

    if ((0, _container.isNavigable)(target, (0, _last["default"])(nextContainerIds))) {
      return target;
    }
  }

  return null;
}

function getNavigableTarget(target) {
  if (target === document) return null;
  var parent;

  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {
    parent = target.parentNode;
    target = parent === document ? null : parent; // calling isNavigable on document is problematic
  }

  return target;
}