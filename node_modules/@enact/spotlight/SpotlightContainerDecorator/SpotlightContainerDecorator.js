"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spotlightDefaultClass = exports.SpotlightContainerDecorator = exports["default"] = void 0;

var _handle = require("@enact/core/handle");

var _hoc = _interopRequireDefault(require("@enact/core/hoc"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _pointer = require("../src/pointer");

var _spotlight = _interopRequireDefault(require("../src/spotlight"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * The class name to apply to the default component to focus in a container.
 *
 * @memberof spotlight/SpotlightContainerDecorator
 * @public
 */
var spotlightDefaultClass = 'spottable-default';
exports.spotlightDefaultClass = spotlightDefaultClass;

var isNewPointerPosition = function isNewPointerPosition(ev) {
  return (0, _pointer.hasPointerMoved)(ev.clientX, ev.clientY);
};

var not = function not(fn) {
  return function () {
    return !fn.apply(this, arguments);
  };
};
/**
 * Default config for {@link spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator}
 *
 * @memberof spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator
 * @hocconfig
 */


var defaultConfig = {
  /**
   * When `true`, allows focus to move outside the container to the next spottable element when
   * holding 5 way keys.
   *
   * @type {Boolean}
   * @default false
   * @memberof spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator.defaultConfig
   * @public
   */
  continue5WayHold: false,

  /**
   * The selector for the default spottable element within the container.
   *
   * @type {String}
   * @default '.spottable-default'
   * @memberof spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator.defaultConfig
   * @public
   */
  defaultElement: ".".concat(spotlightDefaultClass),

  /**
   * Directs which element receives focus when gaining focus from another container. If
   * `'default-element'`, the default focused item will be selected. If `'last-focused'`, the
   * container will focus the last focused item; if the container has never had focus, the default
   * element will receive focus. If `null`, the default 5-way behavior will be applied.
   *
   * @type {String}
   * @default null
   * @memberof spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator.defaultConfig
   * @public
   */
  enterTo: null,

  /**
   * Whether the container will preserve the id when it unmounts.
   *
   * @type {Boolean}
   * @default false
   * @memberof spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator.defaultConfig
   * @public
   */
  preserveId: false
};
/**
 * Constructs a higher-order component that allows Spotlight focus to be passed to
 * its own configurable hierarchy of spottable child controls.
 *
 * Example:
 * ```
 *	const DefaultContainer = SpotlightContainerDecorator(Component);
 *	const FocusDefaultContainer = SpotlightContainerDecorator({enterTo: 'default-element'}, Component);
 * ```
 *
 * To specify a default element to spot in a container, utilize the `spotlightDefaultClass`.
 *
 * Example:
 * ```
 *	import Spotlight from '@enact/spotlight';
 *	import SpotlightContainerDecorator from '@enact/spotlight/SpotlightContainerDecorator';
 *	const ContainerComponent = SpotlightContainerDecorator(Component);
 *	const View = kind({
 *		render: () => {
 *			<ContainerComponent>
 *				<SpottableComponent>foo</SpottableComponent>
 *				<SpottableComponent className={spotlightDefaultClass}>spot me first</SpottableComponent>
 *			</ContainerComponent>
 *		}
 *	});
 * ```
 * @param  {Object}    defaultConfig  Set of default configuration parameters. Additional parameters
 *                                    are passed as configuration to {@link spotlight/Spotlight.set}
 * @param  {Function} higher-order component
 *
 * @returns {Function} SpotlightContainerDecorator
 * @class SpotlightContainerDecorator
 * @memberof spotlight/SpotlightContainerDecorator
 * @hoc
 */

var SpotlightContainerDecorator = (0, _hoc["default"])(defaultConfig, function (config, Wrapped) {
  var _class, _temp;

  var navigableFilter = config.navigableFilter,
      preserveId = config.preserveId,
      containerConfig = _objectWithoutProperties(config, ["navigableFilter", "preserveId"]);

  var stateFromProps = function stateFromProps(_ref) {
    var spotlightId = _ref.spotlightId,
        spotlightRestrict = _ref.spotlightRestrict;
    var options = {
      restrict: spotlightRestrict
    };

    var id = _spotlight["default"].add(spotlightId || options, options);

    return {
      id: id,
      preserveId: preserveId && id === spotlightId,
      spotlightRestrict: spotlightRestrict
    };
  };

  var releaseContainer = function releaseContainer(_ref2) {
    var preserve = _ref2.preserveId,
        id = _ref2.id;

    if (preserve) {
      _spotlight["default"].unmount(id);
    } else {
      _spotlight["default"].remove(id);
    }
  };

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inherits(_class, _React$Component);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));

      _this.navigableFilter = function (elem) {
        // If the component to which this was applied specified a navigableFilter, run it
        if (typeof navigableFilter === 'function') {
          if (navigableFilter(elem, _this.props, _this.context) === false) {
            return false;
          }
        }

        return true;
      };

      _this.silentBlur = function (_ref3) {
        var target = _ref3.target;
        _this.shouldPreventBlur = true;
        target.blur();
        _this.shouldPreventBlur = false;
      };

      _this.handle = _handle.handle.bind(_assertThisInitialized(_this));
      _this.handleBlur = _this.handle(function () {
        return _this.shouldPreventBlur;
      }, _handle.stop);
      _this.handleFocus = _this.handle((0, _handle.forProp)('spotlightDisabled', true), _handle.stop, _this.silentBlur);
      _this.handleMouseEnter = _this.handle((0, _handle.forward)('onMouseEnter'), isNewPointerPosition, function () {
        return _spotlight["default"].setActiveContainer(_this.state.id);
      });
      _this.handleMouseLeave = _this.handle((0, _handle.forward)('onMouseLeave'), not((0, _handle.forProp)('spotlightRestrict', 'self-only')), isNewPointerPosition, function (ev) {
        var parentContainer = ev.currentTarget.parentNode.closest('[data-spotlight-container]');

        var activeContainer = _spotlight["default"].getActiveContainer(); // if this container is wrapped by another and this is the currently active
        // container, move the active container to the parent


        if (parentContainer && activeContainer === _this.state.id) {
          activeContainer = parentContainer.dataset.spotlightId;

          _spotlight["default"].setActiveContainer(activeContainer);
        }
      });
      _this.state = stateFromProps(props); // Used to indicate that we want to stop propagation on blur events that occur as a
      // result of this component imperatively blurring itself on focus when spotlightDisabled

      _this.shouldPreventBlur = false;

      var cfg = _objectSpread({}, containerConfig, {
        navigableFilter: _this.navigableFilter
      });

      _spotlight["default"].set(_this.state.id, cfg);

      return _this;
    }

    _createClass(_class, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        releaseContainer(this.state);
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            spotlightDisabled = _this$props.spotlightDisabled,
            spotlightMuted = _this$props.spotlightMuted,
            rest = _objectWithoutProperties(_this$props, ["spotlightDisabled", "spotlightMuted"]);

        delete rest.containerId;
        delete rest.spotlightId;
        delete rest.spotlightRestrict;
        rest['data-spotlight-container'] = true;
        rest['data-spotlight-id'] = this.state.id;
        rest.onBlurCapture = this.handleBlur;
        rest.onFocusCapture = this.handleFocus;
        rest.onMouseEnter = this.handleMouseEnter;
        rest.onMouseLeave = this.handleMouseLeave;

        if (spotlightDisabled) {
          rest['data-spotlight-container-disabled'] = spotlightDisabled;
        }

        if (spotlightMuted) {
          rest['data-spotlight-container-muted'] = spotlightMuted;
        }

        return _react["default"].createElement(Wrapped, rest);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(props, state) {
        var id = props.spotlightId,
            spotlightRestrict = props.spotlightRestrict;
        var prevId = state.id,
            prevSpotlightRestrict = state.spotlightRestrict; // prevId will only be undefined the first render so this prevents releasing the
        // container after initially creating it

        var isIdChanged = prevId && id && prevId !== id;

        if (isIdChanged) {
          releaseContainer(state);
        }

        if (isIdChanged || spotlightRestrict !== prevSpotlightRestrict) {
          return stateFromProps(_objectSpread({
            spotlightId: prevId,
            spotlightRestrict: prevSpotlightRestrict
          }, props));
        } else {
          return null;
        }
      }
    }]);

    return _class;
  }(_react["default"].Component), _class.displayName = 'SpotlightContainerDecorator', _class.propTypes =
  /** @lends spotlight/SpotlightContainerDecorator.SpotlightContainerDecorator.prototype */
  {
    /**
     * When `true`, controls in the container cannot be navigated.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    spotlightDisabled: _propTypes["default"].bool,

    /**
     * Used to identify this component within the Spotlight system.
     *
     * If the value is `null`, an id will be generated.
     *
     * @type {String}
     * @public
     */
    spotlightId: _propTypes["default"].string,

    /**
     * Whether or not the container is in muted mode.
     *
     * @type {Boolean}
     * @default false
     * @public
     */
    spotlightMuted: _propTypes["default"].bool,

    /**
     * Restricts or prioritizes navigation when focus attempts to leave the container. It
     * can be either 'none', 'self-first', or 'self-only'. Specifying 'self-first' indicates that
     * elements within the container will have a higher likelihood to be chosen as the next
     * navigable element. Specifying 'self-only' indicates that elements in other containers
     * cannot be navigated to by using 5-way navigation - however, elements in other containers
     * can still receive focus by calling `Spotlight.focus(elem)` explicitly. Specying 'none'
     * indicates there should be no restrictions when 5-way navigating the container.
     *
     * @type {String}
     * @public
     */
    spotlightRestrict: _propTypes["default"].oneOf(['none', 'self-first', 'self-only'])
  }, _class.defaultProps = {
    spotlightDisabled: false,
    spotlightMuted: false,
    spotlightRestrict: 'self-first'
  }, _temp;
});
exports.SpotlightContainerDecorator = SpotlightContainerDecorator;
var _default = SpotlightContainerDecorator;
exports["default"] = _default;