{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.navigate = navigate;\nexports[\"default\"] = void 0;\nvar obliqueMinDistance = 1;\nvar straightMinDistance = 0;\n\nvar calcGroupId = function calcGroupId(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  return y * 3 + x;\n};\n\nvar calcNextGridPosition = function calcNextGridPosition(current, next) {\n  var center = current.center;\n  var x, y;\n\n  if (center.x < next.left) {\n    x = 0;\n  } else if (center.x <= next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  if (center.y < next.top) {\n    y = 0;\n  } else if (center.y <= next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar calcNextExtendedGridPosition = function calcNextExtendedGridPosition(current, next) {\n  var x, y;\n\n  if (current.right <= next.left) {\n    x = 0;\n  } else if (current.left < next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  if (current.bottom <= next.top) {\n    y = 0;\n  } else if (current.top < next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nfunction prioritize(priorities, targetEdge) {\n  var destGroup = [];\n\n  for (var index = 0; index < priorities.length; index++) {\n    var destPriority = priorities[index];\n\n    if (destPriority.group.length) {\n      (function () {\n        var destDistance = destPriority.distance;\n        var destDifference = destPriority.difference;\n        var distance = 0;\n        var target = void 0;\n        destPriority.group.sort(function (a, b) {\n          for (var i = 0; i < destDistance.length; i++) {\n            var calcDistance = destDistance[i];\n            var delta = calcDistance(a) - calcDistance(b);\n\n            if (delta) {\n              return delta;\n            }\n          }\n\n          return 0;\n        });\n        target = destPriority.group[0];\n\n        for (var i = 0; i < destDifference.length; i++) {\n          distance += destDifference[i](target);\n        }\n\n        destGroup.push({\n          distance: Math.pow(destPriority.multiplier * (distance || destPriority.minDistance) / targetEdge, 2) + targetEdge,\n          target: target\n        });\n      })();\n    }\n  }\n\n  if (!destGroup.length) {\n    return null;\n  }\n\n  destGroup.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return destGroup;\n}\n\nfunction partition(rects, targetRect, straightOverlapThreshold, getGroupId) {\n  // a matrix of elements where the center of the element in relation to targetRect is:\n  var groups = [[\n    /* [0] => above/left */\n  ], [\n    /* [1] => above/within */\n  ], [\n    /* [2] => above/right */\n  ], [\n    /* [3] => within/left */\n  ], [\n    /* [4] => within */\n  ], [\n    /* [5] => within/right */\n  ], [\n    /* [6] => below/left */\n  ], [\n    /* [7] => below and within */\n  ], [\n    /* [8] => below/right */\n  ]];\n\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    var groupId = getGroupId(rect, targetRect);\n    groups[groupId].push(rect);\n\n    if ([0, 2, 6, 8].indexOf(groupId) !== -1) {\n      if (rect.left <= targetRect.right - targetRect.width * straightOverlapThreshold) {\n        if (groupId === 2) {\n          groups[1].push(rect);\n        } else if (groupId === 8) {\n          groups[7].push(rect);\n        }\n      }\n\n      if (rect.right >= targetRect.left + targetRect.width * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[1].push(rect);\n        } else if (groupId === 6) {\n          groups[7].push(rect);\n        }\n      }\n\n      if (rect.top <= targetRect.bottom - targetRect.height * straightOverlapThreshold) {\n        if (groupId === 6) {\n          groups[3].push(rect);\n        } else if (groupId === 8) {\n          groups[5].push(rect);\n        }\n      }\n\n      if (rect.bottom >= targetRect.top + targetRect.height * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[3].push(rect);\n        } else if (groupId === 2) {\n          groups[5].push(rect);\n        }\n      }\n    }\n  }\n\n  return groups;\n}\n\nfunction generateDistancefunction(targetRect) {\n  return {\n    nearPlumbLineIsBetter: function nearPlumbLineIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.center.x - rect.right;\n      } else {\n        d = rect.left - targetRect.center.x;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearHorizonIsBetter: function nearHorizonIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.center.y - rect.bottom;\n      } else {\n        d = rect.top - targetRect.center.y;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetBottomIsBetter: function nearTargetBottomIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.bottom - rect.top;\n      } else {\n        d = rect.top - targetRect.bottom;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetLeftIsBetter: function nearTargetLeftIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.left - rect.right;\n      } else {\n        d = rect.left - targetRect.left;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetRightIsBetter: function nearTargetRightIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.right - rect.left;\n      } else {\n        d = rect.left - targetRect.right;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetTopIsBetter: function nearTargetTopIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.top - rect.bottom;\n      } else {\n        d = rect.top - targetRect.top;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    topIsBetter: function topIsBetter(rect) {\n      return rect.top;\n    },\n    bottomIsBetter: function bottomIsBetter(rect) {\n      return -1 * rect.bottom;\n    },\n    leftIsBetter: function leftIsBetter(rect) {\n      return rect.left;\n    },\n    rightIsBetter: function rightIsBetter(rect) {\n      return -1 * rect.right;\n    }\n  };\n}\n\nfunction navigate(targetRect, direction, rects, config) {\n  if (!targetRect || !direction || !rects || !rects.length || !config) {\n    return null;\n  }\n\n  var distanceFunction = generateDistancefunction(targetRect);\n  var obliqueMultiplier = config.obliqueMultiplier,\n      straightMultiplier = config.straightMultiplier,\n      straightOnly = config.straightOnly,\n      straightOverlapThreshold = config.straightOverlapThreshold;\n  var groups = partition(rects, targetRect, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(direction === 'up' || direction === 'down' ? calcNextExtendedGridPosition(rect, destRect) : calcNextGridPosition(rect, destRect));\n  });\n  var internalGroups = partition(groups[4], targetRect.center, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(calcNextGridPosition(rect, destRect));\n  });\n  var priorities, targetEdge;\n\n  switch (direction) {\n    case 'left':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[3]).concat(internalGroups[6]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[3],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'right':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[2].concat(internalGroups[5]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[5],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'up':\n      targetEdge = 'top';\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[1]).concat(internalGroups[2]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[1],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'down':\n      targetEdge = 'bottom';\n      priorities = [{\n        group: internalGroups[6].concat(internalGroups[7]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[7],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    default:\n      return null;\n  }\n\n  if (straightOnly) {\n    priorities.splice(2, 2);\n  }\n\n  var destGroup = prioritize(priorities, targetRect[targetEdge]);\n\n  if (!destGroup) {\n    return null;\n  }\n\n  return destGroup[0].target.element;\n}\n\nvar _default = navigate;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteApp\\node_modules\\@enact\\spotlight\\src\\navigate.js"],"names":["Object","defineProperty","exports","value","navigate","obliqueMinDistance","straightMinDistance","calcGroupId","_ref","x","y","calcNextGridPosition","current","next","center","left","right","top","bottom","calcNextExtendedGridPosition","prioritize","priorities","targetEdge","destGroup","index","length","destPriority","group","destDistance","distance","destDifference","difference","target","sort","a","b","i","calcDistance","delta","push","Math","pow","multiplier","minDistance","partition","rects","targetRect","straightOverlapThreshold","getGroupId","groups","rect","groupId","indexOf","width","height","generateDistancefunction","nearPlumbLineIsBetter","d","nearHorizonIsBetter","nearTargetBottomIsBetter","nearTargetLeftIsBetter","nearTargetRightIsBetter","nearTargetTopIsBetter","topIsBetter","bottomIsBetter","leftIsBetter","rightIsBetter","direction","config","distanceFunction","obliqueMultiplier","straightMultiplier","straightOnly","destRect","internalGroups","concat","splice","element","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.navigate = navigate;\nexports[\"default\"] = void 0;\nvar obliqueMinDistance = 1;\nvar straightMinDistance = 0;\n\nvar calcGroupId = function calcGroupId(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  return y * 3 + x;\n};\n\nvar calcNextGridPosition = function calcNextGridPosition(current, next) {\n  var center = current.center;\n  var x, y;\n\n  if (center.x < next.left) {\n    x = 0;\n  } else if (center.x <= next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  if (center.y < next.top) {\n    y = 0;\n  } else if (center.y <= next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar calcNextExtendedGridPosition = function calcNextExtendedGridPosition(current, next) {\n  var x, y;\n\n  if (current.right <= next.left) {\n    x = 0;\n  } else if (current.left < next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n\n  if (current.bottom <= next.top) {\n    y = 0;\n  } else if (current.top < next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nfunction prioritize(priorities, targetEdge) {\n  var destGroup = [];\n\n  for (var index = 0; index < priorities.length; index++) {\n    var destPriority = priorities[index];\n\n    if (destPriority.group.length) {\n      (function () {\n        var destDistance = destPriority.distance;\n        var destDifference = destPriority.difference;\n        var distance = 0;\n        var target = void 0;\n        destPriority.group.sort(function (a, b) {\n          for (var i = 0; i < destDistance.length; i++) {\n            var calcDistance = destDistance[i];\n            var delta = calcDistance(a) - calcDistance(b);\n\n            if (delta) {\n              return delta;\n            }\n          }\n\n          return 0;\n        });\n        target = destPriority.group[0];\n\n        for (var i = 0; i < destDifference.length; i++) {\n          distance += destDifference[i](target);\n        }\n\n        destGroup.push({\n          distance: Math.pow(destPriority.multiplier * (distance || destPriority.minDistance) / targetEdge, 2) + targetEdge,\n          target: target\n        });\n      })();\n    }\n  }\n\n  if (!destGroup.length) {\n    return null;\n  }\n\n  destGroup.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return destGroup;\n}\n\nfunction partition(rects, targetRect, straightOverlapThreshold, getGroupId) {\n  // a matrix of elements where the center of the element in relation to targetRect is:\n  var groups = [[\n    /* [0] => above/left */\n  ], [\n    /* [1] => above/within */\n  ], [\n    /* [2] => above/right */\n  ], [\n    /* [3] => within/left */\n  ], [\n    /* [4] => within */\n  ], [\n    /* [5] => within/right */\n  ], [\n    /* [6] => below/left */\n  ], [\n    /* [7] => below and within */\n  ], [\n    /* [8] => below/right */\n  ]];\n\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    var groupId = getGroupId(rect, targetRect);\n    groups[groupId].push(rect);\n\n    if ([0, 2, 6, 8].indexOf(groupId) !== -1) {\n      if (rect.left <= targetRect.right - targetRect.width * straightOverlapThreshold) {\n        if (groupId === 2) {\n          groups[1].push(rect);\n        } else if (groupId === 8) {\n          groups[7].push(rect);\n        }\n      }\n\n      if (rect.right >= targetRect.left + targetRect.width * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[1].push(rect);\n        } else if (groupId === 6) {\n          groups[7].push(rect);\n        }\n      }\n\n      if (rect.top <= targetRect.bottom - targetRect.height * straightOverlapThreshold) {\n        if (groupId === 6) {\n          groups[3].push(rect);\n        } else if (groupId === 8) {\n          groups[5].push(rect);\n        }\n      }\n\n      if (rect.bottom >= targetRect.top + targetRect.height * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[3].push(rect);\n        } else if (groupId === 2) {\n          groups[5].push(rect);\n        }\n      }\n    }\n  }\n\n  return groups;\n}\n\nfunction generateDistancefunction(targetRect) {\n  return {\n    nearPlumbLineIsBetter: function nearPlumbLineIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.center.x - rect.right;\n      } else {\n        d = rect.left - targetRect.center.x;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearHorizonIsBetter: function nearHorizonIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.center.y - rect.bottom;\n      } else {\n        d = rect.top - targetRect.center.y;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetBottomIsBetter: function nearTargetBottomIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.bottom - rect.top;\n      } else {\n        d = rect.top - targetRect.bottom;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetLeftIsBetter: function nearTargetLeftIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.left - rect.right;\n      } else {\n        d = rect.left - targetRect.left;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetRightIsBetter: function nearTargetRightIsBetter(rect) {\n      var d;\n\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.right - rect.left;\n      } else {\n        d = rect.left - targetRect.right;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    nearTargetTopIsBetter: function nearTargetTopIsBetter(rect) {\n      var d;\n\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.top - rect.bottom;\n      } else {\n        d = rect.top - targetRect.top;\n      }\n\n      return d < 0 ? 0 : d;\n    },\n    topIsBetter: function topIsBetter(rect) {\n      return rect.top;\n    },\n    bottomIsBetter: function bottomIsBetter(rect) {\n      return -1 * rect.bottom;\n    },\n    leftIsBetter: function leftIsBetter(rect) {\n      return rect.left;\n    },\n    rightIsBetter: function rightIsBetter(rect) {\n      return -1 * rect.right;\n    }\n  };\n}\n\nfunction navigate(targetRect, direction, rects, config) {\n  if (!targetRect || !direction || !rects || !rects.length || !config) {\n    return null;\n  }\n\n  var distanceFunction = generateDistancefunction(targetRect);\n  var obliqueMultiplier = config.obliqueMultiplier,\n      straightMultiplier = config.straightMultiplier,\n      straightOnly = config.straightOnly,\n      straightOverlapThreshold = config.straightOverlapThreshold;\n  var groups = partition(rects, targetRect, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(direction === 'up' || direction === 'down' ? calcNextExtendedGridPosition(rect, destRect) : calcNextGridPosition(rect, destRect));\n  });\n  var internalGroups = partition(groups[4], targetRect.center, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(calcNextGridPosition(rect, destRect));\n  });\n  var priorities, targetEdge;\n\n  switch (direction) {\n    case 'left':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[3]).concat(internalGroups[6]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[3],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'right':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[2].concat(internalGroups[5]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[5],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'up':\n      targetEdge = 'top';\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[1]).concat(internalGroups[2]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[1],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    case 'down':\n      targetEdge = 'bottom';\n      priorities = [{\n        group: internalGroups[6].concat(internalGroups[7]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[7],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n\n    default:\n      return null;\n  }\n\n  if (straightOnly) {\n    priorities.splice(2, 2);\n  }\n\n  var destGroup = prioritize(priorities, targetRect[targetEdge]);\n\n  if (!destGroup) {\n    return null;\n  }\n\n  return destGroup[0].target.element;\n}\n\nvar _default = navigate;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}