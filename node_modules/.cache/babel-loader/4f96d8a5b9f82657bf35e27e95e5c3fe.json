{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClickAllow = exports[\"default\"] = void 0;\n\nvar _platform = require(\"@enact/core/platform\");\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // It's possible that emitting `onTap` will cause a DOM change before the mousedown fires resulting\n// in multiple tap/click events for the same user action. To avoid this, we store the last touchend\n// target and timestamp to compare against the next mouse down. If the timestamp is different (e.g\n// we're on a hybrid device that emitted a touch event but the next was a mouse event) or the target\n// is the same (or no previous target was set if no touch events have been emitted), we allow the\n// mousedown *across Touchable instances*.\n\n\nvar _lastTouchEnd = {\n  target: null,\n  timeStamp: 0\n};\n\nvar shouldAllowMouseDown = function shouldAllowMouseDown(ev) {\n  return ev.timeStamp !== _lastTouchEnd.timeStamp || ev.target === _lastTouchEnd.target || _lastTouchEnd.target === null;\n};\n\nvar ClickAllow =\n/*#__PURE__*/\nfunction () {\n  function ClickAllow() {\n    _classCallCheck(this, ClickAllow);\n\n    this.lastTouchEndTime = 0;\n    this.lastMouseUpTime = 0;\n  }\n\n  _createClass(ClickAllow, [{\n    key: \"setLastTouchEnd\",\n    value: function setLastTouchEnd(ev) {\n      if (ev && ev.type === 'touchend') {\n        this.lastTouchEndTime = ev.timeStamp;\n        _lastTouchEnd.timeStamp = ev.timeStamp;\n        _lastTouchEnd.target = ev.target;\n      }\n    }\n  }, {\n    key: \"setLastMouseUp\",\n    value: function setLastMouseUp(ev) {\n      if (ev && ev.type === 'mouseup') {\n        this.lastMouseUpTime = ev.timeStamp;\n      }\n    }\n  }, {\n    key: \"shouldAllowMouseEvent\",\n    value: function shouldAllowMouseEvent(ev) {\n      var timeStamp = ev.timeStamp; // iOS Safari sends both touch and mouse events (with differing timestamps)\n\n      return !_platform.platform.ios && this.lastTouchEndTime !== timeStamp && shouldAllowMouseDown(ev);\n    }\n  }, {\n    key: \"shouldAllowTap\",\n    value: function shouldAllowTap(ev) {\n      var type = ev.type,\n          timeStamp = ev.timeStamp; // Allow the custom tap event for a “click” when it’s actually a click and it’s not from the\n      // last mouseup event which would have fired the click for us\n\n      return type === 'click' && this.lastMouseUpTime !== timeStamp;\n    }\n  }]);\n\n  return ClickAllow;\n}();\n\nexports.ClickAllow = ClickAllow;\nvar _default = ClickAllow;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/cdi/SteApp/node_modules/@enact/ui/Touchable/ClickAllow.js"],"names":["Object","defineProperty","exports","value","ClickAllow","_platform","require","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","_createClass","protoProps","staticProps","prototype","_lastTouchEnd","timeStamp","shouldAllowMouseDown","ev","lastTouchEndTime","lastMouseUpTime","setLastTouchEnd","type","setLastMouseUp","shouldAllowMouseEvent","platform","ios","shouldAllowTap","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClickAllow = exports[\"default\"] = void 0;\n\nvar _platform = require(\"@enact/core/platform\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// It's possible that emitting `onTap` will cause a DOM change before the mousedown fires resulting\n// in multiple tap/click events for the same user action. To avoid this, we store the last touchend\n// target and timestamp to compare against the next mouse down. If the timestamp is different (e.g\n// we're on a hybrid device that emitted a touch event but the next was a mouse event) or the target\n// is the same (or no previous target was set if no touch events have been emitted), we allow the\n// mousedown *across Touchable instances*.\nvar _lastTouchEnd = {\n  target: null,\n  timeStamp: 0\n};\n\nvar shouldAllowMouseDown = function shouldAllowMouseDown(ev) {\n  return ev.timeStamp !== _lastTouchEnd.timeStamp || ev.target === _lastTouchEnd.target || _lastTouchEnd.target === null;\n};\n\nvar ClickAllow =\n/*#__PURE__*/\nfunction () {\n  function ClickAllow() {\n    _classCallCheck(this, ClickAllow);\n\n    this.lastTouchEndTime = 0;\n    this.lastMouseUpTime = 0;\n  }\n\n  _createClass(ClickAllow, [{\n    key: \"setLastTouchEnd\",\n    value: function setLastTouchEnd(ev) {\n      if (ev && ev.type === 'touchend') {\n        this.lastTouchEndTime = ev.timeStamp;\n        _lastTouchEnd.timeStamp = ev.timeStamp;\n        _lastTouchEnd.target = ev.target;\n      }\n    }\n  }, {\n    key: \"setLastMouseUp\",\n    value: function setLastMouseUp(ev) {\n      if (ev && ev.type === 'mouseup') {\n        this.lastMouseUpTime = ev.timeStamp;\n      }\n    }\n  }, {\n    key: \"shouldAllowMouseEvent\",\n    value: function shouldAllowMouseEvent(ev) {\n      var timeStamp = ev.timeStamp; // iOS Safari sends both touch and mouse events (with differing timestamps)\n\n      return !_platform.platform.ios && this.lastTouchEndTime !== timeStamp && shouldAllowMouseDown(ev);\n    }\n  }, {\n    key: \"shouldAllowTap\",\n    value: function shouldAllowTap(ev) {\n      var type = ev.type,\n          timeStamp = ev.timeStamp; // Allow the custom tap event for a “click” when it’s actually a click and it’s not from the\n      // last mouseup event which would have fired the click for us\n\n      return type === 'click' && this.lastMouseUpTime !== timeStamp;\n    }\n  }]);\n\n  return ClickAllow;\n}();\n\nexports.ClickAllow = ClickAllow;\nvar _default = ClickAllow;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}