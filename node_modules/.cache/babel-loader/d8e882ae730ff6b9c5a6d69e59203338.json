{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Job\", {\n  enumerable: true,\n  get: function get() {\n    return _Job[\"default\"];\n  }\n});\nexports.perfNow = exports.mergeClassNameMaps = exports.memoize = exports.isRenderable = exports.extractAriaProps = exports.coerceFunction = exports.coerceArray = exports.cap = void 0;\n\nvar _always = _interopRequireDefault(require(\"ramda/src/always\"));\n\nvar _is = _interopRequireDefault(require(\"ramda/src/is\"));\n\nvar _unless = _interopRequireDefault(require(\"ramda/src/unless\"));\n\nvar ReactIs = _interopRequireWildcard(require(\"react-is\"));\n\nvar _Job = _interopRequireDefault(require(\"./Job\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n/**\n * Capitalizes a given string (not locale-aware).\n *\n * @function\n * @param   {String}    str   The string to capitalize.\n *\n * @returns {String}          The capitalized string.\n * @memberof core/util\n * @public\n */\n\n\nvar cap = function cap(str) {\n  return str.slice(0, 1).toUpperCase() + str.slice(1);\n};\n/**\n * If `arg` is a function, return it. Otherwise returns a function that returns `arg`.\n *\n * Example:\n * ```\n *\tconst returnsZero = coerceFunction(0);\n *\tconst returnsArg = coerceFunction(() => 0);\n * ```\n * @function\n * @param {*}    arg    Function or value\n *\n * @returns {Function}  Either `arg` if `arg` is a function, or a function that returns `arg`\n * @memberof core/util\n * @public\n */\n\n\nexports.cap = cap;\nvar coerceFunction = (0, _unless[\"default\"])((0, _is[\"default\"])(Function), _always[\"default\"]);\n/**\n * If `arg` is array-like, return it. Otherwise returns a single element array containing `arg`.\n *\n * Example:\n * ```\n *\tconst returnsArray = coerceArray(0); // [0]\n *\tconst returnsArg = coerceArray([0]); // [0]\n *\tconst returnsObjArg = coerceArray({0: 'zeroth', length: 1});\n * ```\n * @see http://ramdajs.com/docs/#isArrayLike\n * @function\n * @param {*}    array    Array or value\n *\n * @returns {Array}       Either `array` or `[array]`\n * @memberof core/util\n * @public\n */\n\nexports.coerceFunction = coerceFunction;\n\nvar coerceArray = function coerceArray(array) {\n  return Array.isArray(array) ? array : [array];\n};\n/**\n * Loosely determines if `tag` is a renderable component (either a string or a function).\n *\n * @function\n * @param {*}    tag    Component to test\n *\n * @returns {Boolean}   `true` if `tag` is either a string or a function\n * @memberof core/util\n * @public\n */\n\n\nexports.coerceArray = coerceArray;\n\nvar isRenderable = function isRenderable(tag) {\n  return ReactIs.isValidElementType(tag);\n};\n/**\n * Removes ARIA-related props from `props` and returns them in a new object.\n *\n * Specifically, it removes the `role` prop and any prop prefixed with `aria-`. This is useful when\n * redirecting ARIA-related props from a non-focusable root element to a focusable child element.\n *\n * @function\n * @param   {Object}    props    Props object\n *\n * @returns {Object}             ARIA-related props\n * @memberof core/util\n * @public\n */\n\n\nexports.isRenderable = isRenderable;\n\nvar extractAriaProps = function extractAriaProps(props) {\n  var aria = {};\n  Object.keys(props).forEach(function (key) {\n    if (key === 'role' || key.indexOf('aria-') === 0) {\n      aria[key] = props[key];\n      delete props[key];\n    }\n  });\n  return aria;\n};\n/**\n * Gets the current timestamp of either `window.performance.now` or `Date.now`\n *\n * @function\n *\n * @returns {Number}                    The timestamp from `window.performance.now` or `Date.now`\n * @memberof core/util\n * @public\n */\n\n\nexports.extractAriaProps = extractAriaProps;\n\nvar perfNow = function perfNow() {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n    return window.performance.now();\n  } else {\n    return Date.now();\n  }\n};\n/**\n * Merges two class name maps into one.\n *\n * The resulting map will only contain the class names defined in the `baseMap` and will be appended\n * with the value from `additiveMap` if it exists. Further, `allowedClassNames` may optionally limit\n * which keys will be merged from `additiveMap` into `baseMap`.\n *\n * Example:\n * ```\n * // merges all matching class names from additiveMap1 with baseMap1\n * const newMap1 = mergeClassNameMaps(baseMap1, additiveMap1);\n *\n * // merge only 'a' and 'b' class names from additiveMap2 with baseMap2\n * const newMap2 = mergeClassNameMaps(baseMap2, additiveMap2, ['a', 'b']);\n * ```\n *\n * @function\n * @param {Object}     baseMap             The source mapping of logical class name to physical\n *                                         class name\n * @param {Object}     additiveMap         Mapping of logical to physical class names which are\n *                                         concatenated with `baseMap` where the logical names match\n * @param {String[]}  [allowedClassNames]  Array of logical class names that can be augmented. When\n *                                         set, the logical class name must exist in `baseMap`,\n *                                         `additiveMap`, and this array to be concatenated.\n *\n * @returns {Object}                       The merged class name map.\n * @memberof core/util\n * @public\n */\n\n\nexports.perfNow = perfNow;\n\nvar mergeClassNameMaps = function mergeClassNameMaps(baseMap, additiveMap, allowedClassNames) {\n  var css = baseMap;\n\n  if (baseMap && additiveMap) {\n    allowedClassNames = allowedClassNames || Object.keys(additiveMap); // if the props includes a css map, merge them together now\n\n    css = Object.assign({}, baseMap);\n    allowedClassNames.forEach(function (key) {\n      if (baseMap[key] && additiveMap[key]) {\n        css[key] = baseMap[key] + ' ' + additiveMap[key];\n      }\n    });\n  }\n\n  return css;\n};\n/**\n * Creates a function that memoizes the result of `fn`.\n *\n * Note that this function is a naive implementation and only checks the first argument for\n * memoization.\n *\n * @function\n * @param {Function}    fn    The function to have its output memoized.\n *\n * @returns {Function}        The new memoized function.\n * @memberof core/util\n * @public\n */\n\n\nexports.mergeClassNameMaps = mergeClassNameMaps;\n\nvar memoize = function memoize(fn) {\n  var cache = {};\n  return function () {\n    var n = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (n in cache) {\n      return cache[n];\n    } else {\n      var result = fn.apply(void 0, arguments);\n      cache[n] = result;\n      return result;\n    }\n  };\n};\n\nexports.memoize = memoize;","map":{"version":3,"sources":["/home/cdi/final/SteApp/node_modules/@enact/core/util/util.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_Job","perfNow","mergeClassNameMaps","memoize","isRenderable","extractAriaProps","coerceFunction","coerceArray","cap","_always","_interopRequireDefault","require","_is","_unless","ReactIs","_interopRequireWildcard","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","set","_typeof","Symbol","iterator","constructor","str","slice","toUpperCase","Function","array","Array","isArray","tag","isValidElementType","props","aria","keys","forEach","indexOf","window","performance","now","Date","baseMap","additiveMap","allowedClassNames","css","assign","fn","cache","n","arguments","length","undefined","result","apply"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Job\", {\n  enumerable: true,\n  get: function get() {\n    return _Job[\"default\"];\n  }\n});\nexports.perfNow = exports.mergeClassNameMaps = exports.memoize = exports.isRenderable = exports.extractAriaProps = exports.coerceFunction = exports.coerceArray = exports.cap = void 0;\n\nvar _always = _interopRequireDefault(require(\"ramda/src/always\"));\n\nvar _is = _interopRequireDefault(require(\"ramda/src/is\"));\n\nvar _unless = _interopRequireDefault(require(\"ramda/src/unless\"));\n\nvar ReactIs = _interopRequireWildcard(require(\"react-is\"));\n\nvar _Job = _interopRequireDefault(require(\"./Job\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Capitalizes a given string (not locale-aware).\n *\n * @function\n * @param   {String}    str   The string to capitalize.\n *\n * @returns {String}          The capitalized string.\n * @memberof core/util\n * @public\n */\nvar cap = function cap(str) {\n  return str.slice(0, 1).toUpperCase() + str.slice(1);\n};\n/**\n * If `arg` is a function, return it. Otherwise returns a function that returns `arg`.\n *\n * Example:\n * ```\n *\tconst returnsZero = coerceFunction(0);\n *\tconst returnsArg = coerceFunction(() => 0);\n * ```\n * @function\n * @param {*}    arg    Function or value\n *\n * @returns {Function}  Either `arg` if `arg` is a function, or a function that returns `arg`\n * @memberof core/util\n * @public\n */\n\n\nexports.cap = cap;\nvar coerceFunction = (0, _unless[\"default\"])((0, _is[\"default\"])(Function), _always[\"default\"]);\n/**\n * If `arg` is array-like, return it. Otherwise returns a single element array containing `arg`.\n *\n * Example:\n * ```\n *\tconst returnsArray = coerceArray(0); // [0]\n *\tconst returnsArg = coerceArray([0]); // [0]\n *\tconst returnsObjArg = coerceArray({0: 'zeroth', length: 1});\n * ```\n * @see http://ramdajs.com/docs/#isArrayLike\n * @function\n * @param {*}    array    Array or value\n *\n * @returns {Array}       Either `array` or `[array]`\n * @memberof core/util\n * @public\n */\n\nexports.coerceFunction = coerceFunction;\n\nvar coerceArray = function coerceArray(array) {\n  return Array.isArray(array) ? array : [array];\n};\n/**\n * Loosely determines if `tag` is a renderable component (either a string or a function).\n *\n * @function\n * @param {*}    tag    Component to test\n *\n * @returns {Boolean}   `true` if `tag` is either a string or a function\n * @memberof core/util\n * @public\n */\n\n\nexports.coerceArray = coerceArray;\n\nvar isRenderable = function isRenderable(tag) {\n  return ReactIs.isValidElementType(tag);\n};\n/**\n * Removes ARIA-related props from `props` and returns them in a new object.\n *\n * Specifically, it removes the `role` prop and any prop prefixed with `aria-`. This is useful when\n * redirecting ARIA-related props from a non-focusable root element to a focusable child element.\n *\n * @function\n * @param   {Object}    props    Props object\n *\n * @returns {Object}             ARIA-related props\n * @memberof core/util\n * @public\n */\n\n\nexports.isRenderable = isRenderable;\n\nvar extractAriaProps = function extractAriaProps(props) {\n  var aria = {};\n  Object.keys(props).forEach(function (key) {\n    if (key === 'role' || key.indexOf('aria-') === 0) {\n      aria[key] = props[key];\n      delete props[key];\n    }\n  });\n  return aria;\n};\n/**\n * Gets the current timestamp of either `window.performance.now` or `Date.now`\n *\n * @function\n *\n * @returns {Number}                    The timestamp from `window.performance.now` or `Date.now`\n * @memberof core/util\n * @public\n */\n\n\nexports.extractAriaProps = extractAriaProps;\n\nvar perfNow = function perfNow() {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n    return window.performance.now();\n  } else {\n    return Date.now();\n  }\n};\n/**\n * Merges two class name maps into one.\n *\n * The resulting map will only contain the class names defined in the `baseMap` and will be appended\n * with the value from `additiveMap` if it exists. Further, `allowedClassNames` may optionally limit\n * which keys will be merged from `additiveMap` into `baseMap`.\n *\n * Example:\n * ```\n * // merges all matching class names from additiveMap1 with baseMap1\n * const newMap1 = mergeClassNameMaps(baseMap1, additiveMap1);\n *\n * // merge only 'a' and 'b' class names from additiveMap2 with baseMap2\n * const newMap2 = mergeClassNameMaps(baseMap2, additiveMap2, ['a', 'b']);\n * ```\n *\n * @function\n * @param {Object}     baseMap             The source mapping of logical class name to physical\n *                                         class name\n * @param {Object}     additiveMap         Mapping of logical to physical class names which are\n *                                         concatenated with `baseMap` where the logical names match\n * @param {String[]}  [allowedClassNames]  Array of logical class names that can be augmented. When\n *                                         set, the logical class name must exist in `baseMap`,\n *                                         `additiveMap`, and this array to be concatenated.\n *\n * @returns {Object}                       The merged class name map.\n * @memberof core/util\n * @public\n */\n\n\nexports.perfNow = perfNow;\n\nvar mergeClassNameMaps = function mergeClassNameMaps(baseMap, additiveMap, allowedClassNames) {\n  var css = baseMap;\n\n  if (baseMap && additiveMap) {\n    allowedClassNames = allowedClassNames || Object.keys(additiveMap); // if the props includes a css map, merge them together now\n\n    css = Object.assign({}, baseMap);\n    allowedClassNames.forEach(function (key) {\n      if (baseMap[key] && additiveMap[key]) {\n        css[key] = baseMap[key] + ' ' + additiveMap[key];\n      }\n    });\n  }\n\n  return css;\n};\n/**\n * Creates a function that memoizes the result of `fn`.\n *\n * Note that this function is a naive implementation and only checks the first argument for\n * memoization.\n *\n * @function\n * @param {Function}    fn    The function to have its output memoized.\n *\n * @returns {Function}        The new memoized function.\n * @memberof core/util\n * @public\n */\n\n\nexports.mergeClassNameMaps = mergeClassNameMaps;\n\nvar memoize = function memoize(fn) {\n  var cache = {};\n  return function () {\n    var n = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (n in cache) {\n      return cache[n];\n    } else {\n      var result = fn.apply(void 0, arguments);\n      cache[n] = result;\n      return result;\n    }\n  };\n};\n\nexports.memoize = memoize;"]},"metadata":{},"sourceType":"module"}