{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _container = require(\"./container\");\n\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    } // only verify selector for the first (immediate ancestor) container\n\n\n    verifySelector = false;\n  }\n\n  return true;\n}\n\nfunction getContainersToSearch(containerId) {\n  var range = [];\n\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n\n  return range;\n}\n\nfunction getTargetByContainer(containerId) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id);\n  }, null);\n}\n\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n\n  var next = (0, _utils.parseSelector)(selector)[0];\n\n  if (next) {\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n\n  return null;\n}\n\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\n\nfunction getSpottableDescendantsWithoutContainers(containerId, containerIds) {\n  return (0, _container.getSpottableDescendants)(containerId).filter(function (n) {\n    return !(0, _container.isContainer)(n) || containerIds.indexOf(n.dataset.spotlightId) === -1;\n  });\n}\n\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  } // remove elements that are outside of boundingRect, if specified\n\n\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread({}, rect, {\n        center: _objectSpread({}, rect.center)\n      });\n\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n\n      return updated;\n    }\n\n    return rect;\n  });\n}\n\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  }); // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n\n  return false;\n}\n\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\n\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from position to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  _loop: while (elementRects.length > 0) {\n    var _ret = _loop2();\n\n    switch (_ret) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop;\n    }\n  }\n\n  return next;\n}\n\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds); // shortcut for previous target from element if it were saved\n\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n\n\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop4 = function _loop4() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from element to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container,\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next; // and it is restricted, return its target\n\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  _loop3: while (elementRects.length > 0) {\n    var _ret2 = _loop4();\n\n    switch (_ret2) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop3;\n    }\n  }\n\n  return next;\n}\n\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n\n  var elementRect = (0, _utils.getRect)(element);\n  return (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n\n      if (result === false) {\n        result = element;\n      }\n    }\n\n    return result;\n  }, null);\n}\n\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\n\n\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n\n      return getTargetBySelector(target);\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n\n  return null;\n}\n\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteApp\\node_modules\\@enact\\spotlight\\src\\target.js"],"names":["Object","defineProperty","exports","value","getNavigableTarget","getTargetByContainer","getTargetByDirectionFromElement","getTargetByDirectionFromPosition","getTargetBySelector","isFocusable","_last","_interopRequireDefault","require","_container","_navigate","_utils","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","prototype","toString","call","Array","from","isArray","arr2","elem","containers","getContainersForNode","verifySelector","containerId","isNavigable","getContainersToSearch","range","addRange","id","config","getContainerConfig","indexOf","selectorDisabled","push","getDefaultContainer","getLastContainer","getAllContainerIds","map","reduce","next","getContainerFocusTarget","selector","charAt","substr","parseSelector","nextContainerIds","isRestrictedContainer","enterTo","getSpottableDescendantsWithoutContainers","containerIds","getSpottableDescendants","n","isContainer","dataset","spotlightId","filterRects","elementRects","boundingRect","rect","element","intersects","contains","center","topUpdate","top","bottomUpdate","bottom","leftUpdate","left","rightUpdate","right","updated","centerX","x","centerY","y","getContainerContainingRect","elementRect","overlapping","getOverflowContainerRect","nextConfig","overflow","getContainerRect","getTargetInContainerByDirectionFromPosition","direction","positionRect","elementContainerIds","elements","getRects","_loop2","overlappingContainerId","nextContainerId","lastNavigated","_loop","_ret","getTargetInContainerByDirectionFromElement","previous","getContainerPreviousTarget","spotlightOverflow","_loop4","_loop3","_ret2","extSelector","getAttribute","getRect","getNavigableContainersForNode","reduceRight","result","index","getLeaveForTarget","position","pointerRect","getPointRect","getContainerNode","restrict","leaveFor","document","parent","parentNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _container = require(\"./container\");\n\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    } // only verify selector for the first (immediate ancestor) container\n\n\n    verifySelector = false;\n  }\n\n  return true;\n}\n\nfunction getContainersToSearch(containerId) {\n  var range = [];\n\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n\n  return range;\n}\n\nfunction getTargetByContainer(containerId) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id);\n  }, null);\n}\n\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n\n  var next = (0, _utils.parseSelector)(selector)[0];\n\n  if (next) {\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n\n  return null;\n}\n\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\n\nfunction getSpottableDescendantsWithoutContainers(containerId, containerIds) {\n  return (0, _container.getSpottableDescendants)(containerId).filter(function (n) {\n    return !(0, _container.isContainer)(n) || containerIds.indexOf(n.dataset.spotlightId) === -1;\n  });\n}\n\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  } // remove elements that are outside of boundingRect, if specified\n\n\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread({}, rect, {\n        center: _objectSpread({}, rect.center)\n      });\n\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n\n      return updated;\n    }\n\n    return rect;\n  });\n}\n\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  }); // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n\n  return false;\n}\n\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\n\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from position to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  _loop: while (elementRects.length > 0) {\n    var _ret = _loop2();\n\n    switch (_ret) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop;\n    }\n  }\n\n  return next;\n}\n\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = getSpottableDescendantsWithoutContainers(containerId, elementContainerIds); // shortcut for previous target from element if it were saved\n\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n\n\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n\n  var _loop4 = function _loop4() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      } // found a target so break out and return\n\n\n      return \"break\";\n    } // try to navigate from element to one of the candidates in containerId\n\n\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container,\n\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary\n\n      var lastNavigated = next; // and it is restricted, return its target\n\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    } // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n\n\n    return \"break\";\n  };\n\n  _loop3: while (elementRects.length > 0) {\n    var _ret2 = _loop4();\n\n    switch (_ret2) {\n      case \"continue\":\n        continue;\n\n      case \"break\":\n        break _loop3;\n    }\n  }\n\n  return next;\n}\n\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n\n  var elementRect = (0, _utils.getRect)(element);\n  return (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n\n      if (result === false) {\n        result = element;\n      }\n    }\n\n    return result;\n  }, null);\n}\n\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\n\n\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n\n      return getTargetBySelector(target);\n    }\n\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n\n  return null;\n}\n\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}"]},"metadata":{},"sourceType":"module"}