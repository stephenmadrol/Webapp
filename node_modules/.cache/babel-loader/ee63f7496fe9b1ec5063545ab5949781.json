{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContainerDefaultElement = getContainerDefaultElement;\nexports.getContainerLastFocusedElement = getContainerLastFocusedElement;\nexports.getContainerNavigableElements = getContainerNavigableElements;\nexports.getContainersForNode = getContainersForNode;\nexports.setContainerLastFocusedElement = setContainerLastFocusedElement;\nexports.getContainerFocusTarget = getContainerFocusTarget;\nexports.getContainerPreviousTarget = getContainerPreviousTarget;\nexports.getDefaultContainer = getDefaultContainer;\nexports.getLastContainer = getLastContainer;\nexports.getNavigableContainersForNode = getNavigableContainersForNode;\nexports.isWithinOverflowContainer = isWithinOverflowContainer;\nexports.mayActivateContainer = mayActivateContainer;\nexports.notifyLeaveContainer = notifyLeaveContainer;\nexports.notifyLeaveContainerFail = notifyLeaveContainerFail;\nexports.notifyEnterContainer = notifyEnterContainer;\nexports.setContainerPreviousTarget = setContainerPreviousTarget;\nexports.setDefaultContainer = setDefaultContainer;\nexports.setLastContainer = setLastContainer;\nexports.setLastContainerFromTarget = setLastContainerFromTarget;\nexports.unmountContainer = unmountContainer;\nexports.rootContainerId = exports.removeContainer = exports.removeAllContainers = exports.isNavigable = exports.isContainer = exports.getSpottableDescendants = exports.configureContainer = exports.configureDefaults = exports.containerAttribute = exports.addContainer = exports.isContainer5WayHoldable = exports.getContainerConfig = exports.getContainerNode = exports.getAllContainerIds = void 0;\n\nvar _and = _interopRequireDefault(require(\"ramda/src/and\"));\n\nvar _concat = _interopRequireDefault(require(\"ramda/src/concat\"));\n\nvar _util = require(\"@enact/core/util\");\n\nvar _intersection = _interopRequireDefault(require(\"ramda/src/intersection\"));\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar containerAttribute = 'data-spotlight-id';\nexports.containerAttribute = containerAttribute;\nvar containerConfigs = new Map();\nvar containerKey = 'spotlightId';\nvar disabledKey = 'spotlightContainerDisabled';\nvar containerPrefix = 'container-';\nvar containerSelector = '[data-spotlight-container]';\nvar rootContainerId = 'spotlightRootDecorator';\nexports.rootContainerId = rootContainerId;\nvar reverseDirections = {\n  'left': 'right',\n  'up': 'down',\n  'right': 'left',\n  'down': 'up'\n}; // Incrementer for container IDs\n\nvar _ids = 0;\nvar _defaultContainerId = '';\nvar _lastContainerId = ''; // Note: an <extSelector> can be one of following types:\n// - a valid selector string for \"querySelectorAll\"\n// - a NodeList or an array containing DOM elements\n// - a single DOM element\n// - a string \"@<containerId>\" to indicate the specified container\n// - a string \"@\" to indicate the default container\n\nvar GlobalConfig = {\n  // set to false for unmounted containers to omit them from searches\n  active: true,\n  continue5WayHold: false,\n  defaultElement: '',\n  // <extSelector> except \"@\" syntax.\n  enterTo: '',\n  // '', 'last-focused', 'default-element'\n  lastFocusedElement: null,\n  lastFocusedKey: null,\n  lastFocusedPersist: function lastFocusedPersist(node, all) {\n    var container = typeof node === 'string';\n    return {\n      container: container,\n      element: !container,\n      key: container ? node : all.indexOf(node)\n    };\n  },\n  lastFocusedRestore: function lastFocusedRestore(_ref, all) {\n    var container = _ref.container,\n        key = _ref.key;\n    return container ? key : all[key];\n  },\n  leaveFor: null,\n  // {left: <extSelector>, right: <extSelector>, up: <extSelector>, down: <extSelector>}\n  navigableFilter: null,\n  obliqueMultiplier: 5,\n  onEnterContainer: null,\n  // @private - notify the container when entering via 5-way\n  onLeaveContainer: null,\n  // @private - notify the container when leaving via 5-way\n  onLeaveContainerFail: null,\n  // @private - notify the container when failing to leave via 5-way\n  overflow: false,\n  rememberSource: false,\n  restrict: 'self-first',\n  // 'self-first', 'self-only', 'none'\n  selector: '',\n  // can be a valid <extSelector> except \"@\" syntax.\n  selectorDisabled: false,\n  straightMultiplier: 1,\n  straightOnly: false,\n  straightOverlapThreshold: 0.5,\n  tabIndexIgnoreList: 'a, input, select, textarea, button, iframe, [contentEditable=true]'\n};\n/**\n * Calculates nodes within `node` that match `includeSelector` and do not match `excludeSelector`\n *\n * @param   {Node}    node             DOM Node to query\n * @param   {String}  includeSelector  CSS selector of nodes to include\n * @param   {String}  excludeSelector  CSS selector for nodes to exclude\n *\n * @returns {Node[]}                   Array of nodes\n * @memberof spotlight/container\n * @private\n */\n\nvar querySelector = function querySelector(node, includeSelector, excludeSelector) {\n  var include = Array.prototype.slice.call(node.querySelectorAll(includeSelector));\n  var exclude = node.querySelectorAll(excludeSelector);\n\n  for (var i = 0; i < exclude.length; i++) {\n    var index = include.indexOf(exclude.item(i));\n\n    if (index >= 0) {\n      include.splice(index, 1);\n    }\n  }\n\n  return include;\n};\n/**\n * Determines if `node` is a spotlight container\n *\n * @param   {Node}     node   Node to check\n *\n * @returns {Boolean}        `true` if `node` is a spotlight container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar isContainerNode = function isContainerNode(node) {\n  return node && node.dataset && 'spotlightContainer' in node.dataset;\n};\n/**\n * Walks up the node hierarchy calling `fn` on each node that is a container\n *\n * @param   {Node}     node  Node from which to start the search\n * @param   {Function} fn    Called once for each container with the container node as the first\n *                           argument. The return value is accumulated in the array returned by\n *                           `mapContainers`\n *\n * @returns {Array}          Array of values returned by `fn` in order of outermost container to\n *                           innermost container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar mapContainers = function mapContainers(node, fn) {\n  var result = [];\n\n  while (node && node !== document) {\n    if (isContainerNode(node)) {\n      result.unshift(fn(node));\n    }\n\n    node = node.parentNode;\n  }\n\n  return result;\n};\n/**\n * Returns the container config for `containerId`\n *\n * @param   {String}  id  Container ID\n *\n * @returns {Object}      Container config\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerConfig = function getContainerConfig(id) {\n  return containerConfigs.get(id);\n};\n/**\n * Determines if node or a container id represents a spotlight container\n *\n * @param   {Node|String}  nodeOrId  Node or container ID\n *\n * @returns {Boolean}                `true` if `nodeOrId` represents a spotlight container\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getContainerConfig = getContainerConfig;\n\nvar isContainer = function isContainer(nodeOrId) {\n  if (typeof nodeOrId === 'string') {\n    return containerConfigs.has(nodeOrId);\n  }\n\n  return isContainerNode(nodeOrId);\n};\n/**\n * Determines if any of the containers at or above `node` are disabled and, if so, returns `false`.\n *\n * @param   {Node}     node  Spottable node or spotlight container\n *\n * @returns {Boolean}        `true` if all container ancestors are enabled\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isContainer = isContainer;\n\nvar isContainerEnabled = function isContainerEnabled(node) {\n  return mapContainers(node, function (container) {\n    return container.dataset[disabledKey] !== 'true';\n  }).reduce(_and[\"default\"], true);\n};\n/**\n * Returns the container ID for `node`\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        Container ID\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerId = function getContainerId(node) {\n  return node.dataset[containerKey];\n};\n/**\n * Generates a CSS selector string for a current container if `node` is a container\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        CSS selector\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerSelector = function getContainerSelector(node) {\n  if (isContainerNode(node)) {\n    return \"[\".concat(containerAttribute, \"=\\\"\").concat(getContainerId(node), \"\\\"]\");\n  }\n\n  return '';\n};\n/**\n * Generates a CSS selector string for containers within `node` if it is a container\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        CSS selector\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getSubContainerSelector = function getSubContainerSelector(node) {\n  if (isContainerNode(node)) {\n    return \"\".concat(getContainerSelector(node), \" \").concat(containerSelector);\n  }\n\n  return containerSelector;\n};\n/**\n * Returns the node for a container\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node}                 DOM node of the container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerNode = function getContainerNode(containerId) {\n  if (!containerId) {\n    return null;\n  } else if (containerId === rootContainerId) {\n    return document;\n  }\n\n  return document.querySelector(\"[\".concat(containerAttribute, \"=\\\"\").concat(containerId, \"\\\"]\"));\n};\n/**\n * Calls the `navigableFilter` function for the container if defined.\n *\n * @param   {Node}    node         DOM node to check if it is navigable\n * @param   {String}  containerId  ID of container\n *\n * @returns {Boolean}              `true` if it passes the `navigableFilter` method or if that\n *                                  method is not defined for the container\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getContainerNode = getContainerNode;\n\nvar navigableFilter = function navigableFilter(node, containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (config && typeof config.navigableFilter === 'function') {\n    if (config.navigableFilter(node, containerId) === false) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Determines all spottable elements and containers that are directly contained by the container\n * identified by `containerId` and no other subcontainers.\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node[]}               Array of spottable elements and containers.\n * @memberof spotlight/container\n * @public\n */\n\n\nvar getSpottableDescendants = function getSpottableDescendants(containerId) {\n  var node = getContainerNode(containerId); // if it's falsy or is a disabled container, return an empty set\n\n  if (!node || isContainerNode(node) && !isContainerEnabled(node)) {\n    return [];\n  }\n\n  var _ref2 = getContainerConfig(containerId) || {},\n      selector = _ref2.selector,\n      selectorDisabled = _ref2.selectorDisabled;\n\n  if (!selector || selectorDisabled) {\n    return [];\n  }\n\n  var spottableSelector = selector;\n  var subContainerSelector = getSubContainerSelector(node);\n  var candidates = querySelector(node, \"\".concat(spottableSelector, \", \").concat(getContainerSelector(node), \" \").concat(containerSelector, \":not([data-spotlight-container-disabled=\\\"true\\\"])\"), \"\".concat(subContainerSelector, \" \").concat(spottableSelector, \", \").concat(subContainerSelector, \" \").concat(containerSelector));\n  return candidates.filter(function (n) {\n    return navigableFilter(n, containerId);\n  });\n};\n/**\n * Recursively get spottable descendants by including elements within sub-containers that do not\n * have `enterTo` configured\n *\n * @param   {String}    containerId          ID of container\n * @param   {String[]}  [excludedContainers] IDs of containers to exclude from result set\n *\n * @returns {Node[]}                         Array of spottable elements and containers\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getSpottableDescendants = getSpottableDescendants;\n\nvar getDeepSpottableDescendants = function getDeepSpottableDescendants(containerId, excludedContainers) {\n  return getSpottableDescendants(containerId).map(function (n) {\n    if (isContainer(n)) {\n      var id = getContainerId(n);\n      var config = getContainerConfig(id);\n\n      if (excludedContainers && excludedContainers.indexOf(id) >= 0) {\n        return [];\n      } else if (config && !config.enterTo) {\n        return getDeepSpottableDescendants(id, excludedContainers);\n      }\n    }\n\n    return [n];\n  }).reduce(_concat[\"default\"], []);\n};\n/**\n * Determines if a container allows 5-way key hold to be preserved or not.\n *\n * @param {String} containerId Container Id\n * @returns {Boolean} `true` if a container is 5 way holdable\n * @memberof spotlight/container\n * @private\n */\n\n\nvar isContainer5WayHoldable = function isContainer5WayHoldable(containerId) {\n  var config = getContainerConfig(containerId);\n  return config && config.continue5WayHold || false;\n};\n/**\n * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with\n * the last array item being the immediate container id of the element.\n *\n * @param   {Node}      node  Node from which to start the search\n *\n * @returns {String[]}        Array on container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isContainer5WayHoldable = isContainer5WayHoldable;\n\nfunction getContainersForNode(node) {\n  var containers = mapContainers(node, getContainerId);\n  containers.unshift(rootContainerId);\n  return containers;\n}\n/**\n * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with\n * the last array item being the immediate container id of the element. The container ids are\n * limited to only those between `node` and the first restrict=\"self-only\" container.\n *\n * @param   {Node}      node  Node from which to start the search\n *\n * @returns {String[]}        Array on container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nfunction getNavigableContainersForNode(node) {\n  var containerIds = getContainersForNode(node); // find first self-only container id\n\n  var selfOnlyIndex = containerIds.map(getContainerConfig).filter(function (config) {\n    return config != null;\n  }).reduceRight(function (index, config, i) {\n    if (index === -1 && config.restrict === 'self-only') {\n      return i;\n    }\n\n    return index;\n  }, -1); // if we found one (and it's not the root), slice those off and return\n\n  if (selfOnlyIndex > 0) {\n    return containerIds.slice(selfOnlyIndex);\n  }\n\n  return containerIds;\n}\n/**\n * Generates a new unique identifier for a container\n *\n * @returns {String} Container ID\n * @memberof spotlight/container\n * @private\n */\n\n\nfunction generateId() {\n  var id;\n  /* eslint no-constant-condition: [\"error\", { \"checkLoops\": false }] */\n\n  while (true) {\n    id = containerPrefix + String(++_ids);\n\n    if (!isContainer(id)) {\n      break;\n    }\n  }\n\n  return id;\n}\n/**\n * Merges two container configurations while only allowing keys from `updated` which are defined in\n * `GlobalConfig`\n *\n * @param   {Object}  current  Current container configuration\n * @param   {Object}  updated  Updated configuration which may only be a partial configuration\n *\n * @returns {Object}           Merged configuration\n * @memberof spotlight/container\n * @private\n */\n\n\nvar mergeConfig = function mergeConfig(current, updated) {\n  if (!updated) return current;\n  var cfg = null;\n  Object.keys(updated).forEach(function (key) {\n    if (key in GlobalConfig && current[key] !== updated[key]) {\n      if (cfg == null) {\n        cfg = Object.assign({}, current);\n      }\n\n      cfg[key] = updated[key];\n    }\n  });\n  return cfg || current;\n};\n/**\n * Adds or updates a container. When a container id is not specified, it will be generated.\n *\n * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration\n *                                                object.\n * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`\n *                                                is a string. When omitted, the container will have\n *                                                the default `GlobalConfig`.\n *\n * @returns {String}                              The container id\n * @memberof spotlight/container\n * @public\n */\n\n\nvar configureContainer = function configureContainer() {\n  var containerId, config;\n\n  if (_typeof(arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    config = arguments.length <= 0 ? undefined : arguments[0];\n    containerId = config.id;\n  } else if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n    containerId = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n      config = arguments.length <= 1 ? undefined : arguments[1];\n    }\n  }\n\n  if (!containerId) {\n    containerId = generateId();\n  }\n\n  config = mergeConfig(containerConfigs.get(containerId) || _objectSpread({}, GlobalConfig), config);\n  containerConfigs.set(containerId, config);\n  return containerId;\n};\n/**\n * Adds a container and marks it active. When a container id is not specified, it will be generated.\n *\n * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration\n *                                                object.\n * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`\n *                                                is a string. When omitted, the container will have\n *                                                the default `GlobalConfig`.\n *\n * @returns {String}                              The container id\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.configureContainer = configureContainer;\n\nvar addContainer = function addContainer() {\n  var containerId = configureContainer.apply(void 0, arguments);\n  var config = getContainerConfig(containerId);\n  config.active = true;\n  return containerId;\n};\n/**\n * Removes a container\n *\n * @param   {String}     containerId  ID of the container to remove\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.addContainer = addContainer;\n\nvar removeContainer = function removeContainer(containerId) {\n  containerConfigs[\"delete\"](containerId);\n};\n/**\n * Removes all containers\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.removeContainer = removeContainer;\n\nvar removeAllContainers = function removeAllContainers() {\n  containerConfigs.clear();\n};\n/**\n * Configures the `GlobalConfig` for containers\n *\n * @param   {Object}  config  New global configuration. Cannot introduce new keys\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.removeAllContainers = removeAllContainers;\n\nvar configureDefaults = function configureDefaults(config) {\n  GlobalConfig = mergeConfig(GlobalConfig, config);\n};\n/**\n * Determines if `node` is a navigable element within the container identified by `containerId`.\n *\n * @param   {Node}     node         DOM node to check if it is navigable\n * @param   {String}   containerId  ID of the container containing `node`\n * @param   {Boolean}  verify       `true` to verify the node matches the container's `selector`\n *\n * @returns {Boolean}               `true` if `node` is navigable\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.configureDefaults = configureDefaults;\n\nvar isNavigable = function isNavigable(node, containerId, verify) {\n  if (!node || // jsdom reports all nodes as having no size so we must skip this condition in our tests\n  process.env.NODE_ENV !== 'test' && node.offsetWidth <= 0 && node.offsetHeight <= 0) {\n    return false;\n  }\n\n  var containerNode = getContainerNode(containerId);\n\n  if (containerNode !== document && containerNode.dataset[disabledKey] === 'true') {\n    return false;\n  }\n\n  var config = getContainerConfig(containerId);\n\n  if (verify && config && config.selector && !isContainer(node) && !(0, _utils.matchSelector)(config.selector, node)) {\n    return false;\n  }\n\n  return navigableFilter(node, containerId);\n};\n/**\n * Returns the IDs of all containers\n *\n * @returns {String[]}  Array of container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isNavigable = isNavigable;\n\nvar getAllContainerIds = function getAllContainerIds() {\n  var ids = [];\n  var keys = containerConfigs.keys(); // PhantomJS-friendly iterator->array conversion\n\n  var id;\n\n  while ((id = keys.next()) && !id.done) {\n    if (isActiveContainer(id.value)) {\n      ids.push(id.value);\n    }\n  }\n\n  return ids;\n};\n/**\n * Returns the default focus element for a container\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node|null}                 Default focus element\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.getAllContainerIds = getAllContainerIds;\n\nfunction getContainerDefaultElement(containerId) {\n  var config = getContainerConfig(containerId);\n  var defaultElementSelector = config && config.defaultElement;\n\n  if (!defaultElementSelector) {\n    return null;\n  }\n\n  defaultElementSelector = (0, _util.coerceArray)(defaultElementSelector);\n  var spottables = getDeepSpottableDescendants(containerId);\n  return defaultElementSelector.reduce(function (result, selector) {\n    if (result) {\n      return result;\n    }\n\n    if (typeof selector === 'string') {\n      return spottables.filter(function (elem) {\n        return (0, _utils.matchSelector)(selector, elem) && isNavigable(elem, containerId, true);\n      })[0];\n    } // FIXME: There is some prior implicit support for `defaultElement` to be an element rather\n    // than a selector. This continues that support but should eventually be removed.\n\n\n    return selector;\n  }, null);\n}\n/**\n * Gets the element last focused within the container.\n *\n * @param   {String}       containerId  ID of container\n *\n * @returns {Node|String|null}               DOM Node last focused\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerLastFocusedElement(containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (!config || !config.lastFocusedElement) {\n    return null;\n  } // lastFocusedElement may be a container ID so try to convert it to a node to test navigability\n\n\n  var lastFocusedElement = config.lastFocusedElement;\n  var node = lastFocusedElement;\n\n  if (typeof node === 'string') {\n    node = getContainerNode(lastFocusedElement);\n  }\n\n  return isNavigable(node, containerId, true) ? lastFocusedElement : null;\n}\n/**\n * Sets the element last focused within the container\n *\n * @param   {Node}      node         DOM node last focused\n * @param   {String[]}  containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction setContainerLastFocusedElement(node, containerIds) {\n  var lastFocusedElement = node;\n\n  for (var i = containerIds.length - 1; i > -1; i--) {\n    var id = containerIds[i];\n    configureContainer(id, {\n      lastFocusedElement: lastFocusedElement\n    }); // If any container in the stack is controlling entering focus, use its container id as the\n    // lastFocusedElement instead of the node\n\n    var config = getContainerConfig(id);\n\n    if (config.enterTo) {\n      lastFocusedElement = id;\n    }\n  }\n}\n/**\n * Returns all navigable nodes (spottable nodes or containers) visible from outside the container.\n * If the container is restricting navigation into itself via `enterTo`, this method will attempt to\n * return that element as the only element in an array. If that fails or if navigation is not restricted, it will return an\n * array of all possible navigable nodes.\n *\n * @param   {String} containerId Container ID\n *\n * @returns {Node[]}             Navigable elements within container\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerNavigableElements(containerId) {\n  if (!isContainer(containerId)) {\n    return [];\n  }\n\n  var config = getContainerConfig(containerId);\n  var enterTo = config.enterTo,\n      overflow = config.overflow;\n  var enterLast = enterTo === 'last-focused';\n  var next; // if the container has a preferred entry point, try to find it first\n\n  if (enterLast) {\n    next = getContainerLastFocusedElement(containerId);\n  } // try default element if last focused can't be focused\n\n\n  if (!next) {\n    next = getContainerDefaultElement(containerId);\n  }\n\n  if (!next) {\n    var spottables = overflow ? // overflow requires deep recursion to handle selecting the children of unrestricted\n    // containers or restricted containers larger than the container\n    getDeepSpottableDescendants(containerId) : getSpottableDescendants(containerId); // if there isn't a preferred entry on an overflow container, filter the visible elements\n\n    if (overflow) {\n      var containerRect = (0, _utils.getContainerRect)(containerId);\n      next = containerRect && spottables.filter(function (element) {\n        var elementRect = (0, _utils.getRect)(element);\n\n        if (isContainer(element)) {\n          return (0, _utils.intersects)(containerRect, elementRect);\n        }\n\n        return (0, _utils.contains)(containerRect, (0, _utils.getRect)(element));\n      });\n    } // otherwise, return all spottables within the container\n\n\n    if (!next) {\n      next = spottables;\n    }\n  }\n\n  return next ? (0, _util.coerceArray)(next) : [];\n}\n/**\n * Determines the preferred focus target, traversing any sub-containers as necessary, for the given\n * container.\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node}                 Preferred target as either a DOM node or container-id\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerFocusTarget(containerId) {\n  // deferring restoration until it's requested to allow containers to prepare first\n  restoreLastFocusedElement(containerId);\n  var next = getContainerNavigableElements(containerId); // If multiple candidates returned, we need to find the first viable target since some may\n  // be empty containers which should be skipped.\n\n  return next.reduce(function (result, element) {\n    if (result) {\n      return result;\n    } else if (isContainer(element)) {\n      var nextId = isContainerNode(element) ? getContainerId(element) : element;\n      return getContainerFocusTarget(nextId);\n    }\n\n    return element;\n  }, null) || null;\n}\n\nfunction getContainerPreviousTarget(containerId, direction, destination) {\n  var config = getContainerConfig(containerId);\n\n  if (config && config.rememberSource && config.previous && config.previous.reverse === direction && config.previous.destination === destination) {\n    return config.previous.target;\n  }\n}\n\nfunction setContainerPreviousTarget(containerId, direction, destination, target) {\n  var config = getContainerConfig(containerId);\n\n  if (config && config.rememberSource) {\n    configureContainer(containerId, {\n      previous: {\n        target: target,\n        destination: destination,\n        reverse: reverseDirections[direction]\n      }\n    });\n  }\n}\n/**\n * Saves the last focused element into `lastFocusedKey` using a container-defined serialization\n * method configured in `lastFocusedPersist`.\n *\n * @param   {String}     containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction persistLastFocusedElement(containerId) {\n  var cfg = getContainerConfig(containerId);\n\n  if (cfg) {\n    var lastFocusedElement = cfg.lastFocusedElement;\n\n    if (lastFocusedElement) {\n      var all = getDeepSpottableDescendants(containerId);\n      var lastFocusedKey = cfg.lastFocusedPersist(lastFocusedElement, all); // store lastFocusedKey and release node reference to lastFocusedElement\n\n      cfg.lastFocusedKey = lastFocusedKey;\n      cfg.lastFocusedElement = null;\n    }\n  }\n}\n/**\n * Restores the last focused element from `lastFocusedKey` using a container-defined deserialization\n * method configured in `lastFocusedRestore`.\n *\n * @param   {String}     containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction restoreLastFocusedElement(containerId) {\n  var cfg = getContainerConfig(containerId);\n\n  if (cfg && cfg.lastFocusedKey) {\n    var all = getDeepSpottableDescendants(containerId);\n    var lastFocusedElement = cfg.lastFocusedRestore(cfg.lastFocusedKey, all); // restore lastFocusedElement and release lastFocusedKey\n\n    cfg.lastFocusedKey = null;\n    cfg.lastFocusedElement = lastFocusedElement;\n  }\n}\n\nfunction unmountContainer(containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (config) {\n    config.active = false;\n    persistLastFocusedElement(containerId);\n\n    if (typeof config.defaultElement !== 'string') {\n      config.defaultElement = null;\n    }\n  }\n}\n\nfunction isActiveContainer(containerId) {\n  var config = getContainerConfig(containerId);\n  return config && config.active;\n}\n/**\n * Determines if the provided container has a configured restriction.\n *\n * By default, returns `true` for `'self-only'` restrictions but the type of restriction can be\n * passed as well.\n *\n * @param {String} containerId The container id\n * @param {String} [restrict] The container restriction defaulted to `'self-only'`\n * @returns {Boolean} `true` if the container has the specified restriction\n * @private\n */\n\n\nfunction isRestrictedContainer(containerId) {\n  var restrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'self-only';\n  var config = getContainerConfig(containerId);\n  return Boolean(config && config.restrict === restrict);\n}\n/**\n * Determines if `innerContainerId` is inside `outerContainerId`.\n *\n * @param {String} outerContainerId The outer container id\n * @param {String} innerContainerId The inner container id\n * @returns {Boolean} `true` if both containers exist and `innerContainerId` is within\n *                    `outerContainerId`\n * @private\n */\n\n\nfunction containsContainer(outerContainerId, innerContainerId) {\n  var outer = getContainerNode(outerContainerId);\n  var inner = getContainerNode(innerContainerId);\n  return Boolean(outer && inner && outer.contains(inner));\n}\n/**\n * Determines if `containerId` may become the active container.\n *\n * @param {String} containerId Spotlight container to which focus is leaving\n * @returns\t{Boolean} `true` if the active container can change to `containerId`\n * @private\n */\n\n\nfunction mayActivateContainer(containerId) {\n  var currentContainerId = getLastContainer(); // If the current container is restricted to 'self-only' and if the next container to be\n  // activated is not inside the currently activated container, the next container should not be\n  // activated.\n\n  return !isRestrictedContainer(currentContainerId) || containsContainer(currentContainerId, containerId);\n}\n\nfunction getDefaultContainer() {\n  return isActiveContainer(_defaultContainerId) ? _defaultContainerId : '';\n}\n\nfunction setDefaultContainer(containerId) {\n  if (!containerId) {\n    _defaultContainerId = '';\n  } else if (!getContainerConfig(containerId)) {\n    throw new Error('Container \"' + containerId + '\" doesn\\'t exist!');\n  } else {\n    _defaultContainerId = containerId;\n  }\n}\n\nfunction getLastContainer() {\n  return isActiveContainer(_lastContainerId) ? _lastContainerId : '';\n}\n\nfunction setLastContainer(containerId) {\n  _lastContainerId = containerId || '';\n}\n/**\n * Updates the last container based on the current focus and target focus.\n *\n * @param {Node} current Currently focused node\n * @param {Node} target  Target node. May or may not be focusable\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction setLastContainerFromTarget(current, target) {\n  var currentContainers = getNavigableContainersForNode(current);\n  var currentOuterContainerId = currentContainers[0];\n  var currentContainerConfig = getContainerConfig(currentOuterContainerId);\n  var targetContainers = getContainersForNode(target);\n  var targetInnerContainer = (0, _last[\"default\"])(targetContainers);\n  var sharedContainer = (0, _last[\"default\"])((0, _intersection[\"default\"])(currentContainers, targetContainers));\n\n  if (sharedContainer || !currentContainerConfig || currentContainerConfig.restrict !== 'self-only') {\n    // If the target shares a container with the current container stack or the current\n    // element isn't within a self-only container, use the target's nearest container\n    setLastContainer(targetInnerContainer);\n  } else {\n    // Otherwise, the target is not within the current container stack and the current\n    // element was within a 'self-only' container, use the current's outer container\n    setLastContainer(currentOuterContainerId);\n  }\n}\n\nfunction isWithinOverflowContainer(target) {\n  var containerIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getContainersForNode(target);\n  return containerIds // ignore the root container id which is set to overflow by the root decorator\n  .filter(function (id) {\n    return id !== rootContainerId;\n  }) // get the config for each container\n  .map(getContainerConfig) // and check if any are set to overflow\n  .some(function (config) {\n    return config && config.overflow;\n  });\n}\n/**\n * Notifies any affected containers that focus has left one of their children for another container\n *\n * @param {String} direction up/down/left/right\n * @param {Node} current currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @param {Node} next To be focused element\n * @param {String[]} nextContainerIds Containers for next\n * @private\n */\n\n\nfunction notifyLeaveContainer(direction, current, currentContainerIds, next, nextContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    if (!nextContainerIds.includes(containerId)) {\n      var config = getContainerConfig(containerId);\n\n      if (config && config.onLeaveContainer) {\n        config.onLeaveContainer({\n          type: 'onLeaveContainer',\n          direction: direction,\n          target: current,\n          relatedTarget: next\n        });\n      }\n    }\n  });\n}\n/**\n * Notifies any containers that focus attempted to move but failed to find a target\n *\n * @param {String} direction up/down/left/right\n * @param {Node} current currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @private\n */\n\n\nfunction notifyLeaveContainerFail(direction, current, currentContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    var config = getContainerConfig(containerId);\n\n    if (config && config.onLeaveContainerFail) {\n      config.onLeaveContainerFail({\n        type: 'onLeaveContainerFail',\n        direction: direction,\n        target: current\n      });\n    }\n  });\n}\n/**\n * Notifies any affected containers that one of their children has received focus.\n *\n * @param {String} direction up/down/left/right\n * @param {Node} previous Previously focused element\n * @param {String[]} previousContainerIds Containers for previous\n * @param {Node} current Currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @private\n */\n\n\nfunction notifyEnterContainer(direction, previous, previousContainerIds, current, currentContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    if (!previousContainerIds.includes(containerId)) {\n      var config = getContainerConfig(containerId);\n\n      if (config && config.onEnterContainer) {\n        config.onEnterContainer({\n          type: 'onEnterContainer',\n          direction: direction,\n          target: current,\n          relatedTarget: previous\n        });\n      }\n    }\n  });\n}","map":{"version":3,"sources":["/home/cdi/final/SteApp/node_modules/@enact/spotlight/src/container.js"],"names":["Object","defineProperty","exports","value","getContainerDefaultElement","getContainerLastFocusedElement","getContainerNavigableElements","getContainersForNode","setContainerLastFocusedElement","getContainerFocusTarget","getContainerPreviousTarget","getDefaultContainer","getLastContainer","getNavigableContainersForNode","isWithinOverflowContainer","mayActivateContainer","notifyLeaveContainer","notifyLeaveContainerFail","notifyEnterContainer","setContainerPreviousTarget","setDefaultContainer","setLastContainer","setLastContainerFromTarget","unmountContainer","rootContainerId","removeContainer","removeAllContainers","isNavigable","isContainer","getSpottableDescendants","configureContainer","configureDefaults","containerAttribute","addContainer","isContainer5WayHoldable","getContainerConfig","getContainerNode","getAllContainerIds","_and","_interopRequireDefault","require","_concat","_util","_intersection","_last","_utils","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","_typeof","Symbol","iterator","constructor","prototype","containerConfigs","Map","containerKey","disabledKey","containerPrefix","containerSelector","reverseDirections","_ids","_defaultContainerId","_lastContainerId","GlobalConfig","active","continue5WayHold","defaultElement","enterTo","lastFocusedElement","lastFocusedKey","lastFocusedPersist","node","all","container","element","indexOf","lastFocusedRestore","_ref","leaveFor","navigableFilter","obliqueMultiplier","onEnterContainer","onLeaveContainer","onLeaveContainerFail","overflow","rememberSource","restrict","selector","selectorDisabled","straightMultiplier","straightOnly","straightOverlapThreshold","tabIndexIgnoreList","querySelector","includeSelector","excludeSelector","include","Array","slice","call","querySelectorAll","exclude","index","item","splice","isContainerNode","dataset","mapContainers","fn","result","document","unshift","parentNode","id","get","nodeOrId","has","isContainerEnabled","reduce","getContainerId","getContainerSelector","getSubContainerSelector","containerId","config","_ref2","spottableSelector","subContainerSelector","candidates","n","getDeepSpottableDescendants","excludedContainers","map","containers","containerIds","selfOnlyIndex","reduceRight","generateId","String","mergeConfig","current","updated","cfg","assign","undefined","set","apply","clear","verify","process","env","NODE_ENV","offsetWidth","offsetHeight","containerNode","matchSelector","ids","next","done","isActiveContainer","push","defaultElementSelector","coerceArray","spottables","elem","enterLast","containerRect","getContainerRect","elementRect","getRect","intersects","contains","restoreLastFocusedElement","nextId","direction","destination","previous","reverse","persistLastFocusedElement","isRestrictedContainer","Boolean","containsContainer","outerContainerId","innerContainerId","outer","inner","currentContainerId","Error","currentContainers","currentOuterContainerId","currentContainerConfig","targetContainers","targetInnerContainer","sharedContainer","some","currentContainerIds","nextContainerIds","includes","type","relatedTarget","previousContainerIds"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContainerDefaultElement = getContainerDefaultElement;\nexports.getContainerLastFocusedElement = getContainerLastFocusedElement;\nexports.getContainerNavigableElements = getContainerNavigableElements;\nexports.getContainersForNode = getContainersForNode;\nexports.setContainerLastFocusedElement = setContainerLastFocusedElement;\nexports.getContainerFocusTarget = getContainerFocusTarget;\nexports.getContainerPreviousTarget = getContainerPreviousTarget;\nexports.getDefaultContainer = getDefaultContainer;\nexports.getLastContainer = getLastContainer;\nexports.getNavigableContainersForNode = getNavigableContainersForNode;\nexports.isWithinOverflowContainer = isWithinOverflowContainer;\nexports.mayActivateContainer = mayActivateContainer;\nexports.notifyLeaveContainer = notifyLeaveContainer;\nexports.notifyLeaveContainerFail = notifyLeaveContainerFail;\nexports.notifyEnterContainer = notifyEnterContainer;\nexports.setContainerPreviousTarget = setContainerPreviousTarget;\nexports.setDefaultContainer = setDefaultContainer;\nexports.setLastContainer = setLastContainer;\nexports.setLastContainerFromTarget = setLastContainerFromTarget;\nexports.unmountContainer = unmountContainer;\nexports.rootContainerId = exports.removeContainer = exports.removeAllContainers = exports.isNavigable = exports.isContainer = exports.getSpottableDescendants = exports.configureContainer = exports.configureDefaults = exports.containerAttribute = exports.addContainer = exports.isContainer5WayHoldable = exports.getContainerConfig = exports.getContainerNode = exports.getAllContainerIds = void 0;\n\nvar _and = _interopRequireDefault(require(\"ramda/src/and\"));\n\nvar _concat = _interopRequireDefault(require(\"ramda/src/concat\"));\n\nvar _util = require(\"@enact/core/util\");\n\nvar _intersection = _interopRequireDefault(require(\"ramda/src/intersection\"));\n\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar containerAttribute = 'data-spotlight-id';\nexports.containerAttribute = containerAttribute;\nvar containerConfigs = new Map();\nvar containerKey = 'spotlightId';\nvar disabledKey = 'spotlightContainerDisabled';\nvar containerPrefix = 'container-';\nvar containerSelector = '[data-spotlight-container]';\nvar rootContainerId = 'spotlightRootDecorator';\nexports.rootContainerId = rootContainerId;\nvar reverseDirections = {\n  'left': 'right',\n  'up': 'down',\n  'right': 'left',\n  'down': 'up'\n}; // Incrementer for container IDs\n\nvar _ids = 0;\nvar _defaultContainerId = '';\nvar _lastContainerId = ''; // Note: an <extSelector> can be one of following types:\n// - a valid selector string for \"querySelectorAll\"\n// - a NodeList or an array containing DOM elements\n// - a single DOM element\n// - a string \"@<containerId>\" to indicate the specified container\n// - a string \"@\" to indicate the default container\n\nvar GlobalConfig = {\n  // set to false for unmounted containers to omit them from searches\n  active: true,\n  continue5WayHold: false,\n  defaultElement: '',\n  // <extSelector> except \"@\" syntax.\n  enterTo: '',\n  // '', 'last-focused', 'default-element'\n  lastFocusedElement: null,\n  lastFocusedKey: null,\n  lastFocusedPersist: function lastFocusedPersist(node, all) {\n    var container = typeof node === 'string';\n    return {\n      container: container,\n      element: !container,\n      key: container ? node : all.indexOf(node)\n    };\n  },\n  lastFocusedRestore: function lastFocusedRestore(_ref, all) {\n    var container = _ref.container,\n        key = _ref.key;\n    return container ? key : all[key];\n  },\n  leaveFor: null,\n  // {left: <extSelector>, right: <extSelector>, up: <extSelector>, down: <extSelector>}\n  navigableFilter: null,\n  obliqueMultiplier: 5,\n  onEnterContainer: null,\n  // @private - notify the container when entering via 5-way\n  onLeaveContainer: null,\n  // @private - notify the container when leaving via 5-way\n  onLeaveContainerFail: null,\n  // @private - notify the container when failing to leave via 5-way\n  overflow: false,\n  rememberSource: false,\n  restrict: 'self-first',\n  // 'self-first', 'self-only', 'none'\n  selector: '',\n  // can be a valid <extSelector> except \"@\" syntax.\n  selectorDisabled: false,\n  straightMultiplier: 1,\n  straightOnly: false,\n  straightOverlapThreshold: 0.5,\n  tabIndexIgnoreList: 'a, input, select, textarea, button, iframe, [contentEditable=true]'\n};\n/**\n * Calculates nodes within `node` that match `includeSelector` and do not match `excludeSelector`\n *\n * @param   {Node}    node             DOM Node to query\n * @param   {String}  includeSelector  CSS selector of nodes to include\n * @param   {String}  excludeSelector  CSS selector for nodes to exclude\n *\n * @returns {Node[]}                   Array of nodes\n * @memberof spotlight/container\n * @private\n */\n\nvar querySelector = function querySelector(node, includeSelector, excludeSelector) {\n  var include = Array.prototype.slice.call(node.querySelectorAll(includeSelector));\n  var exclude = node.querySelectorAll(excludeSelector);\n\n  for (var i = 0; i < exclude.length; i++) {\n    var index = include.indexOf(exclude.item(i));\n\n    if (index >= 0) {\n      include.splice(index, 1);\n    }\n  }\n\n  return include;\n};\n/**\n * Determines if `node` is a spotlight container\n *\n * @param   {Node}     node   Node to check\n *\n * @returns {Boolean}        `true` if `node` is a spotlight container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar isContainerNode = function isContainerNode(node) {\n  return node && node.dataset && 'spotlightContainer' in node.dataset;\n};\n/**\n * Walks up the node hierarchy calling `fn` on each node that is a container\n *\n * @param   {Node}     node  Node from which to start the search\n * @param   {Function} fn    Called once for each container with the container node as the first\n *                           argument. The return value is accumulated in the array returned by\n *                           `mapContainers`\n *\n * @returns {Array}          Array of values returned by `fn` in order of outermost container to\n *                           innermost container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar mapContainers = function mapContainers(node, fn) {\n  var result = [];\n\n  while (node && node !== document) {\n    if (isContainerNode(node)) {\n      result.unshift(fn(node));\n    }\n\n    node = node.parentNode;\n  }\n\n  return result;\n};\n/**\n * Returns the container config for `containerId`\n *\n * @param   {String}  id  Container ID\n *\n * @returns {Object}      Container config\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerConfig = function getContainerConfig(id) {\n  return containerConfigs.get(id);\n};\n/**\n * Determines if node or a container id represents a spotlight container\n *\n * @param   {Node|String}  nodeOrId  Node or container ID\n *\n * @returns {Boolean}                `true` if `nodeOrId` represents a spotlight container\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getContainerConfig = getContainerConfig;\n\nvar isContainer = function isContainer(nodeOrId) {\n  if (typeof nodeOrId === 'string') {\n    return containerConfigs.has(nodeOrId);\n  }\n\n  return isContainerNode(nodeOrId);\n};\n/**\n * Determines if any of the containers at or above `node` are disabled and, if so, returns `false`.\n *\n * @param   {Node}     node  Spottable node or spotlight container\n *\n * @returns {Boolean}        `true` if all container ancestors are enabled\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isContainer = isContainer;\n\nvar isContainerEnabled = function isContainerEnabled(node) {\n  return mapContainers(node, function (container) {\n    return container.dataset[disabledKey] !== 'true';\n  }).reduce(_and[\"default\"], true);\n};\n/**\n * Returns the container ID for `node`\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        Container ID\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerId = function getContainerId(node) {\n  return node.dataset[containerKey];\n};\n/**\n * Generates a CSS selector string for a current container if `node` is a container\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        CSS selector\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerSelector = function getContainerSelector(node) {\n  if (isContainerNode(node)) {\n    return \"[\".concat(containerAttribute, \"=\\\"\").concat(getContainerId(node), \"\\\"]\");\n  }\n\n  return '';\n};\n/**\n * Generates a CSS selector string for containers within `node` if it is a container\n *\n * @param   {Node}    node  Container Node\n *\n * @returns {String}        CSS selector\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getSubContainerSelector = function getSubContainerSelector(node) {\n  if (isContainerNode(node)) {\n    return \"\".concat(getContainerSelector(node), \" \").concat(containerSelector);\n  }\n\n  return containerSelector;\n};\n/**\n * Returns the node for a container\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node}                 DOM node of the container\n * @memberof spotlight/container\n * @private\n */\n\n\nvar getContainerNode = function getContainerNode(containerId) {\n  if (!containerId) {\n    return null;\n  } else if (containerId === rootContainerId) {\n    return document;\n  }\n\n  return document.querySelector(\"[\".concat(containerAttribute, \"=\\\"\").concat(containerId, \"\\\"]\"));\n};\n/**\n * Calls the `navigableFilter` function for the container if defined.\n *\n * @param   {Node}    node         DOM node to check if it is navigable\n * @param   {String}  containerId  ID of container\n *\n * @returns {Boolean}              `true` if it passes the `navigableFilter` method or if that\n *                                  method is not defined for the container\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getContainerNode = getContainerNode;\n\nvar navigableFilter = function navigableFilter(node, containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (config && typeof config.navigableFilter === 'function') {\n    if (config.navigableFilter(node, containerId) === false) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Determines all spottable elements and containers that are directly contained by the container\n * identified by `containerId` and no other subcontainers.\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node[]}               Array of spottable elements and containers.\n * @memberof spotlight/container\n * @public\n */\n\n\nvar getSpottableDescendants = function getSpottableDescendants(containerId) {\n  var node = getContainerNode(containerId); // if it's falsy or is a disabled container, return an empty set\n\n  if (!node || isContainerNode(node) && !isContainerEnabled(node)) {\n    return [];\n  }\n\n  var _ref2 = getContainerConfig(containerId) || {},\n      selector = _ref2.selector,\n      selectorDisabled = _ref2.selectorDisabled;\n\n  if (!selector || selectorDisabled) {\n    return [];\n  }\n\n  var spottableSelector = selector;\n  var subContainerSelector = getSubContainerSelector(node);\n  var candidates = querySelector(node, \"\".concat(spottableSelector, \", \").concat(getContainerSelector(node), \" \").concat(containerSelector, \":not([data-spotlight-container-disabled=\\\"true\\\"])\"), \"\".concat(subContainerSelector, \" \").concat(spottableSelector, \", \").concat(subContainerSelector, \" \").concat(containerSelector));\n  return candidates.filter(function (n) {\n    return navigableFilter(n, containerId);\n  });\n};\n/**\n * Recursively get spottable descendants by including elements within sub-containers that do not\n * have `enterTo` configured\n *\n * @param   {String}    containerId          ID of container\n * @param   {String[]}  [excludedContainers] IDs of containers to exclude from result set\n *\n * @returns {Node[]}                         Array of spottable elements and containers\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.getSpottableDescendants = getSpottableDescendants;\n\nvar getDeepSpottableDescendants = function getDeepSpottableDescendants(containerId, excludedContainers) {\n  return getSpottableDescendants(containerId).map(function (n) {\n    if (isContainer(n)) {\n      var id = getContainerId(n);\n      var config = getContainerConfig(id);\n\n      if (excludedContainers && excludedContainers.indexOf(id) >= 0) {\n        return [];\n      } else if (config && !config.enterTo) {\n        return getDeepSpottableDescendants(id, excludedContainers);\n      }\n    }\n\n    return [n];\n  }).reduce(_concat[\"default\"], []);\n};\n/**\n * Determines if a container allows 5-way key hold to be preserved or not.\n *\n * @param {String} containerId Container Id\n * @returns {Boolean} `true` if a container is 5 way holdable\n * @memberof spotlight/container\n * @private\n */\n\n\nvar isContainer5WayHoldable = function isContainer5WayHoldable(containerId) {\n  var config = getContainerConfig(containerId);\n  return config && config.continue5WayHold || false;\n};\n/**\n * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with\n * the last array item being the immediate container id of the element.\n *\n * @param   {Node}      node  Node from which to start the search\n *\n * @returns {String[]}        Array on container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isContainer5WayHoldable = isContainer5WayHoldable;\n\nfunction getContainersForNode(node) {\n  var containers = mapContainers(node, getContainerId);\n  containers.unshift(rootContainerId);\n  return containers;\n}\n/**\n * Returns an array of ids for containers that wrap the element, in order of outer-to-inner, with\n * the last array item being the immediate container id of the element. The container ids are\n * limited to only those between `node` and the first restrict=\"self-only\" container.\n *\n * @param   {Node}      node  Node from which to start the search\n *\n * @returns {String[]}        Array on container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nfunction getNavigableContainersForNode(node) {\n  var containerIds = getContainersForNode(node); // find first self-only container id\n\n  var selfOnlyIndex = containerIds.map(getContainerConfig).filter(function (config) {\n    return config != null;\n  }).reduceRight(function (index, config, i) {\n    if (index === -1 && config.restrict === 'self-only') {\n      return i;\n    }\n\n    return index;\n  }, -1); // if we found one (and it's not the root), slice those off and return\n\n  if (selfOnlyIndex > 0) {\n    return containerIds.slice(selfOnlyIndex);\n  }\n\n  return containerIds;\n}\n/**\n * Generates a new unique identifier for a container\n *\n * @returns {String} Container ID\n * @memberof spotlight/container\n * @private\n */\n\n\nfunction generateId() {\n  var id;\n  /* eslint no-constant-condition: [\"error\", { \"checkLoops\": false }] */\n\n  while (true) {\n    id = containerPrefix + String(++_ids);\n\n    if (!isContainer(id)) {\n      break;\n    }\n  }\n\n  return id;\n}\n/**\n * Merges two container configurations while only allowing keys from `updated` which are defined in\n * `GlobalConfig`\n *\n * @param   {Object}  current  Current container configuration\n * @param   {Object}  updated  Updated configuration which may only be a partial configuration\n *\n * @returns {Object}           Merged configuration\n * @memberof spotlight/container\n * @private\n */\n\n\nvar mergeConfig = function mergeConfig(current, updated) {\n  if (!updated) return current;\n  var cfg = null;\n  Object.keys(updated).forEach(function (key) {\n    if (key in GlobalConfig && current[key] !== updated[key]) {\n      if (cfg == null) {\n        cfg = Object.assign({}, current);\n      }\n\n      cfg[key] = updated[key];\n    }\n  });\n  return cfg || current;\n};\n/**\n * Adds or updates a container. When a container id is not specified, it will be generated.\n *\n * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration\n *                                                object.\n * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`\n *                                                is a string. When omitted, the container will have\n *                                                the default `GlobalConfig`.\n *\n * @returns {String}                              The container id\n * @memberof spotlight/container\n * @public\n */\n\n\nvar configureContainer = function configureContainer() {\n  var containerId, config;\n\n  if (_typeof(arguments.length <= 0 ? undefined : arguments[0]) === 'object') {\n    config = arguments.length <= 0 ? undefined : arguments[0];\n    containerId = config.id;\n  } else if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n    containerId = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (_typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object') {\n      config = arguments.length <= 1 ? undefined : arguments[1];\n    }\n  }\n\n  if (!containerId) {\n    containerId = generateId();\n  }\n\n  config = mergeConfig(containerConfigs.get(containerId) || _objectSpread({}, GlobalConfig), config);\n  containerConfigs.set(containerId, config);\n  return containerId;\n};\n/**\n * Adds a container and marks it active. When a container id is not specified, it will be generated.\n *\n * @param   {String|Object}  containerIdOrConfig  Either a string container id or a configuration\n *                                                object.\n * @param   {Object}         [config]             Container configuration when `containerIdOrConfig`\n *                                                is a string. When omitted, the container will have\n *                                                the default `GlobalConfig`.\n *\n * @returns {String}                              The container id\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.configureContainer = configureContainer;\n\nvar addContainer = function addContainer() {\n  var containerId = configureContainer.apply(void 0, arguments);\n  var config = getContainerConfig(containerId);\n  config.active = true;\n  return containerId;\n};\n/**\n * Removes a container\n *\n * @param   {String}     containerId  ID of the container to remove\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.addContainer = addContainer;\n\nvar removeContainer = function removeContainer(containerId) {\n  containerConfigs[\"delete\"](containerId);\n};\n/**\n * Removes all containers\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.removeContainer = removeContainer;\n\nvar removeAllContainers = function removeAllContainers() {\n  containerConfigs.clear();\n};\n/**\n * Configures the `GlobalConfig` for containers\n *\n * @param   {Object}  config  New global configuration. Cannot introduce new keys\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.removeAllContainers = removeAllContainers;\n\nvar configureDefaults = function configureDefaults(config) {\n  GlobalConfig = mergeConfig(GlobalConfig, config);\n};\n/**\n * Determines if `node` is a navigable element within the container identified by `containerId`.\n *\n * @param   {Node}     node         DOM node to check if it is navigable\n * @param   {String}   containerId  ID of the container containing `node`\n * @param   {Boolean}  verify       `true` to verify the node matches the container's `selector`\n *\n * @returns {Boolean}               `true` if `node` is navigable\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.configureDefaults = configureDefaults;\n\nvar isNavigable = function isNavigable(node, containerId, verify) {\n  if (!node || // jsdom reports all nodes as having no size so we must skip this condition in our tests\n  process.env.NODE_ENV !== 'test' && node.offsetWidth <= 0 && node.offsetHeight <= 0) {\n    return false;\n  }\n\n  var containerNode = getContainerNode(containerId);\n\n  if (containerNode !== document && containerNode.dataset[disabledKey] === 'true') {\n    return false;\n  }\n\n  var config = getContainerConfig(containerId);\n\n  if (verify && config && config.selector && !isContainer(node) && !(0, _utils.matchSelector)(config.selector, node)) {\n    return false;\n  }\n\n  return navigableFilter(node, containerId);\n};\n/**\n * Returns the IDs of all containers\n *\n * @returns {String[]}  Array of container IDs\n * @memberof spotlight/container\n * @private\n */\n\n\nexports.isNavigable = isNavigable;\n\nvar getAllContainerIds = function getAllContainerIds() {\n  var ids = [];\n  var keys = containerConfigs.keys(); // PhantomJS-friendly iterator->array conversion\n\n  var id;\n\n  while ((id = keys.next()) && !id.done) {\n    if (isActiveContainer(id.value)) {\n      ids.push(id.value);\n    }\n  }\n\n  return ids;\n};\n/**\n * Returns the default focus element for a container\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node|null}                 Default focus element\n * @memberof spotlight/container\n * @public\n */\n\n\nexports.getAllContainerIds = getAllContainerIds;\n\nfunction getContainerDefaultElement(containerId) {\n  var config = getContainerConfig(containerId);\n  var defaultElementSelector = config && config.defaultElement;\n\n  if (!defaultElementSelector) {\n    return null;\n  }\n\n  defaultElementSelector = (0, _util.coerceArray)(defaultElementSelector);\n  var spottables = getDeepSpottableDescendants(containerId);\n  return defaultElementSelector.reduce(function (result, selector) {\n    if (result) {\n      return result;\n    }\n\n    if (typeof selector === 'string') {\n      return spottables.filter(function (elem) {\n        return (0, _utils.matchSelector)(selector, elem) && isNavigable(elem, containerId, true);\n      })[0];\n    } // FIXME: There is some prior implicit support for `defaultElement` to be an element rather\n    // than a selector. This continues that support but should eventually be removed.\n\n\n    return selector;\n  }, null);\n}\n/**\n * Gets the element last focused within the container.\n *\n * @param   {String}       containerId  ID of container\n *\n * @returns {Node|String|null}               DOM Node last focused\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerLastFocusedElement(containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (!config || !config.lastFocusedElement) {\n    return null;\n  } // lastFocusedElement may be a container ID so try to convert it to a node to test navigability\n\n\n  var lastFocusedElement = config.lastFocusedElement;\n  var node = lastFocusedElement;\n\n  if (typeof node === 'string') {\n    node = getContainerNode(lastFocusedElement);\n  }\n\n  return isNavigable(node, containerId, true) ? lastFocusedElement : null;\n}\n/**\n * Sets the element last focused within the container\n *\n * @param   {Node}      node         DOM node last focused\n * @param   {String[]}  containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction setContainerLastFocusedElement(node, containerIds) {\n  var lastFocusedElement = node;\n\n  for (var i = containerIds.length - 1; i > -1; i--) {\n    var id = containerIds[i];\n    configureContainer(id, {\n      lastFocusedElement: lastFocusedElement\n    }); // If any container in the stack is controlling entering focus, use its container id as the\n    // lastFocusedElement instead of the node\n\n    var config = getContainerConfig(id);\n\n    if (config.enterTo) {\n      lastFocusedElement = id;\n    }\n  }\n}\n/**\n * Returns all navigable nodes (spottable nodes or containers) visible from outside the container.\n * If the container is restricting navigation into itself via `enterTo`, this method will attempt to\n * return that element as the only element in an array. If that fails or if navigation is not restricted, it will return an\n * array of all possible navigable nodes.\n *\n * @param   {String} containerId Container ID\n *\n * @returns {Node[]}             Navigable elements within container\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerNavigableElements(containerId) {\n  if (!isContainer(containerId)) {\n    return [];\n  }\n\n  var config = getContainerConfig(containerId);\n  var enterTo = config.enterTo,\n      overflow = config.overflow;\n  var enterLast = enterTo === 'last-focused';\n  var next; // if the container has a preferred entry point, try to find it first\n\n  if (enterLast) {\n    next = getContainerLastFocusedElement(containerId);\n  } // try default element if last focused can't be focused\n\n\n  if (!next) {\n    next = getContainerDefaultElement(containerId);\n  }\n\n  if (!next) {\n    var spottables = overflow ? // overflow requires deep recursion to handle selecting the children of unrestricted\n    // containers or restricted containers larger than the container\n    getDeepSpottableDescendants(containerId) : getSpottableDescendants(containerId); // if there isn't a preferred entry on an overflow container, filter the visible elements\n\n    if (overflow) {\n      var containerRect = (0, _utils.getContainerRect)(containerId);\n      next = containerRect && spottables.filter(function (element) {\n        var elementRect = (0, _utils.getRect)(element);\n\n        if (isContainer(element)) {\n          return (0, _utils.intersects)(containerRect, elementRect);\n        }\n\n        return (0, _utils.contains)(containerRect, (0, _utils.getRect)(element));\n      });\n    } // otherwise, return all spottables within the container\n\n\n    if (!next) {\n      next = spottables;\n    }\n  }\n\n  return next ? (0, _util.coerceArray)(next) : [];\n}\n/**\n * Determines the preferred focus target, traversing any sub-containers as necessary, for the given\n * container.\n *\n * @param   {String}  containerId  ID of container\n *\n * @returns {Node}                 Preferred target as either a DOM node or container-id\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction getContainerFocusTarget(containerId) {\n  // deferring restoration until it's requested to allow containers to prepare first\n  restoreLastFocusedElement(containerId);\n  var next = getContainerNavigableElements(containerId); // If multiple candidates returned, we need to find the first viable target since some may\n  // be empty containers which should be skipped.\n\n  return next.reduce(function (result, element) {\n    if (result) {\n      return result;\n    } else if (isContainer(element)) {\n      var nextId = isContainerNode(element) ? getContainerId(element) : element;\n      return getContainerFocusTarget(nextId);\n    }\n\n    return element;\n  }, null) || null;\n}\n\nfunction getContainerPreviousTarget(containerId, direction, destination) {\n  var config = getContainerConfig(containerId);\n\n  if (config && config.rememberSource && config.previous && config.previous.reverse === direction && config.previous.destination === destination) {\n    return config.previous.target;\n  }\n}\n\nfunction setContainerPreviousTarget(containerId, direction, destination, target) {\n  var config = getContainerConfig(containerId);\n\n  if (config && config.rememberSource) {\n    configureContainer(containerId, {\n      previous: {\n        target: target,\n        destination: destination,\n        reverse: reverseDirections[direction]\n      }\n    });\n  }\n}\n/**\n * Saves the last focused element into `lastFocusedKey` using a container-defined serialization\n * method configured in `lastFocusedPersist`.\n *\n * @param   {String}     containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction persistLastFocusedElement(containerId) {\n  var cfg = getContainerConfig(containerId);\n\n  if (cfg) {\n    var lastFocusedElement = cfg.lastFocusedElement;\n\n    if (lastFocusedElement) {\n      var all = getDeepSpottableDescendants(containerId);\n      var lastFocusedKey = cfg.lastFocusedPersist(lastFocusedElement, all); // store lastFocusedKey and release node reference to lastFocusedElement\n\n      cfg.lastFocusedKey = lastFocusedKey;\n      cfg.lastFocusedElement = null;\n    }\n  }\n}\n/**\n * Restores the last focused element from `lastFocusedKey` using a container-defined deserialization\n * method configured in `lastFocusedRestore`.\n *\n * @param   {String}     containerId  ID of container\n *\n * @returns {undefined}\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction restoreLastFocusedElement(containerId) {\n  var cfg = getContainerConfig(containerId);\n\n  if (cfg && cfg.lastFocusedKey) {\n    var all = getDeepSpottableDescendants(containerId);\n    var lastFocusedElement = cfg.lastFocusedRestore(cfg.lastFocusedKey, all); // restore lastFocusedElement and release lastFocusedKey\n\n    cfg.lastFocusedKey = null;\n    cfg.lastFocusedElement = lastFocusedElement;\n  }\n}\n\nfunction unmountContainer(containerId) {\n  var config = getContainerConfig(containerId);\n\n  if (config) {\n    config.active = false;\n    persistLastFocusedElement(containerId);\n\n    if (typeof config.defaultElement !== 'string') {\n      config.defaultElement = null;\n    }\n  }\n}\n\nfunction isActiveContainer(containerId) {\n  var config = getContainerConfig(containerId);\n  return config && config.active;\n}\n/**\n * Determines if the provided container has a configured restriction.\n *\n * By default, returns `true` for `'self-only'` restrictions but the type of restriction can be\n * passed as well.\n *\n * @param {String} containerId The container id\n * @param {String} [restrict] The container restriction defaulted to `'self-only'`\n * @returns {Boolean} `true` if the container has the specified restriction\n * @private\n */\n\n\nfunction isRestrictedContainer(containerId) {\n  var restrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'self-only';\n  var config = getContainerConfig(containerId);\n  return Boolean(config && config.restrict === restrict);\n}\n/**\n * Determines if `innerContainerId` is inside `outerContainerId`.\n *\n * @param {String} outerContainerId The outer container id\n * @param {String} innerContainerId The inner container id\n * @returns {Boolean} `true` if both containers exist and `innerContainerId` is within\n *                    `outerContainerId`\n * @private\n */\n\n\nfunction containsContainer(outerContainerId, innerContainerId) {\n  var outer = getContainerNode(outerContainerId);\n  var inner = getContainerNode(innerContainerId);\n  return Boolean(outer && inner && outer.contains(inner));\n}\n/**\n * Determines if `containerId` may become the active container.\n *\n * @param {String} containerId Spotlight container to which focus is leaving\n * @returns\t{Boolean} `true` if the active container can change to `containerId`\n * @private\n */\n\n\nfunction mayActivateContainer(containerId) {\n  var currentContainerId = getLastContainer(); // If the current container is restricted to 'self-only' and if the next container to be\n  // activated is not inside the currently activated container, the next container should not be\n  // activated.\n\n  return !isRestrictedContainer(currentContainerId) || containsContainer(currentContainerId, containerId);\n}\n\nfunction getDefaultContainer() {\n  return isActiveContainer(_defaultContainerId) ? _defaultContainerId : '';\n}\n\nfunction setDefaultContainer(containerId) {\n  if (!containerId) {\n    _defaultContainerId = '';\n  } else if (!getContainerConfig(containerId)) {\n    throw new Error('Container \"' + containerId + '\" doesn\\'t exist!');\n  } else {\n    _defaultContainerId = containerId;\n  }\n}\n\nfunction getLastContainer() {\n  return isActiveContainer(_lastContainerId) ? _lastContainerId : '';\n}\n\nfunction setLastContainer(containerId) {\n  _lastContainerId = containerId || '';\n}\n/**\n * Updates the last container based on the current focus and target focus.\n *\n * @param {Node} current Currently focused node\n * @param {Node} target  Target node. May or may not be focusable\n * @memberof spotlight/container\n * @public\n */\n\n\nfunction setLastContainerFromTarget(current, target) {\n  var currentContainers = getNavigableContainersForNode(current);\n  var currentOuterContainerId = currentContainers[0];\n  var currentContainerConfig = getContainerConfig(currentOuterContainerId);\n  var targetContainers = getContainersForNode(target);\n  var targetInnerContainer = (0, _last[\"default\"])(targetContainers);\n  var sharedContainer = (0, _last[\"default\"])((0, _intersection[\"default\"])(currentContainers, targetContainers));\n\n  if (sharedContainer || !currentContainerConfig || currentContainerConfig.restrict !== 'self-only') {\n    // If the target shares a container with the current container stack or the current\n    // element isn't within a self-only container, use the target's nearest container\n    setLastContainer(targetInnerContainer);\n  } else {\n    // Otherwise, the target is not within the current container stack and the current\n    // element was within a 'self-only' container, use the current's outer container\n    setLastContainer(currentOuterContainerId);\n  }\n}\n\nfunction isWithinOverflowContainer(target) {\n  var containerIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getContainersForNode(target);\n  return containerIds // ignore the root container id which is set to overflow by the root decorator\n  .filter(function (id) {\n    return id !== rootContainerId;\n  }) // get the config for each container\n  .map(getContainerConfig) // and check if any are set to overflow\n  .some(function (config) {\n    return config && config.overflow;\n  });\n}\n/**\n * Notifies any affected containers that focus has left one of their children for another container\n *\n * @param {String} direction up/down/left/right\n * @param {Node} current currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @param {Node} next To be focused element\n * @param {String[]} nextContainerIds Containers for next\n * @private\n */\n\n\nfunction notifyLeaveContainer(direction, current, currentContainerIds, next, nextContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    if (!nextContainerIds.includes(containerId)) {\n      var config = getContainerConfig(containerId);\n\n      if (config && config.onLeaveContainer) {\n        config.onLeaveContainer({\n          type: 'onLeaveContainer',\n          direction: direction,\n          target: current,\n          relatedTarget: next\n        });\n      }\n    }\n  });\n}\n/**\n * Notifies any containers that focus attempted to move but failed to find a target\n *\n * @param {String} direction up/down/left/right\n * @param {Node} current currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @private\n */\n\n\nfunction notifyLeaveContainerFail(direction, current, currentContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    var config = getContainerConfig(containerId);\n\n    if (config && config.onLeaveContainerFail) {\n      config.onLeaveContainerFail({\n        type: 'onLeaveContainerFail',\n        direction: direction,\n        target: current\n      });\n    }\n  });\n}\n/**\n * Notifies any affected containers that one of their children has received focus.\n *\n * @param {String} direction up/down/left/right\n * @param {Node} previous Previously focused element\n * @param {String[]} previousContainerIds Containers for previous\n * @param {Node} current Currently focused element\n * @param {String[]} currentContainerIds Containers for current\n * @private\n */\n\n\nfunction notifyEnterContainer(direction, previous, previousContainerIds, current, currentContainerIds) {\n  currentContainerIds.forEach(function (containerId) {\n    if (!previousContainerIds.includes(containerId)) {\n      var config = getContainerConfig(containerId);\n\n      if (config && config.onEnterContainer) {\n        config.onEnterContainer({\n          type: 'onEnterContainer',\n          direction: direction,\n          target: current,\n          relatedTarget: previous\n        });\n      }\n    }\n  });\n}"]},"metadata":{},"sourceType":"module"}