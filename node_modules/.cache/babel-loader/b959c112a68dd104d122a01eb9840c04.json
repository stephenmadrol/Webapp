{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n/*\n * IString.js - ilib string subclass definition\n *\n * Copyright Â© 2012-2015, 2018, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js Utils.js Locale.js MathUtils.js\n// !data plurals\n\n\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n/**\n * @class\n * Create a new ilib string instance. This string inherits from and\n * extends the Javascript String class. It can be\n * used almost anywhere that a normal Javascript string is used, though in\n * some instances you will need to call the {@link #toString} method when\n * a built-in Javascript string is needed. The formatting methods are\n * methods that are not in the intrinsic String class and are most useful\n * when localizing strings in an app or web site in combination with\n * the ResBundle class.<p>\n *\n * This class is named IString (\"ilib string\") so as not to conflict with the\n * built-in Javascript String class.\n *\n * @constructor\n * @param {string|IString=} string initialize this instance with this string\n */\n\n\nvar IString = function IString(string) {\n  if (_typeof(string) === 'object') {\n    if (string instanceof IString) {\n      this.str = string.str;\n    } else {\n      this.str = string.toString();\n    }\n  } else if (typeof string === 'string') {\n    this.str = new String(string);\n  } else {\n    this.str = \"\";\n  }\n\n  this.length = this.str.length;\n  this.cpLength = -1;\n  this.localeSpec = ilib.getLocale();\n};\n/**\n * Return true if the given character is a Unicode surrogate character,\n * either high or low.\n *\n * @private\n * @static\n * @param {string} ch character to check\n * @return {boolean} true if the character is a surrogate\n */\n\n\nIString._isSurrogate = function (ch) {\n  var n = ch.charCodeAt(0);\n  return n >= 0xDC00 && n <= 0xDFFF || n >= 0xD800 && n <= 0xDBFF;\n}; // build in the English rule\n\n\nIString.plurals_default = {\n  \"one\": {\n    \"and\": [{\n      \"eq\": [\"i\", 1]\n    }, {\n      \"eq\": [\"v\", 0]\n    }]\n  }\n};\n/**\n * Convert a UCS-4 code point to a Javascript string. The codepoint can be any valid\n * UCS-4 Unicode character, including supplementary characters. Standard Javascript\n * only supports supplementary characters using the UTF-16 encoding, which has\n * values in the range 0x0000-0xFFFF. String.fromCharCode() will only\n * give you a string containing 16-bit characters, and will not properly convert\n * the code point for a supplementary character (which has a value > 0xFFFF) into\n * two UTF-16 surrogate characters. Instead, it will just just give you whatever\n * single character happens to be the same as your code point modulo 0x10000, which\n * is almost never what you want.<p>\n *\n * Similarly, that means if you use String.charCodeAt()\n * you will only retrieve a 16-bit value, which may possibly be a single\n * surrogate character that is part of a surrogate pair representing a character\n * in the supplementary plane. It will not give you a code point. Use\n * IString.codePointAt() to access code points in a string, or use\n * an iterator to walk through the code points in a string.\n *\n * @static\n * @param {number} codepoint UCS-4 code point to convert to a character\n * @return {string} a string containing the character represented by the codepoint\n */\n\nIString.fromCodePoint = function (codepoint) {\n  if (codepoint < 0x10000) {\n    return String.fromCharCode(codepoint);\n  } else {\n    var high = Math.floor(codepoint / 0x10000) - 1;\n    var low = codepoint & 0xFFFF;\n    return String.fromCharCode(0xD800 | (high & 0x000F) << 6 | (low & 0xFC00) >> 10) + String.fromCharCode(0xDC00 | low & 0x3FF);\n  }\n};\n/**\n * Convert the character or the surrogate pair at the given\n * index into the intrinsic Javascript string to a Unicode\n * UCS-4 code point.\n *\n * @static\n * @param {string} str string to get the code point from\n * @param {number} index index into the string\n * @return {number} code point of the character at the\n * given index into the string\n */\n\n\nIString.toCodePoint = function (str, index) {\n  if (!str || str.length === 0) {\n    return -1;\n  }\n\n  var code = -1,\n      high = str.charCodeAt(index);\n\n  if (high >= 0xD800 && high <= 0xDBFF) {\n    if (str.length > index + 1) {\n      var low = str.charCodeAt(index + 1);\n\n      if (low >= 0xDC00 && low <= 0xDFFF) {\n        code = ((high & 0x3C0) >> 6) + 1 << 16 | ((high & 0x3F) << 10 | low & 0x3FF);\n      }\n    }\n  } else {\n    code = high;\n  }\n\n  return code;\n};\n/**\n * Load the plural the definitions of plurals for the locale.\n * @param {boolean=} sync\n * @param {Locale|string=} locale\n * @param {Object=} loadParams\n * @param {function(*)=} onLoad\n */\n\n\nIString.loadPlurals = function (sync, locale, loadParams, onLoad) {\n  var loc;\n\n  if (locale) {\n    loc = typeof locale === 'string' ? new Locale(locale) : locale;\n  } else {\n    loc = new Locale(ilib.getLocale());\n  }\n\n  var spec = loc.getLanguage();\n\n  if (!ilib.data[\"plurals_\" + spec]) {\n    Utils.loadData({\n      name: \"plurals.json\",\n      object: \"IString\",\n      locale: loc,\n      sync: sync,\n      loadParams: loadParams,\n      callback: ilib.bind(this, function (plurals) {\n        if (!plurals) {\n          ilib.data.cache.IString[spec] = IString.plurals_default;\n        }\n\n        ilib.data[\"plurals_\" + spec] = plurals || IString.plurals_default;\n\n        if (onLoad && typeof onLoad === 'function') {\n          onLoad(ilib.data[\"plurals_\" + spec]);\n        }\n      })\n    });\n  } else {\n    if (onLoad && typeof onLoad === 'function') {\n      onLoad(ilib.data[\"plurals_\" + spec]);\n    }\n  }\n};\n/**\n * @private\n * @static\n */\n\n\nIString._fncs = {\n  /**\n   * @private\n   * @param {Object} obj\n   * @return {string|undefined}\n   */\n  firstProp: function firstProp(obj) {\n    for (var p in obj) {\n      if (p && obj[p]) {\n        return p;\n      }\n    }\n\n    return undefined; // should never get here\n  },\n\n  /**\n   * @private\n   * @param {Object} obj\n   * @return {string|undefined}\n   */\n  firstPropRule: function firstPropRule(obj) {\n    if (Object.prototype.toString.call(obj) === '[object Array]') {\n      return \"inrange\";\n    } else if (Object.prototype.toString.call(obj) === '[object Object]') {\n      for (var p in obj) {\n        if (p && obj[p]) {\n          return p;\n        }\n      }\n    }\n\n    return undefined; // should never get here\n  },\n\n  /**\n   * @private\n   * @param {Object} obj\n   * @param {number|Object} n\n   * @return {?}\n   */\n  getValue: function getValue(obj, n) {\n    if (_typeof(obj) === 'object') {\n      var subrule = IString._fncs.firstPropRule(obj);\n\n      if (subrule === \"inrange\") {\n        return IString._fncs[subrule](obj, n);\n      }\n\n      return IString._fncs[subrule](obj[subrule], n);\n    } else if (typeof obj === 'string') {\n      if (_typeof(n) === 'object') {\n        return n[obj];\n      }\n\n      return n;\n    } else {\n      return obj;\n    }\n  },\n\n  /**\n   * @private\n   * @param {number|Object} n\n   * @param {Array.<number|Array.<number>>|Object} range\n   * @return {boolean}\n   */\n  matchRangeContinuous: function matchRangeContinuous(n, range) {\n    for (var num in range) {\n      if (typeof num !== 'undefined' && typeof range[num] !== 'undefined') {\n        var obj = range[num];\n\n        if (typeof obj === 'number') {\n          if (n === range[num]) {\n            return true;\n          } else if (n >= range[0] && n <= range[1]) {\n            return true;\n          }\n        } else if (Object.prototype.toString.call(obj) === '[object Array]') {\n          if (n >= obj[0] && n <= obj[1]) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @private\n   * @param {*} number\n   * @return {Object}\n   */\n  calculateNumberDigits: function calculateNumberDigits(number) {\n    var numberToString = number.toString();\n    var parts = [];\n    var numberDigits = {};\n    var operandSymbol = {};\n    var integerPart, decimalPartLength, decimalPart;\n\n    if (numberToString.indexOf('.') !== -1) {\n      //decimal\n      parts = numberToString.split('.', 2);\n      numberDigits.integerPart = parseInt(parts[0], 10);\n      numberDigits.decimalPartLength = parts[1].length;\n      numberDigits.decimalPart = parseInt(parts[1], 10);\n      operandSymbol.n = parseFloat(number);\n      operandSymbol.i = numberDigits.integerPart;\n      operandSymbol.v = numberDigits.decimalPartLength;\n      operandSymbol.w = numberDigits.decimalPartLength;\n      operandSymbol.f = numberDigits.decimalPart;\n      operandSymbol.t = numberDigits.decimalPart;\n    } else {\n      numberDigits.integerPart = number;\n      numberDigits.decimalPartLength = 0;\n      numberDigits.decimalPart = 0;\n      operandSymbol.n = parseInt(number, 10);\n      operandSymbol.i = numberDigits.integerPart;\n      operandSymbol.v = 0;\n      operandSymbol.w = 0;\n      operandSymbol.f = 0;\n      operandSymbol.t = 0;\n    }\n\n    return operandSymbol;\n  },\n\n  /**\n   * @private\n   * @param {number|Object} n\n   * @param {Array.<number|Array.<number>>|Object} range\n   * @return {boolean}\n   */\n  matchRange: function matchRange(n, range) {\n    return IString._fncs.matchRangeContinuous(n, range);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  is: function is(rule, n) {\n    var left = IString._fncs.getValue(rule[0], n);\n\n    var right = IString._fncs.getValue(rule[1], n);\n\n    return left == right;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  isnot: function isnot(rule, n) {\n    return IString._fncs.getValue(rule[0], n) != IString._fncs.getValue(rule[1], n);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  inrange: function inrange(rule, n) {\n    if (typeof rule[0] === 'number') {\n      if (_typeof(n) === 'object') {\n        return IString._fncs.matchRange(n.n, rule);\n      }\n\n      return IString._fncs.matchRange(n, rule);\n    } else if (typeof rule[0] === 'undefined') {\n      var subrule = IString._fncs.firstPropRule(rule);\n\n      return IString._fncs[subrule](rule[subrule], n);\n    } else {\n      return IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n    }\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  notin: function notin(rule, n) {\n    return !IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  within: function within(rule, n) {\n    return IString._fncs.matchRangeContinuous(IString._fncs.getValue(rule[0], n), rule[1]);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {number}\n   */\n  mod: function mod(rule, n) {\n    return MathUtils.mod(IString._fncs.getValue(rule[0], n), IString._fncs.getValue(rule[1], n));\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {number}\n   */\n  n: function n(rule, _n) {\n    return _n;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  or: function or(rule, n) {\n    var ruleLength = rule.length;\n    var result, i;\n\n    for (i = 0; i < ruleLength; i++) {\n      result = IString._fncs.getValue(rule[i], n);\n\n      if (result) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  and: function and(rule, n) {\n    var ruleLength = rule.length;\n    var result, i;\n\n    for (i = 0; i < ruleLength; i++) {\n      result = IString._fncs.getValue(rule[i], n);\n\n      if (!result) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  eq: function eq(rule, n) {\n    var valueLeft = IString._fncs.getValue(rule[0], n);\n\n    var valueRight;\n\n    if (typeof rule[0] === 'string') {\n      if (_typeof(n) === 'object') {\n        valueRight = n[rule[0]];\n\n        if (typeof rule[1] === 'number') {\n          valueRight = IString._fncs.getValue(rule[1], n);\n        } else if (_typeof(rule[1]) === 'object' && IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n          valueRight = IString._fncs.getValue(rule[1], n);\n        }\n      }\n    } else {\n      if (IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n        // mod\n        valueRight = IString._fncs.getValue(rule[1], valueLeft);\n      } else {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      }\n    }\n\n    if (typeof valueRight === 'boolean') {\n      return valueRight ? true : false;\n    } else {\n      return valueLeft == valueRight ? true : false;\n    }\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  neq: function neq(rule, n) {\n    var valueLeft = IString._fncs.getValue(rule[0], n);\n\n    var valueRight;\n    var leftRange;\n    var rightRange;\n\n    if (typeof rule[0] === 'string') {\n      valueRight = n[rule[0]];\n\n      if (typeof rule[1] === 'number') {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      } else if (_typeof(rule[1]) === 'object') {\n        leftRange = rule[1][0];\n        rightRange = rule[1][1];\n\n        if (typeof leftRange === 'number' && typeof rightRange === 'number') {\n          if (valueLeft >= leftRange && valueRight <= rightRange) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }\n    } else {\n      if (IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n        // mod\n        valueRight = IString._fncs.getValue(rule[1], valueLeft);\n      } else {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      }\n    }\n\n    if (typeof valueRight === 'boolean') {\n      //mod\n      return valueRight ? false : true;\n    } else {\n      return valueLeft !== valueRight ? true : false;\n    }\n  }\n};\nIString.prototype = {\n  /**\n   * Return the length of this string in characters. This function defers to the regular\n   * Javascript string class in order to perform the length function. Please note that this\n   * method is a real method, whereas the length property of Javascript strings is\n   * implemented by native code and appears as a property.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"this is a string\");\n   * console.log(\"String is \" + str._length() + \" characters long.\");\n   * </pre>\n   * @private\n   */\n  _length: function _length() {\n    return this.str.length;\n  },\n\n  /**\n   * Format this string instance as a message, replacing the parameters with\n   * the given values.<p>\n   *\n   * The string can contain any text that a regular Javascript string can\n   * contain. Replacement parameters have the syntax:\n   *\n   * <pre>\n   * {name}\n   * </pre>\n   *\n   * Where \"name\" can be any string surrounded by curly brackets. The value of\n   * \"name\" is taken from the parameters argument.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"There are {num} objects.\");\n   * console.log(str.format({\n   *   num: 12\n   * });\n   * </pre>\n   *\n   * Would give the output:\n   *\n   * <pre>\n   * There are 12 objects.\n   * </pre>\n   *\n   * If a property is missing from the parameter block, the replacement\n   * parameter substring is left untouched in the string, and a different\n   * set of parameters may be applied a second time. This way, different\n   * parts of the code may format different parts of the message that they\n   * happen to know about.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"There are {num} objects in the {container}.\");\n   * console.log(str.format({\n   *   num: 12\n   * });\n   * </pre>\n   *\n   * Would give the output:<p>\n   *\n   * <pre>\n   * There are 12 objects in the {container}.\n   * </pre>\n   *\n   * The result can then be formatted again with a different parameter block that\n   * specifies a value for the container property.\n   *\n   * @param params a Javascript object containing values for the replacement\n   * parameters in the current string\n   * @return a new IString instance with as many replacement parameters filled\n   * out as possible with real values.\n   */\n  format: function format(params) {\n    var formatted = this.str;\n\n    if (params) {\n      var regex;\n\n      for (var p in params) {\n        if (typeof params[p] !== 'undefined') {\n          regex = new RegExp(\"\\{\" + p + \"\\}\", \"g\");\n          formatted = formatted.replace(regex, params[p]);\n        }\n      }\n    }\n\n    return formatted.toString();\n  },\n\n  /** @private */\n  _testChoice: function _testChoice(index, limit) {\n    var numberDigits = {};\n    var operandValue = {};\n\n    switch (_typeof(index)) {\n      case 'number':\n        operandValue = IString._fncs.calculateNumberDigits(index);\n\n        if (limit.substring(0, 2) === \"<=\") {\n          limit = parseFloat(limit.substring(2));\n          return operandValue.n <= limit;\n        } else if (limit.substring(0, 2) === \">=\") {\n          limit = parseFloat(limit.substring(2));\n          return operandValue.n >= limit;\n        } else if (limit.charAt(0) === \"<\") {\n          limit = parseFloat(limit.substring(1));\n          return operandValue.n < limit;\n        } else if (limit.charAt(0) === \">\") {\n          limit = parseFloat(limit.substring(1));\n          return operandValue.n > limit;\n        } else {\n          this.locale = this.locale || new Locale(this.localeSpec);\n\n          switch (limit) {\n            case \"zero\":\n            case \"one\":\n            case \"two\":\n            case \"few\":\n            case \"many\":\n              // CLDR locale-dependent number classes\n              var ruleset = ilib.data[\"plurals_\" + this.locale.getLanguage()];\n\n              if (ruleset) {\n                var rule = ruleset[limit];\n                return IString._fncs.getValue(rule, operandValue);\n              }\n\n              break;\n\n            case \"\":\n            case \"other\":\n              // matches anything\n              return true;\n\n            default:\n              var dash = limit.indexOf(\"-\");\n\n              if (dash !== -1) {\n                // range\n                var start = limit.substring(0, dash);\n                var end = limit.substring(dash + 1);\n                return operandValue.n >= parseInt(start, 10) && operandValue.n <= parseInt(end, 10);\n              } else {\n                return operandValue.n === parseInt(limit, 10);\n              }\n\n          }\n        }\n\n        break;\n\n      case 'boolean':\n        return limit === \"true\" && index === true || limit === \"false\" && index === false;\n\n      case 'string':\n        var regexp = new RegExp(limit, \"i\");\n        return regexp.test(index);\n\n      case 'object':\n        throw \"syntax error: formatChoice parameter for the argument index cannot be an object\";\n    }\n\n    return false;\n  },\n\n  /**\n   * Format a string as one of a choice of strings dependent on the value of\n   * a particular argument index or array of indices.<p>\n   *\n   * The syntax of the choice string is as follows. The string contains a\n   * series of choices separated by a vertical bar character \"|\". Each choice\n   * has a value or range of values to match followed by a hash character \"#\"\n   * followed by the string to use if the variable matches the criteria.<p>\n   *\n   * Example string:\n   *\n   * <pre>\n   * var num = 2;\n   * var str = new IString(\"0#There are no objects.|1#There is one object.|2#There are {number} objects.\");\n   * console.log(str.formatChoice(num, {\n   *   number: num\n   * }));\n   * </pre>\n   *\n   * Gives the output:\n   *\n   * <pre>\n   * \"There are 2 objects.\"\n   * </pre>\n   *\n   * The strings to format may contain replacement variables that will be formatted\n   * using the format() method above and the params argument as a source of values\n   * to use while formatting those variables.<p>\n   *\n   * If the criterion for a particular choice is empty, that choice will be used\n   * as the default one for use when none of the other choice's criteria match.<p>\n   *\n   * Example string:\n   *\n   * <pre>\n   * var num = 22;\n   * var str = new IString(\"0#There are no objects.|1#There is one object.|#There are {number} objects.\");\n   * console.log(str.formatChoice(num, {\n   *   number: num\n   * }));\n   * </pre>\n   *\n   * Gives the output:\n   *\n   * <pre>\n   * \"There are 22 objects.\"\n   * </pre>\n   *\n   * If multiple choice patterns can match a given argument index, the first one\n   * encountered in the string will be used. If no choice patterns match the\n   * argument index, then the default choice will be used. If there is no default\n   * choice defined, then this method will return an empty string.<p>\n   *\n   * <b>Special Syntax</b><p>\n   *\n   * For any choice format string, all of the patterns in the string should be\n   * of a single type: numeric, boolean, or string/regexp. The type of the\n   * patterns is determined by the type of the argument index parameter.<p>\n   *\n   * If the argument index is numeric, then some special syntax can be used\n   * in the patterns to match numeric ranges.<p>\n   *\n   * <ul>\n   * <li><i>&gt;x</i> - match any number that is greater than x\n   * <li><i>&gt;=x</i> - match any number that is greater than or equal to x\n   * <li><i>&lt;x</i> - match any number that is less than x\n   * <li><i>&lt;=x</i> - match any number that is less than or equal to x\n   * <li><i>start-end</i> - match any number in the range [start,end)\n   * <li><i>zero</i> - match any number in the class \"zero\". (See below for\n   * a description of number classes.)\n   * <li><i>one</i> - match any number in the class \"one\"\n   * <li><i>two</i> - match any number in the class \"two\"\n   * <li><i>few</i> - match any number in the class \"few\"\n   * <li><i>many</i> - match any number in the class \"many\"\n      * <li><i>other</i> - match any number in the other or default class\n   * </ul>\n   *\n   * A number class defines a set of numbers that receive a particular syntax\n   * in the strings. For example, in Slovenian, integers ending in the digit\n   * \"1\" are in the \"one\" class, including 1, 21, 31, ... 101, 111, etc.\n   * Similarly, integers ending in the digit \"2\" are in the \"two\" class.\n   * Integers ending in the digits \"3\" or \"4\" are in the \"few\" class, and\n   * every other integer is handled by the default string.<p>\n   *\n   * The definition of what numbers are included in a class is locale-dependent.\n   * They are defined in the data file plurals.json. If your string is in a\n   * different locale than the default for ilib, you should call the setLocale()\n   * method of the string instance before calling this method.<p>\n   *\n   * <b>Other Pattern Types</b><p>\n   *\n   * If the argument index is a boolean, the string values \"true\" and \"false\"\n   * may appear as the choice patterns.<p>\n   *\n   * If the argument index is of type string, then the choice patterns may contain\n   * regular expressions, or static strings as degenerate regexps.<p>\n   *\n   * <b>Multiple Indexes</b><p>\n   *\n   * If you have 2 or more indexes to format into a string, you can pass them as\n   * an array. When you do that, the patterns to match should be a comma-separate\n   * list of patterns as per the rules above.<p>\n   *\n      * Example string:\n      *\n      * <pre>\n      * var str = new IString(\"zero,zero#There are no objects on zero pages.|one,one#There is 1 object on 1 page.|other,one#There are {number} objects on 1 page.|#There are {number} objects on {pages} pages.\");\n      * var num = 4, pages = 1;\n      * console.log(str.formatChoice([num, pages], {\n      *   number: num,\n      *   pages: pages\n      * }));\n      * </pre>\n      *\n      * Gives the output:<p>\n      *\n      * <pre>\n      * \"There are 4 objects on 1 page.\"\n      * </pre>\n      *\n      * Note that when there is a single index, you would typically leave the pattern blank to\n      * indicate the default choice. When there are multiple indices, sometimes one of the\n      * patterns has to be the default case when the other is not. Rather than leaving one or\n      * more of the patterns blank with commas that look out-of-place in the middle of it, you\n      * can use the word \"other\" to indicate a match with the default or other choice. The above example\n      * shows the use of the \"other\" pattern. That said, you are allowed to leave the pattern\n      * blank if you so choose. In the example above, the pattern for the third string could\n      * easily have been written as \",one\" instead of \"other,one\" and the result will be the same.\n      *\n   * @param {*|Array.<*>} argIndex The index into the choice array of the current parameter,\n   * or an array of indices\n   * @param {Object} params The hash of parameter values that replace the replacement\n   * variables in the string\n   * @throws \"syntax error in choice format pattern: \" if there is a syntax error\n   * @return {string} the formatted string\n   */\n  formatChoice: function formatChoice(argIndex, params) {\n    var choices = this.str.split(\"|\");\n\n    var type = _typeof(argIndex);\n\n    var limits = [];\n    var strings = [];\n    var i;\n    var parts;\n    var limit;\n    var arg;\n    var result = undefined;\n    var defaultCase = \"\";\n\n    if (this.str.length === 0) {\n      // nothing to do\n      return \"\";\n    } // first parse all the choices\n\n\n    for (i = 0; i < choices.length; i++) {\n      parts = choices[i].split(\"#\");\n\n      if (parts.length > 2) {\n        limits[i] = parts[0];\n        parts = parts.shift();\n        strings[i] = parts.join(\"#\");\n      } else if (parts.length === 2) {\n        limits[i] = parts[0];\n        strings[i] = parts[1];\n      } else {\n        // syntax error\n        throw \"syntax error in choice format pattern: \" + choices[i];\n      }\n    }\n\n    var args = ilib.isArray(argIndex) ? argIndex : [argIndex]; // then apply the argument index (or indices)\n\n    for (i = 0; i < limits.length; i++) {\n      if (limits[i].length === 0) {\n        // this is default case\n        defaultCase = new IString(strings[i]);\n      } else {\n        var limitsArr = limits[i].indexOf(\",\") > -1 ? limits[i].split(\",\") : [limits[i]];\n        var applicable = true;\n\n        for (var j = 0; applicable && j < args.length && j < limitsArr.length; j++) {\n          applicable = this._testChoice(args[j], limitsArr[j]);\n        }\n\n        if (applicable) {\n          result = new IString(strings[i]);\n          i = limits.length;\n        }\n      }\n    }\n\n    if (!result) {\n      result = defaultCase || new IString(\"\");\n    }\n\n    result = result.format(params);\n    return result.toString();\n  },\n  // delegates\n\n  /**\n   * Same as String.toString()\n   * @return {string} this instance as regular Javascript string\n   */\n  toString: function toString() {\n    return this.str.toString();\n  },\n\n  /**\n   * Same as String.valueOf()\n   * @return {string} this instance as a regular Javascript string\n   */\n  valueOf: function valueOf() {\n    return this.str.valueOf();\n  },\n\n  /**\n   * Same as String.charAt()\n   * @param {number} index the index of the character being sought\n   * @return {IString} the character at the given index\n   */\n  charAt: function charAt(index) {\n    return new IString(this.str.charAt(index));\n  },\n\n  /**\n   * Same as String.charCodeAt(). This only reports on\n   * 2-byte UCS-2 Unicode values, and does not take into\n   * account supplementary characters encoded in UTF-16.\n   * If you would like to take account of those characters,\n   * use codePointAt() instead.\n   * @param {number} index the index of the character being sought\n   * @return {number} the character code of the character at the\n   * given index in the string\n   */\n  charCodeAt: function charCodeAt(index) {\n    return this.str.charCodeAt(index);\n  },\n\n  /**\n   * Same as String.concat()\n   * @param {string} strings strings to concatenate to the current one\n   * @return {IString} a concatenation of the given strings\n   */\n  concat: function concat(strings) {\n    return new IString(this.str.concat(strings));\n  },\n\n  /**\n   * Same as String.indexOf()\n   * @param {string} searchValue string to search for\n   * @param {number} start index into the string to start searching, or\n   * undefined to search the entire string\n   * @return {number} index into the string of the string being sought,\n   * or -1 if the string is not found\n   */\n  indexOf: function indexOf(searchValue, start) {\n    return this.str.indexOf(searchValue, start);\n  },\n\n  /**\n   * Same as String.lastIndexOf()\n   * @param {string} searchValue string to search for\n   * @param {number} start index into the string to start searching, or\n   * undefined to search the entire string\n   * @return {number} index into the string of the string being sought,\n   * or -1 if the string is not found\n   */\n  lastIndexOf: function lastIndexOf(searchValue, start) {\n    return this.str.lastIndexOf(searchValue, start);\n  },\n\n  /**\n   * Same as String.match()\n   * @param {string} regexp the regular expression to match\n   * @return {Array.<string>} an array of matches\n   */\n  match: function match(regexp) {\n    return this.str.match(regexp);\n  },\n\n  /**\n   * Same as String.replace()\n   * @param {string} searchValue a regular expression to search for\n   * @param {string} newValue the string to replace the matches with\n   * @return {IString} a new string with all the matches replaced\n   * with the new value\n   */\n  replace: function replace(searchValue, newValue) {\n    return new IString(this.str.replace(searchValue, newValue));\n  },\n\n  /**\n   * Same as String.search()\n   * @param {string} regexp the regular expression to search for\n   * @return {number} position of the match, or -1 for no match\n   */\n  search: function search(regexp) {\n    return this.str.search(regexp);\n  },\n\n  /**\n   * Same as String.slice()\n   * @param {number} start first character to include in the string\n   * @param {number} end include all characters up to, but not including\n   * the end character\n   * @return {IString} a slice of the current string\n   */\n  slice: function slice(start, end) {\n    return new IString(this.str.slice(start, end));\n  },\n\n  /**\n   * Same as String.split()\n   * @param {string} separator regular expression to match to find\n   * separations between the parts of the text\n   * @param {number} limit maximum number of items in the final\n   * output array. Any items beyond that limit will be ignored.\n   * @return {Array.<string>} the parts of the current string split\n   * by the separator\n   */\n  split: function split(separator, limit) {\n    return this.str.split(separator, limit);\n  },\n\n  /**\n   * Same as String.substr()\n   * @param {number} start the index of the character that should\n   * begin the returned substring\n   * @param {number} length the number of characters to return after\n   * the start character.\n   * @return {IString} the requested substring\n   */\n  substr: function substr(start, length) {\n    var plat = ilib._getPlatform();\n\n    if (plat === \"qt\" || plat === \"rhino\" || plat === \"trireme\") {\n      // qt and rhino have a broken implementation of substr(), so\n      // work around it\n      if (typeof length === \"undefined\") {\n        length = this.str.length - start;\n      }\n    }\n\n    return new IString(this.str.substr(start, length));\n  },\n\n  /**\n   * Same as String.substring()\n   * @param {number} from the index of the character that should\n   * begin the returned substring\n   * @param {number} to the index where to stop the extraction. If\n   * omitted, extracts the rest of the string\n   * @return {IString} the requested substring\n   */\n  substring: function substring(from, to) {\n    return this.str.substring(from, to);\n  },\n\n  /**\n   * Same as String.toLowerCase(). Note that this method is\n   * not locale-sensitive.\n   * @return {IString} a string with the first character\n   * lower-cased\n   */\n  toLowerCase: function toLowerCase() {\n    return this.str.toLowerCase();\n  },\n\n  /**\n   * Same as String.toUpperCase(). Note that this method is\n   * not locale-sensitive. Use toLocaleUpperCase() instead\n   * to get locale-sensitive behaviour.\n   * @return {IString} a string with the first character\n   * upper-cased\n   */\n  toUpperCase: function toUpperCase() {\n    return this.str.toUpperCase();\n  },\n\n  /**\n   * Convert the character or the surrogate pair at the given\n   * index into the string to a Unicode UCS-4 code point.\n   * @protected\n   * @param {number} index index into the string\n   * @return {number} code point of the character at the\n   * given index into the string\n   */\n  _toCodePoint: function _toCodePoint(index) {\n    return IString.toCodePoint(this.str, index);\n  },\n\n  /**\n   * Call the callback with each character in the string one at\n   * a time, taking care to step through the surrogate pairs in\n   * the UTF-16 encoding properly.<p>\n   *\n   * The standard Javascript String's charAt() method only\n   * returns a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index to charAt() is pointing to a low- or\n   * high-surrogate character,\n   * it will return the surrogate character rather\n   * than the the character\n   * in the supplementary planes that the two surrogates together\n   * encode. This function will call the callback with the full\n   * character, making sure to join two\n   * surrogates into one character in the supplementary planes\n   * where necessary.<p>\n   *\n   * @param {function(string)} callback a callback function to call with each\n   * full character in the current string\n   */\n  forEach: function forEach(callback) {\n    if (typeof callback === 'function') {\n      var it = this.charIterator();\n\n      while (it.hasNext()) {\n        callback(it.next());\n      }\n    }\n  },\n\n  /**\n   * Call the callback with each numeric code point in the string one at\n   * a time, taking care to step through the surrogate pairs in\n   * the UTF-16 encoding properly.<p>\n   *\n   * The standard Javascript String's charCodeAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index to charCodeAt() is pointing to a low- or\n   * high-surrogate character,\n   * it will return the code point of the surrogate character rather\n   * than the code point of the character\n   * in the supplementary planes that the two surrogates together\n   * encode. This function will call the callback with the full\n   * code point of each character, making sure to join two\n   * surrogates into one code point in the supplementary planes.<p>\n   *\n   * @param {function(string)} callback a callback function to call with each\n   * code point in the current string\n   */\n  forEachCodePoint: function forEachCodePoint(callback) {\n    if (typeof callback === 'function') {\n      var it = this.iterator();\n\n      while (it.hasNext()) {\n        callback(it.next());\n      }\n    }\n  },\n\n  /**\n   * Return an iterator that will step through all of the characters\n   * in the string one at a time and return their code points, taking\n   * care to step through the surrogate pairs in UTF-16 encoding\n   * properly.<p>\n   *\n   * The standard Javascript String's charCodeAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index is pointing to a low- or high-surrogate character,\n   * it will return a code point of the surrogate character rather\n   * than the code point of the character\n   * in the supplementary planes that the two surrogates together\n   * encode.<p>\n   *\n   * The iterator instance returned has two methods, hasNext() which\n   * returns true if the iterator has more code points to iterate through,\n   * and next() which returns the next code point as a number.<p>\n   *\n   * @return {Object} an iterator\n   * that iterates through all the code points in the string\n   */\n  iterator: function iterator() {\n    /**\n     * @constructor\n     */\n    function _iterator(istring) {\n      this.index = 0;\n\n      this.hasNext = function () {\n        return this.index < istring.str.length;\n      };\n\n      this.next = function () {\n        if (this.index < istring.str.length) {\n          var num = istring._toCodePoint(this.index);\n\n          this.index += num > 0xFFFF ? 2 : 1;\n        } else {\n          num = -1;\n        }\n\n        return num;\n      };\n    }\n\n    ;\n    return new _iterator(this);\n  },\n\n  /**\n   * Return an iterator that will step through all of the characters\n   * in the string one at a time, taking\n   * care to step through the surrogate pairs in UTF-16 encoding\n   * properly.<p>\n   *\n   * The standard Javascript String's charAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index is pointing to a low- or high-surrogate character,\n   * it will return that surrogate character rather\n   * than the surrogate pair which represents a character\n   * in the supplementary planes.<p>\n   *\n   * The iterator instance returned has two methods, hasNext() which\n   * returns true if the iterator has more characters to iterate through,\n   * and next() which returns the next character.<p>\n   *\n   * @return {Object} an iterator\n   * that iterates through all the characters in the string\n   */\n  charIterator: function charIterator() {\n    /**\n     * @constructor\n     */\n    function _chiterator(istring) {\n      this.index = 0;\n\n      this.hasNext = function () {\n        return this.index < istring.str.length;\n      };\n\n      this.next = function () {\n        var ch;\n\n        if (this.index < istring.str.length) {\n          ch = istring.str.charAt(this.index);\n\n          if (IString._isSurrogate(ch) && this.index + 1 < istring.str.length && IString._isSurrogate(istring.str.charAt(this.index + 1))) {\n            this.index++;\n            ch += istring.str.charAt(this.index);\n          }\n\n          this.index++;\n        }\n\n        return ch;\n      };\n    }\n\n    ;\n    return new _chiterator(this);\n  },\n\n  /**\n   * Return the code point at the given index when the string is viewed\n   * as an array of code points. If the index is beyond the end of the\n   * array of code points or if the index is negative, -1 is returned.\n   * @param {number} index index of the code point\n   * @return {number} code point of the character at the given index into\n   * the string\n   */\n  codePointAt: function codePointAt(index) {\n    if (index < 0) {\n      return -1;\n    }\n\n    var count,\n        it = this.iterator(),\n        ch;\n\n    for (count = index; count >= 0 && it.hasNext(); count--) {\n      ch = it.next();\n    }\n\n    return count < 0 ? ch : -1;\n  },\n\n  /**\n   * Set the locale to use when processing choice formats. The locale\n   * affects how number classes are interpretted. In some cultures,\n   * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n   * in yet others, \"few\" maps to \"any integer that ends in the digits\n   * 3 or 4\".\n   * @param {Locale|string} locale locale to use when processing choice\n   * formats with this string\n   * @param {boolean=} sync [optional] whether to load the locale data synchronously\n   * or not\n   * @param {Object=} loadParams [optional] parameters to pass to the loader function\n   * @param {function(*)=} onLoad [optional] function to call when the loading is done\n   */\n  setLocale: function setLocale(locale, sync, loadParams, onLoad) {\n    if (_typeof(locale) === 'object') {\n      this.locale = locale;\n    } else {\n      this.localeSpec = locale;\n      this.locale = new Locale(locale);\n    }\n\n    IString.loadPlurals(typeof sync !== 'undefined' ? sync : true, this.locale, loadParams, onLoad);\n  },\n\n  /**\n   * Return the locale to use when processing choice formats. The locale\n   * affects how number classes are interpretted. In some cultures,\n   * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n   * in yet others, \"few\" maps to \"any integer that ends in the digits\n   * 3 or 4\".\n   * @return {string} localespec to use when processing choice\n   * formats with this string\n   */\n  getLocale: function getLocale() {\n    return (this.locale ? this.locale.getSpec() : this.localeSpec) || ilib.getLocale();\n  },\n\n  /**\n   * Return the number of code points in this string. This may be different\n   * than the number of characters, as the UTF-16 encoding that Javascript\n   * uses for its basis returns surrogate pairs separately. Two 2-byte\n   * surrogate characters together make up one character/code point in\n   * the supplementary character planes. If your string contains no\n   * characters in the supplementary planes, this method will return the\n   * same thing as the length() method.\n   * @return {number} the number of code points in this string\n   */\n  codePointLength: function codePointLength() {\n    if (this.cpLength === -1) {\n      var it = this.iterator();\n      this.cpLength = 0;\n\n      while (it.hasNext()) {\n        this.cpLength++;\n        it.next();\n      }\n\n      ;\n    }\n\n    return this.cpLength;\n  }\n};\nmodule.exports = IString;","map":{"version":3,"sources":["/home/cdi/SteApp/node_modules/@enact/i18n/ilib/lib/IString.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","ilib","require","Utils","MathUtils","Locale","IString","string","str","toString","String","length","cpLength","localeSpec","getLocale","_isSurrogate","ch","n","charCodeAt","plurals_default","fromCodePoint","codepoint","fromCharCode","high","Math","floor","low","toCodePoint","index","code","loadPlurals","sync","locale","loadParams","onLoad","loc","spec","getLanguage","data","loadData","name","object","callback","bind","plurals","cache","_fncs","firstProp","p","undefined","firstPropRule","Object","call","getValue","subrule","matchRangeContinuous","range","num","calculateNumberDigits","number","numberToString","parts","numberDigits","operandSymbol","integerPart","decimalPartLength","decimalPart","indexOf","split","parseInt","parseFloat","i","v","w","f","t","matchRange","is","rule","left","right","isnot","inrange","notin","within","mod","_n","or","ruleLength","result","and","eq","valueLeft","valueRight","neq","leftRange","rightRange","_length","format","params","formatted","regex","RegExp","replace","_testChoice","limit","operandValue","substring","charAt","ruleset","dash","start","end","regexp","test","formatChoice","argIndex","choices","type","limits","strings","arg","defaultCase","shift","join","args","isArray","limitsArr","applicable","j","valueOf","concat","searchValue","lastIndexOf","match","newValue","search","slice","separator","substr","plat","_getPlatform","from","to","toLowerCase","toUpperCase","_toCodePoint","forEach","it","charIterator","hasNext","next","forEachCodePoint","_iterator","istring","_chiterator","codePointAt","count","setLocale","getSpec","codePointLength","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * IString.js - ilib string subclass definition\n *\n * Copyright Â© 2012-2015, 2018, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js Utils.js Locale.js MathUtils.js\n// !data plurals\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n/**\n * @class\n * Create a new ilib string instance. This string inherits from and\n * extends the Javascript String class. It can be\n * used almost anywhere that a normal Javascript string is used, though in\n * some instances you will need to call the {@link #toString} method when\n * a built-in Javascript string is needed. The formatting methods are\n * methods that are not in the intrinsic String class and are most useful\n * when localizing strings in an app or web site in combination with\n * the ResBundle class.<p>\n *\n * This class is named IString (\"ilib string\") so as not to conflict with the\n * built-in Javascript String class.\n *\n * @constructor\n * @param {string|IString=} string initialize this instance with this string\n */\n\n\nvar IString = function IString(string) {\n  if (_typeof(string) === 'object') {\n    if (string instanceof IString) {\n      this.str = string.str;\n    } else {\n      this.str = string.toString();\n    }\n  } else if (typeof string === 'string') {\n    this.str = new String(string);\n  } else {\n    this.str = \"\";\n  }\n\n  this.length = this.str.length;\n  this.cpLength = -1;\n  this.localeSpec = ilib.getLocale();\n};\n/**\n * Return true if the given character is a Unicode surrogate character,\n * either high or low.\n *\n * @private\n * @static\n * @param {string} ch character to check\n * @return {boolean} true if the character is a surrogate\n */\n\n\nIString._isSurrogate = function (ch) {\n  var n = ch.charCodeAt(0);\n  return n >= 0xDC00 && n <= 0xDFFF || n >= 0xD800 && n <= 0xDBFF;\n}; // build in the English rule\n\n\nIString.plurals_default = {\n  \"one\": {\n    \"and\": [{\n      \"eq\": [\"i\", 1]\n    }, {\n      \"eq\": [\"v\", 0]\n    }]\n  }\n};\n/**\n * Convert a UCS-4 code point to a Javascript string. The codepoint can be any valid\n * UCS-4 Unicode character, including supplementary characters. Standard Javascript\n * only supports supplementary characters using the UTF-16 encoding, which has\n * values in the range 0x0000-0xFFFF. String.fromCharCode() will only\n * give you a string containing 16-bit characters, and will not properly convert\n * the code point for a supplementary character (which has a value > 0xFFFF) into\n * two UTF-16 surrogate characters. Instead, it will just just give you whatever\n * single character happens to be the same as your code point modulo 0x10000, which\n * is almost never what you want.<p>\n *\n * Similarly, that means if you use String.charCodeAt()\n * you will only retrieve a 16-bit value, which may possibly be a single\n * surrogate character that is part of a surrogate pair representing a character\n * in the supplementary plane. It will not give you a code point. Use\n * IString.codePointAt() to access code points in a string, or use\n * an iterator to walk through the code points in a string.\n *\n * @static\n * @param {number} codepoint UCS-4 code point to convert to a character\n * @return {string} a string containing the character represented by the codepoint\n */\n\nIString.fromCodePoint = function (codepoint) {\n  if (codepoint < 0x10000) {\n    return String.fromCharCode(codepoint);\n  } else {\n    var high = Math.floor(codepoint / 0x10000) - 1;\n    var low = codepoint & 0xFFFF;\n    return String.fromCharCode(0xD800 | (high & 0x000F) << 6 | (low & 0xFC00) >> 10) + String.fromCharCode(0xDC00 | low & 0x3FF);\n  }\n};\n/**\n * Convert the character or the surrogate pair at the given\n * index into the intrinsic Javascript string to a Unicode\n * UCS-4 code point.\n *\n * @static\n * @param {string} str string to get the code point from\n * @param {number} index index into the string\n * @return {number} code point of the character at the\n * given index into the string\n */\n\n\nIString.toCodePoint = function (str, index) {\n  if (!str || str.length === 0) {\n    return -1;\n  }\n\n  var code = -1,\n      high = str.charCodeAt(index);\n\n  if (high >= 0xD800 && high <= 0xDBFF) {\n    if (str.length > index + 1) {\n      var low = str.charCodeAt(index + 1);\n\n      if (low >= 0xDC00 && low <= 0xDFFF) {\n        code = ((high & 0x3C0) >> 6) + 1 << 16 | ((high & 0x3F) << 10 | low & 0x3FF);\n      }\n    }\n  } else {\n    code = high;\n  }\n\n  return code;\n};\n/**\n * Load the plural the definitions of plurals for the locale.\n * @param {boolean=} sync\n * @param {Locale|string=} locale\n * @param {Object=} loadParams\n * @param {function(*)=} onLoad\n */\n\n\nIString.loadPlurals = function (sync, locale, loadParams, onLoad) {\n  var loc;\n\n  if (locale) {\n    loc = typeof locale === 'string' ? new Locale(locale) : locale;\n  } else {\n    loc = new Locale(ilib.getLocale());\n  }\n\n  var spec = loc.getLanguage();\n\n  if (!ilib.data[\"plurals_\" + spec]) {\n    Utils.loadData({\n      name: \"plurals.json\",\n      object: \"IString\",\n      locale: loc,\n      sync: sync,\n      loadParams: loadParams,\n      callback: ilib.bind(this, function (plurals) {\n        if (!plurals) {\n          ilib.data.cache.IString[spec] = IString.plurals_default;\n        }\n\n        ilib.data[\"plurals_\" + spec] = plurals || IString.plurals_default;\n\n        if (onLoad && typeof onLoad === 'function') {\n          onLoad(ilib.data[\"plurals_\" + spec]);\n        }\n      })\n    });\n  } else {\n    if (onLoad && typeof onLoad === 'function') {\n      onLoad(ilib.data[\"plurals_\" + spec]);\n    }\n  }\n};\n/**\n * @private\n * @static\n */\n\n\nIString._fncs = {\n  /**\n   * @private\n   * @param {Object} obj\n   * @return {string|undefined}\n   */\n  firstProp: function firstProp(obj) {\n    for (var p in obj) {\n      if (p && obj[p]) {\n        return p;\n      }\n    }\n\n    return undefined; // should never get here\n  },\n\n  /**\n   * @private\n   * @param {Object} obj\n   * @return {string|undefined}\n   */\n  firstPropRule: function firstPropRule(obj) {\n    if (Object.prototype.toString.call(obj) === '[object Array]') {\n      return \"inrange\";\n    } else if (Object.prototype.toString.call(obj) === '[object Object]') {\n      for (var p in obj) {\n        if (p && obj[p]) {\n          return p;\n        }\n      }\n    }\n\n    return undefined; // should never get here\n  },\n\n  /**\n   * @private\n   * @param {Object} obj\n   * @param {number|Object} n\n   * @return {?}\n   */\n  getValue: function getValue(obj, n) {\n    if (_typeof(obj) === 'object') {\n      var subrule = IString._fncs.firstPropRule(obj);\n\n      if (subrule === \"inrange\") {\n        return IString._fncs[subrule](obj, n);\n      }\n\n      return IString._fncs[subrule](obj[subrule], n);\n    } else if (typeof obj === 'string') {\n      if (_typeof(n) === 'object') {\n        return n[obj];\n      }\n\n      return n;\n    } else {\n      return obj;\n    }\n  },\n\n  /**\n   * @private\n   * @param {number|Object} n\n   * @param {Array.<number|Array.<number>>|Object} range\n   * @return {boolean}\n   */\n  matchRangeContinuous: function matchRangeContinuous(n, range) {\n    for (var num in range) {\n      if (typeof num !== 'undefined' && typeof range[num] !== 'undefined') {\n        var obj = range[num];\n\n        if (typeof obj === 'number') {\n          if (n === range[num]) {\n            return true;\n          } else if (n >= range[0] && n <= range[1]) {\n            return true;\n          }\n        } else if (Object.prototype.toString.call(obj) === '[object Array]') {\n          if (n >= obj[0] && n <= obj[1]) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @private\n   * @param {*} number\n   * @return {Object}\n   */\n  calculateNumberDigits: function calculateNumberDigits(number) {\n    var numberToString = number.toString();\n    var parts = [];\n    var numberDigits = {};\n    var operandSymbol = {};\n    var integerPart, decimalPartLength, decimalPart;\n\n    if (numberToString.indexOf('.') !== -1) {\n      //decimal\n      parts = numberToString.split('.', 2);\n      numberDigits.integerPart = parseInt(parts[0], 10);\n      numberDigits.decimalPartLength = parts[1].length;\n      numberDigits.decimalPart = parseInt(parts[1], 10);\n      operandSymbol.n = parseFloat(number);\n      operandSymbol.i = numberDigits.integerPart;\n      operandSymbol.v = numberDigits.decimalPartLength;\n      operandSymbol.w = numberDigits.decimalPartLength;\n      operandSymbol.f = numberDigits.decimalPart;\n      operandSymbol.t = numberDigits.decimalPart;\n    } else {\n      numberDigits.integerPart = number;\n      numberDigits.decimalPartLength = 0;\n      numberDigits.decimalPart = 0;\n      operandSymbol.n = parseInt(number, 10);\n      operandSymbol.i = numberDigits.integerPart;\n      operandSymbol.v = 0;\n      operandSymbol.w = 0;\n      operandSymbol.f = 0;\n      operandSymbol.t = 0;\n    }\n\n    return operandSymbol;\n  },\n\n  /**\n   * @private\n   * @param {number|Object} n\n   * @param {Array.<number|Array.<number>>|Object} range\n   * @return {boolean}\n   */\n  matchRange: function matchRange(n, range) {\n    return IString._fncs.matchRangeContinuous(n, range);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  is: function is(rule, n) {\n    var left = IString._fncs.getValue(rule[0], n);\n\n    var right = IString._fncs.getValue(rule[1], n);\n\n    return left == right;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  isnot: function isnot(rule, n) {\n    return IString._fncs.getValue(rule[0], n) != IString._fncs.getValue(rule[1], n);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  inrange: function inrange(rule, n) {\n    if (typeof rule[0] === 'number') {\n      if (_typeof(n) === 'object') {\n        return IString._fncs.matchRange(n.n, rule);\n      }\n\n      return IString._fncs.matchRange(n, rule);\n    } else if (typeof rule[0] === 'undefined') {\n      var subrule = IString._fncs.firstPropRule(rule);\n\n      return IString._fncs[subrule](rule[subrule], n);\n    } else {\n      return IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n    }\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  notin: function notin(rule, n) {\n    return !IString._fncs.matchRange(IString._fncs.getValue(rule[0], n), rule[1]);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {boolean}\n   */\n  within: function within(rule, n) {\n    return IString._fncs.matchRangeContinuous(IString._fncs.getValue(rule[0], n), rule[1]);\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {number}\n   */\n  mod: function mod(rule, n) {\n    return MathUtils.mod(IString._fncs.getValue(rule[0], n), IString._fncs.getValue(rule[1], n));\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number} n\n   * @return {number}\n   */\n  n: function n(rule, _n) {\n    return _n;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  or: function or(rule, n) {\n    var ruleLength = rule.length;\n    var result, i;\n\n    for (i = 0; i < ruleLength; i++) {\n      result = IString._fncs.getValue(rule[i], n);\n\n      if (result) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  and: function and(rule, n) {\n    var ruleLength = rule.length;\n    var result, i;\n\n    for (i = 0; i < ruleLength; i++) {\n      result = IString._fncs.getValue(rule[i], n);\n\n      if (!result) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  eq: function eq(rule, n) {\n    var valueLeft = IString._fncs.getValue(rule[0], n);\n\n    var valueRight;\n\n    if (typeof rule[0] === 'string') {\n      if (_typeof(n) === 'object') {\n        valueRight = n[rule[0]];\n\n        if (typeof rule[1] === 'number') {\n          valueRight = IString._fncs.getValue(rule[1], n);\n        } else if (_typeof(rule[1]) === 'object' && IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n          valueRight = IString._fncs.getValue(rule[1], n);\n        }\n      }\n    } else {\n      if (IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n        // mod\n        valueRight = IString._fncs.getValue(rule[1], valueLeft);\n      } else {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      }\n    }\n\n    if (typeof valueRight === 'boolean') {\n      return valueRight ? true : false;\n    } else {\n      return valueLeft == valueRight ? true : false;\n    }\n  },\n\n  /**\n   * @private\n   * @param {Object} rule\n   * @param {number|Object} n\n   * @return {boolean}\n   */\n  neq: function neq(rule, n) {\n    var valueLeft = IString._fncs.getValue(rule[0], n);\n\n    var valueRight;\n    var leftRange;\n    var rightRange;\n\n    if (typeof rule[0] === 'string') {\n      valueRight = n[rule[0]];\n\n      if (typeof rule[1] === 'number') {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      } else if (_typeof(rule[1]) === 'object') {\n        leftRange = rule[1][0];\n        rightRange = rule[1][1];\n\n        if (typeof leftRange === 'number' && typeof rightRange === 'number') {\n          if (valueLeft >= leftRange && valueRight <= rightRange) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }\n    } else {\n      if (IString._fncs.firstPropRule(rule[1]) === \"inrange\") {\n        // mod\n        valueRight = IString._fncs.getValue(rule[1], valueLeft);\n      } else {\n        valueRight = IString._fncs.getValue(rule[1], n);\n      }\n    }\n\n    if (typeof valueRight === 'boolean') {\n      //mod\n      return valueRight ? false : true;\n    } else {\n      return valueLeft !== valueRight ? true : false;\n    }\n  }\n};\nIString.prototype = {\n  /**\n   * Return the length of this string in characters. This function defers to the regular\n   * Javascript string class in order to perform the length function. Please note that this\n   * method is a real method, whereas the length property of Javascript strings is\n   * implemented by native code and appears as a property.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"this is a string\");\n   * console.log(\"String is \" + str._length() + \" characters long.\");\n   * </pre>\n   * @private\n   */\n  _length: function _length() {\n    return this.str.length;\n  },\n\n  /**\n   * Format this string instance as a message, replacing the parameters with\n   * the given values.<p>\n   *\n   * The string can contain any text that a regular Javascript string can\n   * contain. Replacement parameters have the syntax:\n   *\n   * <pre>\n   * {name}\n   * </pre>\n   *\n   * Where \"name\" can be any string surrounded by curly brackets. The value of\n   * \"name\" is taken from the parameters argument.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"There are {num} objects.\");\n   * console.log(str.format({\n   *   num: 12\n   * });\n   * </pre>\n   *\n   * Would give the output:\n   *\n   * <pre>\n   * There are 12 objects.\n   * </pre>\n   *\n   * If a property is missing from the parameter block, the replacement\n   * parameter substring is left untouched in the string, and a different\n   * set of parameters may be applied a second time. This way, different\n   * parts of the code may format different parts of the message that they\n   * happen to know about.<p>\n   *\n   * Example:\n   *\n   * <pre>\n   * var str = new IString(\"There are {num} objects in the {container}.\");\n   * console.log(str.format({\n   *   num: 12\n   * });\n   * </pre>\n   *\n   * Would give the output:<p>\n   *\n   * <pre>\n   * There are 12 objects in the {container}.\n   * </pre>\n   *\n   * The result can then be formatted again with a different parameter block that\n   * specifies a value for the container property.\n   *\n   * @param params a Javascript object containing values for the replacement\n   * parameters in the current string\n   * @return a new IString instance with as many replacement parameters filled\n   * out as possible with real values.\n   */\n  format: function format(params) {\n    var formatted = this.str;\n\n    if (params) {\n      var regex;\n\n      for (var p in params) {\n        if (typeof params[p] !== 'undefined') {\n          regex = new RegExp(\"\\{\" + p + \"\\}\", \"g\");\n          formatted = formatted.replace(regex, params[p]);\n        }\n      }\n    }\n\n    return formatted.toString();\n  },\n\n  /** @private */\n  _testChoice: function _testChoice(index, limit) {\n    var numberDigits = {};\n    var operandValue = {};\n\n    switch (_typeof(index)) {\n      case 'number':\n        operandValue = IString._fncs.calculateNumberDigits(index);\n\n        if (limit.substring(0, 2) === \"<=\") {\n          limit = parseFloat(limit.substring(2));\n          return operandValue.n <= limit;\n        } else if (limit.substring(0, 2) === \">=\") {\n          limit = parseFloat(limit.substring(2));\n          return operandValue.n >= limit;\n        } else if (limit.charAt(0) === \"<\") {\n          limit = parseFloat(limit.substring(1));\n          return operandValue.n < limit;\n        } else if (limit.charAt(0) === \">\") {\n          limit = parseFloat(limit.substring(1));\n          return operandValue.n > limit;\n        } else {\n          this.locale = this.locale || new Locale(this.localeSpec);\n\n          switch (limit) {\n            case \"zero\":\n            case \"one\":\n            case \"two\":\n            case \"few\":\n            case \"many\":\n              // CLDR locale-dependent number classes\n              var ruleset = ilib.data[\"plurals_\" + this.locale.getLanguage()];\n\n              if (ruleset) {\n                var rule = ruleset[limit];\n                return IString._fncs.getValue(rule, operandValue);\n              }\n\n              break;\n\n            case \"\":\n            case \"other\":\n              // matches anything\n              return true;\n\n            default:\n              var dash = limit.indexOf(\"-\");\n\n              if (dash !== -1) {\n                // range\n                var start = limit.substring(0, dash);\n                var end = limit.substring(dash + 1);\n                return operandValue.n >= parseInt(start, 10) && operandValue.n <= parseInt(end, 10);\n              } else {\n                return operandValue.n === parseInt(limit, 10);\n              }\n\n          }\n        }\n\n        break;\n\n      case 'boolean':\n        return limit === \"true\" && index === true || limit === \"false\" && index === false;\n\n      case 'string':\n        var regexp = new RegExp(limit, \"i\");\n        return regexp.test(index);\n\n      case 'object':\n        throw \"syntax error: formatChoice parameter for the argument index cannot be an object\";\n    }\n\n    return false;\n  },\n\n  /**\n   * Format a string as one of a choice of strings dependent on the value of\n   * a particular argument index or array of indices.<p>\n   *\n   * The syntax of the choice string is as follows. The string contains a\n   * series of choices separated by a vertical bar character \"|\". Each choice\n   * has a value or range of values to match followed by a hash character \"#\"\n   * followed by the string to use if the variable matches the criteria.<p>\n   *\n   * Example string:\n   *\n   * <pre>\n   * var num = 2;\n   * var str = new IString(\"0#There are no objects.|1#There is one object.|2#There are {number} objects.\");\n   * console.log(str.formatChoice(num, {\n   *   number: num\n   * }));\n   * </pre>\n   *\n   * Gives the output:\n   *\n   * <pre>\n   * \"There are 2 objects.\"\n   * </pre>\n   *\n   * The strings to format may contain replacement variables that will be formatted\n   * using the format() method above and the params argument as a source of values\n   * to use while formatting those variables.<p>\n   *\n   * If the criterion for a particular choice is empty, that choice will be used\n   * as the default one for use when none of the other choice's criteria match.<p>\n   *\n   * Example string:\n   *\n   * <pre>\n   * var num = 22;\n   * var str = new IString(\"0#There are no objects.|1#There is one object.|#There are {number} objects.\");\n   * console.log(str.formatChoice(num, {\n   *   number: num\n   * }));\n   * </pre>\n   *\n   * Gives the output:\n   *\n   * <pre>\n   * \"There are 22 objects.\"\n   * </pre>\n   *\n   * If multiple choice patterns can match a given argument index, the first one\n   * encountered in the string will be used. If no choice patterns match the\n   * argument index, then the default choice will be used. If there is no default\n   * choice defined, then this method will return an empty string.<p>\n   *\n   * <b>Special Syntax</b><p>\n   *\n   * For any choice format string, all of the patterns in the string should be\n   * of a single type: numeric, boolean, or string/regexp. The type of the\n   * patterns is determined by the type of the argument index parameter.<p>\n   *\n   * If the argument index is numeric, then some special syntax can be used\n   * in the patterns to match numeric ranges.<p>\n   *\n   * <ul>\n   * <li><i>&gt;x</i> - match any number that is greater than x\n   * <li><i>&gt;=x</i> - match any number that is greater than or equal to x\n   * <li><i>&lt;x</i> - match any number that is less than x\n   * <li><i>&lt;=x</i> - match any number that is less than or equal to x\n   * <li><i>start-end</i> - match any number in the range [start,end)\n   * <li><i>zero</i> - match any number in the class \"zero\". (See below for\n   * a description of number classes.)\n   * <li><i>one</i> - match any number in the class \"one\"\n   * <li><i>two</i> - match any number in the class \"two\"\n   * <li><i>few</i> - match any number in the class \"few\"\n   * <li><i>many</i> - match any number in the class \"many\"\n      * <li><i>other</i> - match any number in the other or default class\n   * </ul>\n   *\n   * A number class defines a set of numbers that receive a particular syntax\n   * in the strings. For example, in Slovenian, integers ending in the digit\n   * \"1\" are in the \"one\" class, including 1, 21, 31, ... 101, 111, etc.\n   * Similarly, integers ending in the digit \"2\" are in the \"two\" class.\n   * Integers ending in the digits \"3\" or \"4\" are in the \"few\" class, and\n   * every other integer is handled by the default string.<p>\n   *\n   * The definition of what numbers are included in a class is locale-dependent.\n   * They are defined in the data file plurals.json. If your string is in a\n   * different locale than the default for ilib, you should call the setLocale()\n   * method of the string instance before calling this method.<p>\n   *\n   * <b>Other Pattern Types</b><p>\n   *\n   * If the argument index is a boolean, the string values \"true\" and \"false\"\n   * may appear as the choice patterns.<p>\n   *\n   * If the argument index is of type string, then the choice patterns may contain\n   * regular expressions, or static strings as degenerate regexps.<p>\n   *\n   * <b>Multiple Indexes</b><p>\n   *\n   * If you have 2 or more indexes to format into a string, you can pass them as\n   * an array. When you do that, the patterns to match should be a comma-separate\n   * list of patterns as per the rules above.<p>\n   *\n      * Example string:\n      *\n      * <pre>\n      * var str = new IString(\"zero,zero#There are no objects on zero pages.|one,one#There is 1 object on 1 page.|other,one#There are {number} objects on 1 page.|#There are {number} objects on {pages} pages.\");\n      * var num = 4, pages = 1;\n      * console.log(str.formatChoice([num, pages], {\n      *   number: num,\n      *   pages: pages\n      * }));\n      * </pre>\n      *\n      * Gives the output:<p>\n      *\n      * <pre>\n      * \"There are 4 objects on 1 page.\"\n      * </pre>\n      *\n      * Note that when there is a single index, you would typically leave the pattern blank to\n      * indicate the default choice. When there are multiple indices, sometimes one of the\n      * patterns has to be the default case when the other is not. Rather than leaving one or\n      * more of the patterns blank with commas that look out-of-place in the middle of it, you\n      * can use the word \"other\" to indicate a match with the default or other choice. The above example\n      * shows the use of the \"other\" pattern. That said, you are allowed to leave the pattern\n      * blank if you so choose. In the example above, the pattern for the third string could\n      * easily have been written as \",one\" instead of \"other,one\" and the result will be the same.\n      *\n   * @param {*|Array.<*>} argIndex The index into the choice array of the current parameter,\n   * or an array of indices\n   * @param {Object} params The hash of parameter values that replace the replacement\n   * variables in the string\n   * @throws \"syntax error in choice format pattern: \" if there is a syntax error\n   * @return {string} the formatted string\n   */\n  formatChoice: function formatChoice(argIndex, params) {\n    var choices = this.str.split(\"|\");\n\n    var type = _typeof(argIndex);\n\n    var limits = [];\n    var strings = [];\n    var i;\n    var parts;\n    var limit;\n    var arg;\n    var result = undefined;\n    var defaultCase = \"\";\n\n    if (this.str.length === 0) {\n      // nothing to do\n      return \"\";\n    } // first parse all the choices\n\n\n    for (i = 0; i < choices.length; i++) {\n      parts = choices[i].split(\"#\");\n\n      if (parts.length > 2) {\n        limits[i] = parts[0];\n        parts = parts.shift();\n        strings[i] = parts.join(\"#\");\n      } else if (parts.length === 2) {\n        limits[i] = parts[0];\n        strings[i] = parts[1];\n      } else {\n        // syntax error\n        throw \"syntax error in choice format pattern: \" + choices[i];\n      }\n    }\n\n    var args = ilib.isArray(argIndex) ? argIndex : [argIndex]; // then apply the argument index (or indices)\n\n    for (i = 0; i < limits.length; i++) {\n      if (limits[i].length === 0) {\n        // this is default case\n        defaultCase = new IString(strings[i]);\n      } else {\n        var limitsArr = limits[i].indexOf(\",\") > -1 ? limits[i].split(\",\") : [limits[i]];\n        var applicable = true;\n\n        for (var j = 0; applicable && j < args.length && j < limitsArr.length; j++) {\n          applicable = this._testChoice(args[j], limitsArr[j]);\n        }\n\n        if (applicable) {\n          result = new IString(strings[i]);\n          i = limits.length;\n        }\n      }\n    }\n\n    if (!result) {\n      result = defaultCase || new IString(\"\");\n    }\n\n    result = result.format(params);\n    return result.toString();\n  },\n  // delegates\n\n  /**\n   * Same as String.toString()\n   * @return {string} this instance as regular Javascript string\n   */\n  toString: function toString() {\n    return this.str.toString();\n  },\n\n  /**\n   * Same as String.valueOf()\n   * @return {string} this instance as a regular Javascript string\n   */\n  valueOf: function valueOf() {\n    return this.str.valueOf();\n  },\n\n  /**\n   * Same as String.charAt()\n   * @param {number} index the index of the character being sought\n   * @return {IString} the character at the given index\n   */\n  charAt: function charAt(index) {\n    return new IString(this.str.charAt(index));\n  },\n\n  /**\n   * Same as String.charCodeAt(). This only reports on\n   * 2-byte UCS-2 Unicode values, and does not take into\n   * account supplementary characters encoded in UTF-16.\n   * If you would like to take account of those characters,\n   * use codePointAt() instead.\n   * @param {number} index the index of the character being sought\n   * @return {number} the character code of the character at the\n   * given index in the string\n   */\n  charCodeAt: function charCodeAt(index) {\n    return this.str.charCodeAt(index);\n  },\n\n  /**\n   * Same as String.concat()\n   * @param {string} strings strings to concatenate to the current one\n   * @return {IString} a concatenation of the given strings\n   */\n  concat: function concat(strings) {\n    return new IString(this.str.concat(strings));\n  },\n\n  /**\n   * Same as String.indexOf()\n   * @param {string} searchValue string to search for\n   * @param {number} start index into the string to start searching, or\n   * undefined to search the entire string\n   * @return {number} index into the string of the string being sought,\n   * or -1 if the string is not found\n   */\n  indexOf: function indexOf(searchValue, start) {\n    return this.str.indexOf(searchValue, start);\n  },\n\n  /**\n   * Same as String.lastIndexOf()\n   * @param {string} searchValue string to search for\n   * @param {number} start index into the string to start searching, or\n   * undefined to search the entire string\n   * @return {number} index into the string of the string being sought,\n   * or -1 if the string is not found\n   */\n  lastIndexOf: function lastIndexOf(searchValue, start) {\n    return this.str.lastIndexOf(searchValue, start);\n  },\n\n  /**\n   * Same as String.match()\n   * @param {string} regexp the regular expression to match\n   * @return {Array.<string>} an array of matches\n   */\n  match: function match(regexp) {\n    return this.str.match(regexp);\n  },\n\n  /**\n   * Same as String.replace()\n   * @param {string} searchValue a regular expression to search for\n   * @param {string} newValue the string to replace the matches with\n   * @return {IString} a new string with all the matches replaced\n   * with the new value\n   */\n  replace: function replace(searchValue, newValue) {\n    return new IString(this.str.replace(searchValue, newValue));\n  },\n\n  /**\n   * Same as String.search()\n   * @param {string} regexp the regular expression to search for\n   * @return {number} position of the match, or -1 for no match\n   */\n  search: function search(regexp) {\n    return this.str.search(regexp);\n  },\n\n  /**\n   * Same as String.slice()\n   * @param {number} start first character to include in the string\n   * @param {number} end include all characters up to, but not including\n   * the end character\n   * @return {IString} a slice of the current string\n   */\n  slice: function slice(start, end) {\n    return new IString(this.str.slice(start, end));\n  },\n\n  /**\n   * Same as String.split()\n   * @param {string} separator regular expression to match to find\n   * separations between the parts of the text\n   * @param {number} limit maximum number of items in the final\n   * output array. Any items beyond that limit will be ignored.\n   * @return {Array.<string>} the parts of the current string split\n   * by the separator\n   */\n  split: function split(separator, limit) {\n    return this.str.split(separator, limit);\n  },\n\n  /**\n   * Same as String.substr()\n   * @param {number} start the index of the character that should\n   * begin the returned substring\n   * @param {number} length the number of characters to return after\n   * the start character.\n   * @return {IString} the requested substring\n   */\n  substr: function substr(start, length) {\n    var plat = ilib._getPlatform();\n\n    if (plat === \"qt\" || plat === \"rhino\" || plat === \"trireme\") {\n      // qt and rhino have a broken implementation of substr(), so\n      // work around it\n      if (typeof length === \"undefined\") {\n        length = this.str.length - start;\n      }\n    }\n\n    return new IString(this.str.substr(start, length));\n  },\n\n  /**\n   * Same as String.substring()\n   * @param {number} from the index of the character that should\n   * begin the returned substring\n   * @param {number} to the index where to stop the extraction. If\n   * omitted, extracts the rest of the string\n   * @return {IString} the requested substring\n   */\n  substring: function substring(from, to) {\n    return this.str.substring(from, to);\n  },\n\n  /**\n   * Same as String.toLowerCase(). Note that this method is\n   * not locale-sensitive.\n   * @return {IString} a string with the first character\n   * lower-cased\n   */\n  toLowerCase: function toLowerCase() {\n    return this.str.toLowerCase();\n  },\n\n  /**\n   * Same as String.toUpperCase(). Note that this method is\n   * not locale-sensitive. Use toLocaleUpperCase() instead\n   * to get locale-sensitive behaviour.\n   * @return {IString} a string with the first character\n   * upper-cased\n   */\n  toUpperCase: function toUpperCase() {\n    return this.str.toUpperCase();\n  },\n\n  /**\n   * Convert the character or the surrogate pair at the given\n   * index into the string to a Unicode UCS-4 code point.\n   * @protected\n   * @param {number} index index into the string\n   * @return {number} code point of the character at the\n   * given index into the string\n   */\n  _toCodePoint: function _toCodePoint(index) {\n    return IString.toCodePoint(this.str, index);\n  },\n\n  /**\n   * Call the callback with each character in the string one at\n   * a time, taking care to step through the surrogate pairs in\n   * the UTF-16 encoding properly.<p>\n   *\n   * The standard Javascript String's charAt() method only\n   * returns a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index to charAt() is pointing to a low- or\n   * high-surrogate character,\n   * it will return the surrogate character rather\n   * than the the character\n   * in the supplementary planes that the two surrogates together\n   * encode. This function will call the callback with the full\n   * character, making sure to join two\n   * surrogates into one character in the supplementary planes\n   * where necessary.<p>\n   *\n   * @param {function(string)} callback a callback function to call with each\n   * full character in the current string\n   */\n  forEach: function forEach(callback) {\n    if (typeof callback === 'function') {\n      var it = this.charIterator();\n\n      while (it.hasNext()) {\n        callback(it.next());\n      }\n    }\n  },\n\n  /**\n   * Call the callback with each numeric code point in the string one at\n   * a time, taking care to step through the surrogate pairs in\n   * the UTF-16 encoding properly.<p>\n   *\n   * The standard Javascript String's charCodeAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index to charCodeAt() is pointing to a low- or\n   * high-surrogate character,\n   * it will return the code point of the surrogate character rather\n   * than the code point of the character\n   * in the supplementary planes that the two surrogates together\n   * encode. This function will call the callback with the full\n   * code point of each character, making sure to join two\n   * surrogates into one code point in the supplementary planes.<p>\n   *\n   * @param {function(string)} callback a callback function to call with each\n   * code point in the current string\n   */\n  forEachCodePoint: function forEachCodePoint(callback) {\n    if (typeof callback === 'function') {\n      var it = this.iterator();\n\n      while (it.hasNext()) {\n        callback(it.next());\n      }\n    }\n  },\n\n  /**\n   * Return an iterator that will step through all of the characters\n   * in the string one at a time and return their code points, taking\n   * care to step through the surrogate pairs in UTF-16 encoding\n   * properly.<p>\n   *\n   * The standard Javascript String's charCodeAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index is pointing to a low- or high-surrogate character,\n   * it will return a code point of the surrogate character rather\n   * than the code point of the character\n   * in the supplementary planes that the two surrogates together\n   * encode.<p>\n   *\n   * The iterator instance returned has two methods, hasNext() which\n   * returns true if the iterator has more code points to iterate through,\n   * and next() which returns the next code point as a number.<p>\n   *\n   * @return {Object} an iterator\n   * that iterates through all the code points in the string\n   */\n  iterator: function iterator() {\n    /**\n     * @constructor\n     */\n    function _iterator(istring) {\n      this.index = 0;\n\n      this.hasNext = function () {\n        return this.index < istring.str.length;\n      };\n\n      this.next = function () {\n        if (this.index < istring.str.length) {\n          var num = istring._toCodePoint(this.index);\n\n          this.index += num > 0xFFFF ? 2 : 1;\n        } else {\n          num = -1;\n        }\n\n        return num;\n      };\n    }\n\n    ;\n    return new _iterator(this);\n  },\n\n  /**\n   * Return an iterator that will step through all of the characters\n   * in the string one at a time, taking\n   * care to step through the surrogate pairs in UTF-16 encoding\n   * properly.<p>\n   *\n   * The standard Javascript String's charAt() method only\n   * returns information about a particular 16-bit character in the\n   * UTF-16 encoding scheme.\n   * If the index is pointing to a low- or high-surrogate character,\n   * it will return that surrogate character rather\n   * than the surrogate pair which represents a character\n   * in the supplementary planes.<p>\n   *\n   * The iterator instance returned has two methods, hasNext() which\n   * returns true if the iterator has more characters to iterate through,\n   * and next() which returns the next character.<p>\n   *\n   * @return {Object} an iterator\n   * that iterates through all the characters in the string\n   */\n  charIterator: function charIterator() {\n    /**\n     * @constructor\n     */\n    function _chiterator(istring) {\n      this.index = 0;\n\n      this.hasNext = function () {\n        return this.index < istring.str.length;\n      };\n\n      this.next = function () {\n        var ch;\n\n        if (this.index < istring.str.length) {\n          ch = istring.str.charAt(this.index);\n\n          if (IString._isSurrogate(ch) && this.index + 1 < istring.str.length && IString._isSurrogate(istring.str.charAt(this.index + 1))) {\n            this.index++;\n            ch += istring.str.charAt(this.index);\n          }\n\n          this.index++;\n        }\n\n        return ch;\n      };\n    }\n\n    ;\n    return new _chiterator(this);\n  },\n\n  /**\n   * Return the code point at the given index when the string is viewed\n   * as an array of code points. If the index is beyond the end of the\n   * array of code points or if the index is negative, -1 is returned.\n   * @param {number} index index of the code point\n   * @return {number} code point of the character at the given index into\n   * the string\n   */\n  codePointAt: function codePointAt(index) {\n    if (index < 0) {\n      return -1;\n    }\n\n    var count,\n        it = this.iterator(),\n        ch;\n\n    for (count = index; count >= 0 && it.hasNext(); count--) {\n      ch = it.next();\n    }\n\n    return count < 0 ? ch : -1;\n  },\n\n  /**\n   * Set the locale to use when processing choice formats. The locale\n   * affects how number classes are interpretted. In some cultures,\n   * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n   * in yet others, \"few\" maps to \"any integer that ends in the digits\n   * 3 or 4\".\n   * @param {Locale|string} locale locale to use when processing choice\n   * formats with this string\n   * @param {boolean=} sync [optional] whether to load the locale data synchronously\n   * or not\n   * @param {Object=} loadParams [optional] parameters to pass to the loader function\n   * @param {function(*)=} onLoad [optional] function to call when the loading is done\n   */\n  setLocale: function setLocale(locale, sync, loadParams, onLoad) {\n    if (_typeof(locale) === 'object') {\n      this.locale = locale;\n    } else {\n      this.localeSpec = locale;\n      this.locale = new Locale(locale);\n    }\n\n    IString.loadPlurals(typeof sync !== 'undefined' ? sync : true, this.locale, loadParams, onLoad);\n  },\n\n  /**\n   * Return the locale to use when processing choice formats. The locale\n   * affects how number classes are interpretted. In some cultures,\n   * the limit \"few\" maps to \"any integer that ends in the digits 2 to 9\" and\n   * in yet others, \"few\" maps to \"any integer that ends in the digits\n   * 3 or 4\".\n   * @return {string} localespec to use when processing choice\n   * formats with this string\n   */\n  getLocale: function getLocale() {\n    return (this.locale ? this.locale.getSpec() : this.localeSpec) || ilib.getLocale();\n  },\n\n  /**\n   * Return the number of code points in this string. This may be different\n   * than the number of characters, as the UTF-16 encoding that Javascript\n   * uses for its basis returns surrogate pairs separately. Two 2-byte\n   * surrogate characters together make up one character/code point in\n   * the supplementary character planes. If your string contains no\n   * characters in the supplementary planes, this method will return the\n   * same thing as the length() method.\n   * @return {number} the number of code points in this string\n   */\n  codePointLength: function codePointLength() {\n    if (this.cpLength === -1) {\n      var it = this.iterator();\n      this.cpLength = 0;\n\n      while (it.hasNext()) {\n        this.cpLength++;\n        it.next();\n      }\n\n      ;\n    }\n\n    return this.cpLength;\n  }\n};\nmodule.exports = IString;"]},"metadata":{},"sourceType":"module"}