{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateFontSize = calculateFontSize;\nexports.defineScreenTypes = defineScreenTypes;\nexports.getAspectRatio = getAspectRatio;\nexports.getAspectRatioName = getAspectRatioName;\nexports.getResolutionClasses = getResolutionClasses;\nexports.getScreenTypeObject = getScreenTypeObject;\nexports.getScreenType = getScreenType;\nexports.init = init;\nexports.scale = scale;\nexports.selectSrc = selectSrc;\nexports.unit = unit;\nexports.unitToPixelFactors = exports.scaleToRem = exports.config = void 0;\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar baseScreen,\n    orientation,\n    riRatio,\n    screenType,\n    workspaceBounds = {\n  width: (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' ? window.innerWidth : 1920,\n  height: (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' ? window.innerHeight : 1080\n},\n    screenTypes = [{\n  name: 'standard',\n  pxPerRem: 16,\n  width: workspaceBounds.width,\n  height: workspaceBounds.height,\n  aspectRatioName: 'standard',\n  base: true\n}],\n    // Assign one sane type in case defineScreenTypes is never run.\nscreenTypeObject,\n    config;\n/**\n * Object that stores all of the pixel conversion factors to each keyed unit.\n *\n * @type {Object}\n * @memberof ui/resolution\n * @public\n */\n\nexports.config = config;\nvar unitToPixelFactors = {\n  'rem': 12,\n  'in': 96\n};\nexports.unitToPixelFactors = unitToPixelFactors;\nvar configDefaults = {\n  orientationHandling: 'normal'\n};\n/**\n * Update the common measured boundary object.\n *\n * This object is used as \"what size screen are we looking at\". Providing no arguments has no\n * effect and updates nothing.\n *\n * @function\n * @memberOf ui/resolution\n * @param {Node}    measurementNode    A standard DOM node or the `window` node.\n *\n * @returns {undefined}\n * @private\n */\n\nvar updateWorkspaceBounds = function updateWorkspaceBounds(measurementNode) {\n  if (measurementNode && (measurementNode.clientHeight || measurementNode.clientWidth)) {\n    workspaceBounds = {\n      height: measurementNode.clientHeight,\n      width: measurementNode.clientWidth\n    };\n  } else if (measurementNode && (measurementNode.innerHeight || measurementNode.innerWidth)) {\n    // A backup for if measurementNode is actually `window` and not a normal node\n    workspaceBounds = {\n      height: measurementNode.innerHeight,\n      width: measurementNode.innerWidth\n    };\n  }\n};\n/**\n * Fetch the screenType object\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    The key string for the screen type object. If falsy, the current\n *                             screenType is used\n *\n * @returns {Object}           screenTypeObject\n * @private\n */\n\n\nfunction getScreenTypeObject(type) {\n  type = type || screenType;\n\n  if (screenTypeObject && screenTypeObject.name === type) {\n    return screenTypeObject;\n  }\n\n  return screenTypes.filter(function (elem) {\n    return type === elem.name;\n  })[0];\n}\n/**\n * Sets up screen resolution scaling capabilities by defining an array of all the screens\n * being used.\n *\n * These should be listed in order from smallest to largest, according to\n * width.\n *\n * The `name`, `pxPerRem`, `width`, and `aspectRatioName` properties are required for\n * each screen type in the array. Setting `base: true` on a screen type marks it as the\n * default resolution, upon which everything else will be based.\n *\n * Executing this method also initializes the rest of the resolution-independence code.\n *\n * Example:\n * ```\n * import ri from 'enact/ui/resolution';\n *\n * ri.defineScreenTypes([\n * \t{name: 'vga',     pxPerRem: 8,  width: 640,  height: 480,  aspectRatioName: 'standard'},\n * \t{name: 'xga',     pxPerRem: 16, width: 1024, height: 768,  aspectRatioName: 'standard'},\n * \t{name: 'hd',      pxPerRem: 16, width: 1280, height: 720,  aspectRatioName: 'hdtv'},\n * \t{name: 'fhd',     pxPerRem: 24, width: 1920, height: 1080, aspectRatioName: 'hdtv', base: true},\n * \t{name: 'uw-uxga', pxPerRem: 24, width: 2560, height: 1080, aspectRatioName: 'cinema'},\n * \t{name: 'uhd',     pxPerRem: 48, width: 3840, height: 2160, aspectRatioName: 'hdtv'}\n * ]);\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {Object[]}    types    An array of objects containing screen configuration data, as in the\n *                            preceding example.\n * @returns {undefined}\n * @public\n */\n\n\nfunction defineScreenTypes(types) {\n  if (types) screenTypes = types;\n\n  for (var i = 0; i < screenTypes.length; i++) {\n    if (screenTypes[i]['base']) baseScreen = screenTypes[i];\n  }\n\n  init();\n}\n/**\n * Fetches the name of the screen type that best matches the current screen size.\n *\n * The best match is defined as the screen type that is the closest to the screen resolution without\n * going over. (\"The Price is Right\" style.)\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    rez    Optional measurement scheme. Must include `height` and `width` properties.\n * @returns {String}         Screen type (e.g., `'fhd'`, `'uhd'`, etc.)\n * @public\n */\n\n\nfunction getScreenType(rez) {\n  rez = rez || workspaceBounds;\n  var types = screenTypes;\n  var bestMatch = types[types.length - 1].name; // Blindly set the first screen type, in case no matches are found later.\n\n  orientation = 'landscape';\n\n  if (rez.height > rez.width) {\n    orientation = 'portrait';\n    var swap = rez.width;\n    rez.width = rez.height;\n    rez.height = swap;\n  } // Loop through resolutions, last->first, largest->smallest\n\n\n  for (var i = types.length - 1; i >= 0; i--) {\n    // Does the current resolution fit inside this screenType definition? If so, save it as the current best match.\n    if (rez.height <= types[i].height && rez.width <= types[i].width) {\n      bestMatch = types[i].name;\n    }\n  } // Return the name of the closest fitting set of dimensions.\n\n\n  return bestMatch;\n}\n/**\n * Calculate the base rem font size.\n *\n * This is how the magic happens. This accepts an optional `screenType` name. If one isn't provided,\n * the currently detected screen type is used. This uses the config option `orientationHandling`,\n * which when set to \"scale\" and the screen is in portrait orientation, will dynamically calculate\n * what the base font size should be, if the width were proportionally scaled down to fit in the portrait space.\n *\n * To use, put the following in your application code:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * ri.config.orientationHandling = 'scale';\n * ri.init();\n * ```\n *\n * This has no effect if the screen is in landscape, or if `orientationHandling` is unset.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type to base size the calculation on. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The calculated pixel size (with unit suffix. Ex: \"24px\").\n * @public\n */\n\n\nfunction calculateFontSize(type) {\n  var scrObj = getScreenTypeObject(type);\n  var size;\n\n  if (orientation === 'portrait' && config.orientationHandling === 'scale') {\n    size = scrObj.height / scrObj.width * scrObj.pxPerRem;\n  } else {\n    size = scrObj.pxPerRem;\n  }\n\n  return size + 'px';\n}\n/**\n * @function\n * @memberof ui/resolution\n * @param {String}    size     A valid CSS measurement to be applied as the base document font size.\n * @private\n * @returns {undefined}\n */\n\n\nfunction updateBaseFontSize(size) {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n    document.documentElement.style.fontSize = size;\n  }\n}\n/**\n * Returns the CSS classes for the given `type`.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n * @returns {String}          CSS class names\n * @public\n */\n\n\nfunction getResolutionClasses() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  var classes = [];\n\n  if (orientation) {\n    classes.push('enact-orientation-' + orientation);\n  }\n\n  if (type) {\n    classes.push('enact-res-' + type.toLowerCase());\n    var scrObj = getScreenTypeObject(type);\n\n    if (scrObj.aspectRatioName) {\n      classes.push('enact-aspect-ratio-' + scrObj.aspectRatioName.toLowerCase());\n    }\n  }\n\n  return classes.join(' ');\n}\n/**\n * Returns the ratio of pixels per rem for the given `type` to the pixels per rem for the base type.\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    Screen type\n *\n * @returns {Number}           ratio\n */\n\n\nfunction getRiRatio() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n\n  if (type && baseScreen) {\n    var ratio = getUnitToPixelFactors(type) / getUnitToPixelFactors(baseScreen.name);\n\n    if (type === screenType) {\n      // cache this if it's for our current screen type.\n      riRatio = ratio;\n    }\n\n    return ratio;\n  }\n\n  return 1;\n}\n/**\n * Returns the pixels per rem for the given `type`.\n *\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n *\n * @returns {Number}          pixels per rem\n */\n\n\nfunction getUnitToPixelFactors() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n\n  if (type) {\n    return getScreenTypeObject(type).pxPerRem;\n  }\n\n  return 1;\n}\n/**\n * Calculates the aspect ratio of the specified screen type.\n *\n * If no screen type is provided, the current screen type is used.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio will be calculated. If no screen\n *                            type is provided, the current screen type is used.\n * @returns {Number}          The calculated screen ratio (e.g., `1.333`, `1.777`, `2.333`, etc.)\n * @public\n */\n\n\nfunction getAspectRatio(type) {\n  var scrObj = getScreenTypeObject(type);\n\n  if (scrObj.width && scrObj.height) {\n    return scrObj.width / scrObj.height;\n  }\n\n  return 1;\n}\n/**\n * Returns the name of the aspect ratio for a specified screen type, or for the default\n * screen type if none is provided.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio name will be returned. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The name of the screen type's aspect ratio\n * @public\n */\n\n\nfunction getAspectRatioName(type) {\n  var scrObj = getScreenTypeObject(type);\n  return scrObj.aspectRatioName || 'standard';\n}\n/**\n * Takes a provided pixel value and performs a scaling operation based on the current\n * screen type.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    px    The quantity of standard-resolution pixels to scale to the\n *                          current screen resolution.\n * @returns {Number}        The scaled value based on the current screen scaling factor\n * @public\n */\n\n\nfunction scale(px) {\n  return (riRatio || getRiRatio()) * px;\n}\n/**\n * Convert to various unit formats.\n *\n * Useful for converting pixels to a resolution-independent\n * measurement method, like \"rem\". Other units are available if defined in the\n * {@link ui/resolution.unitToPixelFactors} object.\n *\n * Example:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * // Do calculations and get back the desired CSS unit.\n * var frameWidth = 250,\n *     frameWithMarginInches = ri.unit( 10 + frameWidth + 10, 'in' ), // '2.8125in' == frameWithMarginInches\n *     frameWithMarginRems = ri.unit( 10 + frameWidth + 10, 'rem' ); // '22.5rem' == frameWithMarginRems\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|Number}     pixels    The pixels or math to convert to the unit (\"px\" suffix in String\n *                                       format is permitted. ex: `'20px'`)\n * @param {String}            toUnit    The name of the unit to convert to.\n *\n * @returns {String|undefined}          Resulting conversion in CSS safe format, in case of malformed input, `undefined`\n * @public\n */\n\n\nfunction unit(pixels, toUnit) {\n  if (!toUnit || !unitToPixelFactors[toUnit]) return;\n  if (typeof pixels === 'string' && pixels.substr(-2) === 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2));\n  if (typeof pixels !== 'number') return;\n  return pixels / unitToPixelFactors[toUnit] + '' + toUnit;\n}\n/**\n * Shorthand for when you know you need to scale some pixel value and have it converted to \"rem\" for\n * proper scaling.\n *\n * This runs {@link ui/resolution.scale} and {@link ui/resolution.unit} together.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    pixels    The quantity of standard-resolution pixels to scale to rems\n *\n * @returns {String|undefined}  Resulting conversion or, in case of malformed input, `undefined`\n * @public\n */\n\n\nvar scaleToRem = function scaleToRem(pixels) {\n  return unit(scale(pixels), 'rem');\n};\n/**\n * The default configurable options for {@link ui/resolution.selectSrc}.\n *\n * @typedef {Object} selectSrcOptions\n * @memberof ui/resolution\n * @property {String}    hd    HD / 720p Resolution image asset source URI/URL\n * @property {String}    fhd    FHD / 1080p Resolution image asset source URI/URL\n * @property {String}    uhd    UHD / 4K Resolution image asset source URI/URL\n */\n\n/**\n * Selects the ideal image asset from a set of assets, based on various screen\n * resolutions: HD (720p), FHD (1080p), UHD (4k).\n *\n * When a `src` argument is provided, `selectSrc()` will choose the best image with\n * respect to the current screen resolution. `src` may be either the traditional\n * string, which will pass straight through, or a hash/object of screen types and\n * their asset sources (keys:screen and values:src). The image sources will be used\n * when the screen resolution is less than or equal to the provided screen types.\n *\n * Example:\n * ```\n * // Take advantage of the multi-res mode\n * import {Image} from '@enact/ui/Image';\n *\n * const src = {\n *     'hd': 'http://lorempixel.com/64/64/city/1/',\n *     'fhd': 'http://lorempixel.com/128/128/city/1/',\n *     'uhd': 'http://lorempixel.com/256/256/city/1/'\n * };\n * ...\n * <Image src={src} ... />\n * ...\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|ui/resolution.selectSrcSrcOptions} src       A string containing a single image\n *                                                             source or a key/value hash/object\n *                                                             containing keys representing screen\n *                                                             types (`'hd'`, `'fhd'`, `'uhd'`,\n *                                                             etc.) and values containing the asset\n *                                                             source for that target screen\n *                                                             resolution.\n *\n * @returns {String}                                           The chosen source, given the string\n *                                                             or hash provided\n * @public\n */\n\n\nexports.scaleToRem = scaleToRem;\n\nfunction selectSrc(src) {\n  if (typeof src != 'string' && src) {\n    var newSrc = src.fhd || src.uhd || src.hd;\n    var types = screenTypes; // loop through resolutions\n\n    for (var i = types.length - 1; i >= 0; i--) {\n      var t = types[i].name;\n      if (screenType === t && src[t]) newSrc = src[t];\n    }\n\n    src = newSrc;\n  }\n\n  return src;\n}\n/**\n * This will need to be re-run any time the screen size changes, so all the values can be re-cached.\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    args    A hash of options. The key `measurementNode` is used to as the node,\n *                            typically the root element, to measure and use as the dimensions for\n *                            the `screenType`.\n *\n * @returns {undefined}\n * @public\n */\n\n\nfunction init() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var measurementNode = args.measurementNode;\n  updateWorkspaceBounds(measurementNode);\n  screenType = getScreenType();\n  screenTypeObject = getScreenTypeObject();\n  unitToPixelFactors.rem = getUnitToPixelFactors();\n  riRatio = getRiRatio();\n  updateBaseFontSize(calculateFontSize());\n}\n/**\n * The current configuration\n *\n * @type {Object}\n * @memberof ui/resolution\n * @private\n */\n\n\nexports.config = config = Object.assign({}, configDefaults);","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/ui/resolution/resolution.js"],"names":["Object","defineProperty","exports","value","calculateFontSize","defineScreenTypes","getAspectRatio","getAspectRatioName","getResolutionClasses","getScreenTypeObject","getScreenType","init","scale","selectSrc","unit","unitToPixelFactors","scaleToRem","config","_typeof","obj","Symbol","iterator","constructor","prototype","baseScreen","orientation","riRatio","screenType","workspaceBounds","width","window","innerWidth","height","innerHeight","screenTypes","name","pxPerRem","aspectRatioName","base","screenTypeObject","configDefaults","orientationHandling","updateWorkspaceBounds","measurementNode","clientHeight","clientWidth","type","filter","elem","types","i","length","rez","bestMatch","swap","scrObj","size","updateBaseFontSize","document","documentElement","style","fontSize","arguments","undefined","classes","push","toLowerCase","join","getRiRatio","ratio","getUnitToPixelFactors","px","pixels","toUnit","substr","parseInt","src","newSrc","fhd","uhd","hd","t","args","rem","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateFontSize = calculateFontSize;\nexports.defineScreenTypes = defineScreenTypes;\nexports.getAspectRatio = getAspectRatio;\nexports.getAspectRatioName = getAspectRatioName;\nexports.getResolutionClasses = getResolutionClasses;\nexports.getScreenTypeObject = getScreenTypeObject;\nexports.getScreenType = getScreenType;\nexports.init = init;\nexports.scale = scale;\nexports.selectSrc = selectSrc;\nexports.unit = unit;\nexports.unitToPixelFactors = exports.scaleToRem = exports.config = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar baseScreen,\n    orientation,\n    riRatio,\n    screenType,\n    workspaceBounds = {\n  width: (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' ? window.innerWidth : 1920,\n  height: (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' ? window.innerHeight : 1080\n},\n    screenTypes = [{\n  name: 'standard',\n  pxPerRem: 16,\n  width: workspaceBounds.width,\n  height: workspaceBounds.height,\n  aspectRatioName: 'standard',\n  base: true\n}],\n    // Assign one sane type in case defineScreenTypes is never run.\nscreenTypeObject,\n    config;\n/**\n * Object that stores all of the pixel conversion factors to each keyed unit.\n *\n * @type {Object}\n * @memberof ui/resolution\n * @public\n */\n\nexports.config = config;\nvar unitToPixelFactors = {\n  'rem': 12,\n  'in': 96\n};\nexports.unitToPixelFactors = unitToPixelFactors;\nvar configDefaults = {\n  orientationHandling: 'normal'\n};\n/**\n * Update the common measured boundary object.\n *\n * This object is used as \"what size screen are we looking at\". Providing no arguments has no\n * effect and updates nothing.\n *\n * @function\n * @memberOf ui/resolution\n * @param {Node}    measurementNode    A standard DOM node or the `window` node.\n *\n * @returns {undefined}\n * @private\n */\n\nvar updateWorkspaceBounds = function updateWorkspaceBounds(measurementNode) {\n  if (measurementNode && (measurementNode.clientHeight || measurementNode.clientWidth)) {\n    workspaceBounds = {\n      height: measurementNode.clientHeight,\n      width: measurementNode.clientWidth\n    };\n  } else if (measurementNode && (measurementNode.innerHeight || measurementNode.innerWidth)) {\n    // A backup for if measurementNode is actually `window` and not a normal node\n    workspaceBounds = {\n      height: measurementNode.innerHeight,\n      width: measurementNode.innerWidth\n    };\n  }\n};\n/**\n * Fetch the screenType object\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    The key string for the screen type object. If falsy, the current\n *                             screenType is used\n *\n * @returns {Object}           screenTypeObject\n * @private\n */\n\n\nfunction getScreenTypeObject(type) {\n  type = type || screenType;\n\n  if (screenTypeObject && screenTypeObject.name === type) {\n    return screenTypeObject;\n  }\n\n  return screenTypes.filter(function (elem) {\n    return type === elem.name;\n  })[0];\n}\n/**\n * Sets up screen resolution scaling capabilities by defining an array of all the screens\n * being used.\n *\n * These should be listed in order from smallest to largest, according to\n * width.\n *\n * The `name`, `pxPerRem`, `width`, and `aspectRatioName` properties are required for\n * each screen type in the array. Setting `base: true` on a screen type marks it as the\n * default resolution, upon which everything else will be based.\n *\n * Executing this method also initializes the rest of the resolution-independence code.\n *\n * Example:\n * ```\n * import ri from 'enact/ui/resolution';\n *\n * ri.defineScreenTypes([\n * \t{name: 'vga',     pxPerRem: 8,  width: 640,  height: 480,  aspectRatioName: 'standard'},\n * \t{name: 'xga',     pxPerRem: 16, width: 1024, height: 768,  aspectRatioName: 'standard'},\n * \t{name: 'hd',      pxPerRem: 16, width: 1280, height: 720,  aspectRatioName: 'hdtv'},\n * \t{name: 'fhd',     pxPerRem: 24, width: 1920, height: 1080, aspectRatioName: 'hdtv', base: true},\n * \t{name: 'uw-uxga', pxPerRem: 24, width: 2560, height: 1080, aspectRatioName: 'cinema'},\n * \t{name: 'uhd',     pxPerRem: 48, width: 3840, height: 2160, aspectRatioName: 'hdtv'}\n * ]);\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {Object[]}    types    An array of objects containing screen configuration data, as in the\n *                            preceding example.\n * @returns {undefined}\n * @public\n */\n\n\nfunction defineScreenTypes(types) {\n  if (types) screenTypes = types;\n\n  for (var i = 0; i < screenTypes.length; i++) {\n    if (screenTypes[i]['base']) baseScreen = screenTypes[i];\n  }\n\n  init();\n}\n/**\n * Fetches the name of the screen type that best matches the current screen size.\n *\n * The best match is defined as the screen type that is the closest to the screen resolution without\n * going over. (\"The Price is Right\" style.)\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    rez    Optional measurement scheme. Must include `height` and `width` properties.\n * @returns {String}         Screen type (e.g., `'fhd'`, `'uhd'`, etc.)\n * @public\n */\n\n\nfunction getScreenType(rez) {\n  rez = rez || workspaceBounds;\n  var types = screenTypes;\n  var bestMatch = types[types.length - 1].name; // Blindly set the first screen type, in case no matches are found later.\n\n  orientation = 'landscape';\n\n  if (rez.height > rez.width) {\n    orientation = 'portrait';\n    var swap = rez.width;\n    rez.width = rez.height;\n    rez.height = swap;\n  } // Loop through resolutions, last->first, largest->smallest\n\n\n  for (var i = types.length - 1; i >= 0; i--) {\n    // Does the current resolution fit inside this screenType definition? If so, save it as the current best match.\n    if (rez.height <= types[i].height && rez.width <= types[i].width) {\n      bestMatch = types[i].name;\n    }\n  } // Return the name of the closest fitting set of dimensions.\n\n\n  return bestMatch;\n}\n/**\n * Calculate the base rem font size.\n *\n * This is how the magic happens. This accepts an optional `screenType` name. If one isn't provided,\n * the currently detected screen type is used. This uses the config option `orientationHandling`,\n * which when set to \"scale\" and the screen is in portrait orientation, will dynamically calculate\n * what the base font size should be, if the width were proportionally scaled down to fit in the portrait space.\n *\n * To use, put the following in your application code:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * ri.config.orientationHandling = 'scale';\n * ri.init();\n * ```\n *\n * This has no effect if the screen is in landscape, or if `orientationHandling` is unset.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type to base size the calculation on. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The calculated pixel size (with unit suffix. Ex: \"24px\").\n * @public\n */\n\n\nfunction calculateFontSize(type) {\n  var scrObj = getScreenTypeObject(type);\n  var size;\n\n  if (orientation === 'portrait' && config.orientationHandling === 'scale') {\n    size = scrObj.height / scrObj.width * scrObj.pxPerRem;\n  } else {\n    size = scrObj.pxPerRem;\n  }\n\n  return size + 'px';\n}\n/**\n * @function\n * @memberof ui/resolution\n * @param {String}    size     A valid CSS measurement to be applied as the base document font size.\n * @private\n * @returns {undefined}\n */\n\n\nfunction updateBaseFontSize(size) {\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n    document.documentElement.style.fontSize = size;\n  }\n}\n/**\n * Returns the CSS classes for the given `type`.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n * @returns {String}          CSS class names\n * @public\n */\n\n\nfunction getResolutionClasses() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  var classes = [];\n\n  if (orientation) {\n    classes.push('enact-orientation-' + orientation);\n  }\n\n  if (type) {\n    classes.push('enact-res-' + type.toLowerCase());\n    var scrObj = getScreenTypeObject(type);\n\n    if (scrObj.aspectRatioName) {\n      classes.push('enact-aspect-ratio-' + scrObj.aspectRatioName.toLowerCase());\n    }\n  }\n\n  return classes.join(' ');\n}\n/**\n * Returns the ratio of pixels per rem for the given `type` to the pixels per rem for the base type.\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    Screen type\n *\n * @returns {Number}           ratio\n */\n\n\nfunction getRiRatio() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n\n  if (type && baseScreen) {\n    var ratio = getUnitToPixelFactors(type) / getUnitToPixelFactors(baseScreen.name);\n\n    if (type === screenType) {\n      // cache this if it's for our current screen type.\n      riRatio = ratio;\n    }\n\n    return ratio;\n  }\n\n  return 1;\n}\n/**\n * Returns the pixels per rem for the given `type`.\n *\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n *\n * @returns {Number}          pixels per rem\n */\n\n\nfunction getUnitToPixelFactors() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n\n  if (type) {\n    return getScreenTypeObject(type).pxPerRem;\n  }\n\n  return 1;\n}\n/**\n * Calculates the aspect ratio of the specified screen type.\n *\n * If no screen type is provided, the current screen type is used.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio will be calculated. If no screen\n *                            type is provided, the current screen type is used.\n * @returns {Number}          The calculated screen ratio (e.g., `1.333`, `1.777`, `2.333`, etc.)\n * @public\n */\n\n\nfunction getAspectRatio(type) {\n  var scrObj = getScreenTypeObject(type);\n\n  if (scrObj.width && scrObj.height) {\n    return scrObj.width / scrObj.height;\n  }\n\n  return 1;\n}\n/**\n * Returns the name of the aspect ratio for a specified screen type, or for the default\n * screen type if none is provided.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio name will be returned. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The name of the screen type's aspect ratio\n * @public\n */\n\n\nfunction getAspectRatioName(type) {\n  var scrObj = getScreenTypeObject(type);\n  return scrObj.aspectRatioName || 'standard';\n}\n/**\n * Takes a provided pixel value and performs a scaling operation based on the current\n * screen type.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    px    The quantity of standard-resolution pixels to scale to the\n *                          current screen resolution.\n * @returns {Number}        The scaled value based on the current screen scaling factor\n * @public\n */\n\n\nfunction scale(px) {\n  return (riRatio || getRiRatio()) * px;\n}\n/**\n * Convert to various unit formats.\n *\n * Useful for converting pixels to a resolution-independent\n * measurement method, like \"rem\". Other units are available if defined in the\n * {@link ui/resolution.unitToPixelFactors} object.\n *\n * Example:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * // Do calculations and get back the desired CSS unit.\n * var frameWidth = 250,\n *     frameWithMarginInches = ri.unit( 10 + frameWidth + 10, 'in' ), // '2.8125in' == frameWithMarginInches\n *     frameWithMarginRems = ri.unit( 10 + frameWidth + 10, 'rem' ); // '22.5rem' == frameWithMarginRems\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|Number}     pixels    The pixels or math to convert to the unit (\"px\" suffix in String\n *                                       format is permitted. ex: `'20px'`)\n * @param {String}            toUnit    The name of the unit to convert to.\n *\n * @returns {String|undefined}          Resulting conversion in CSS safe format, in case of malformed input, `undefined`\n * @public\n */\n\n\nfunction unit(pixels, toUnit) {\n  if (!toUnit || !unitToPixelFactors[toUnit]) return;\n  if (typeof pixels === 'string' && pixels.substr(-2) === 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2));\n  if (typeof pixels !== 'number') return;\n  return pixels / unitToPixelFactors[toUnit] + '' + toUnit;\n}\n/**\n * Shorthand for when you know you need to scale some pixel value and have it converted to \"rem\" for\n * proper scaling.\n *\n * This runs {@link ui/resolution.scale} and {@link ui/resolution.unit} together.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    pixels    The quantity of standard-resolution pixels to scale to rems\n *\n * @returns {String|undefined}  Resulting conversion or, in case of malformed input, `undefined`\n * @public\n */\n\n\nvar scaleToRem = function scaleToRem(pixels) {\n  return unit(scale(pixels), 'rem');\n};\n/**\n * The default configurable options for {@link ui/resolution.selectSrc}.\n *\n * @typedef {Object} selectSrcOptions\n * @memberof ui/resolution\n * @property {String}    hd    HD / 720p Resolution image asset source URI/URL\n * @property {String}    fhd    FHD / 1080p Resolution image asset source URI/URL\n * @property {String}    uhd    UHD / 4K Resolution image asset source URI/URL\n */\n\n/**\n * Selects the ideal image asset from a set of assets, based on various screen\n * resolutions: HD (720p), FHD (1080p), UHD (4k).\n *\n * When a `src` argument is provided, `selectSrc()` will choose the best image with\n * respect to the current screen resolution. `src` may be either the traditional\n * string, which will pass straight through, or a hash/object of screen types and\n * their asset sources (keys:screen and values:src). The image sources will be used\n * when the screen resolution is less than or equal to the provided screen types.\n *\n * Example:\n * ```\n * // Take advantage of the multi-res mode\n * import {Image} from '@enact/ui/Image';\n *\n * const src = {\n *     'hd': 'http://lorempixel.com/64/64/city/1/',\n *     'fhd': 'http://lorempixel.com/128/128/city/1/',\n *     'uhd': 'http://lorempixel.com/256/256/city/1/'\n * };\n * ...\n * <Image src={src} ... />\n * ...\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|ui/resolution.selectSrcSrcOptions} src       A string containing a single image\n *                                                             source or a key/value hash/object\n *                                                             containing keys representing screen\n *                                                             types (`'hd'`, `'fhd'`, `'uhd'`,\n *                                                             etc.) and values containing the asset\n *                                                             source for that target screen\n *                                                             resolution.\n *\n * @returns {String}                                           The chosen source, given the string\n *                                                             or hash provided\n * @public\n */\n\n\nexports.scaleToRem = scaleToRem;\n\nfunction selectSrc(src) {\n  if (typeof src != 'string' && src) {\n    var newSrc = src.fhd || src.uhd || src.hd;\n    var types = screenTypes; // loop through resolutions\n\n    for (var i = types.length - 1; i >= 0; i--) {\n      var t = types[i].name;\n      if (screenType === t && src[t]) newSrc = src[t];\n    }\n\n    src = newSrc;\n  }\n\n  return src;\n}\n/**\n * This will need to be re-run any time the screen size changes, so all the values can be re-cached.\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    args    A hash of options. The key `measurementNode` is used to as the node,\n *                            typically the root element, to measure and use as the dimensions for\n *                            the `screenType`.\n *\n * @returns {undefined}\n * @public\n */\n\n\nfunction init() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var measurementNode = args.measurementNode;\n  updateWorkspaceBounds(measurementNode);\n  screenType = getScreenType();\n  screenTypeObject = getScreenTypeObject();\n  unitToPixelFactors.rem = getUnitToPixelFactors();\n  riRatio = getRiRatio();\n  updateBaseFontSize(calculateFontSize());\n}\n/**\n * The current configuration\n *\n * @type {Object}\n * @memberof ui/resolution\n * @private\n */\n\n\nexports.config = config = Object.assign({}, configDefaults);"]},"metadata":{},"sourceType":"module"}