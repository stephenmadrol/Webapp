{"ast":null,"code":"\"use strict\";\n/* eslint-env browser,es6 */\n\n/*\n * zoneinfo.js - represent a binary zone info file\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * The portion of this code that parses the zone info file format is derived\n * from the code in the node-zoneinfo project by Gregory McWhirter licensed\n * under the MIT license:\n *\n * Copyright (c) 2013 Gregory McWhirter\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject\n * to the following conditions:\n\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nvar PackedBuffer = require('./packedbuffer.js');\n\nvar _platform = typeof PalmSystem !== 'undefined' ? 'webos' : 'browser';\n/**\n * Represents a binary zone info file of the sort that the Unix Zone Info Compiler\n * produces.\n * @constructor\n * @param {string} path path to the file to be loaded\n * @param {number} year year of the zone info rules needed\n */\n\n\nvar ZoneInfoFile = function ZoneInfoFile(path) {\n  var that = this;\n\n  switch (_platform) {\n    /*\n    Uncomment and use this when enyo works for binary load.\n    case 'enyo':\n    \tlet ajax = new enyo.Ajax({\n    \t\txhrFields: {\n    \t\t\tresponseType:'arraybuffer'\n    \t\t},\n    \t\tcacheBust: false,\n    \t\tsync: true,\n    \t\thandleAs: 'binary',\n    \t\turl: 'file://' + path\n    \t});\n    \tajax.response(this, function (s, r) {\n    \t\tlet byteArray = new Uint8Array(r);\n    \t\t// console.log('ZoneInfoFile bytes received: ' + byteArray.length);\n    \t\tthat._parseInfo(byteArray);\n    \t});\n    \t//ajax.error(this, function (s, r) {\n    \t//\tconsole.log('ZoneInfoFile: failed to load files ' + JSON.stringify(s) + ' ' + r);\n    \t//});\n    \tajax.go();\n    \tbreak;\n    */\n    default:\n      {\n        // use normal web techniques for sync binary data fetching\n        // see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data\n        var req = new XMLHttpRequest();\n        req.open('GET', 'file:' + path, false);\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n\n        req.onload = function () {\n          var byteArray = new Uint8Array(req.response.length);\n\n          for (var i = 0; i < req.response.length; i++) {\n            byteArray[i] = req.response.charCodeAt(i) & 0xff;\n          } // console.log('ZoneInfoFile bytes received: ' + byteArray.length);\n\n\n          that._parseInfo(byteArray);\n        };\n\n        req.onerror = function () {\n          throw new Error('Cannot load file ' + path);\n        };\n\n        req.send();\n        break;\n      }\n  }\n};\n/**\n * @private\n * Parse the binary buffer to find the zone info\n * @param {Buffer} buffer The buffer to process\n * @returns {void}\n */\n\n\nZoneInfoFile.prototype._parseInfo = function (buffer) {\n  var packed = new PackedBuffer(buffer); // The time zone information files used by tzset(3)\n  // begin with the magic characters 'TZif' to identify\n  // them as time zone information files, followed by\n  // sixteen bytes reserved for future use, followed by\n  // six four-byte values of type long, written in a\n  // ''standard'' byte order (the high-order byte\n  // of the value is written first).\n\n  if (packed.getString(4) !== 'TZif') {\n    throw new Error('file format not recognized');\n  } else {\n    // ignore 16 bytes\n    packed.skip(16);\n    /* eslint-disable camelcase */\n    // The number of UTC/local indicators stored in the file.\n\n    var tzh_ttisgmtcnt = packed.getLong(); // The number of standard/wall indicators stored in the file.\n\n    var tzh_ttisstdcnt = packed.getLong(); // The number of leap seconds for which data is stored in the file.\n\n    var tzh_leapcnt = packed.getLong(); // The number of 'transition times' for which data is stored in the file.\n\n    var tzh_timecnt = packed.getLong(); // The number of 'local time types' for which data is stored in the file (must not be zero).\n\n    var tzh_typecnt = packed.getLong(); // The number of characters of 'time zone abbreviation strings' stored in the file.\n\n    var tzh_charcnt = packed.getLong();\n    this.transitionTimes = tzh_timecnt ? packed.getLongs(tzh_timecnt) : [];\n    this.transitionTimes = this.transitionTimes.map(function (item) {\n      return item * 1000;\n    }); // these are indexes into the zonesInfo that correspond to each transition time\n\n    this.ruleIndex = tzh_timecnt ? packed.getUnsignedBytes(tzh_timecnt) : [];\n    this.zoneInfo = [];\n\n    for (var i = 0; i < tzh_typecnt; i++) {\n      this.zoneInfo.push({\n        offset: Math.floor(packed.getLong() / 60),\n        // offset in seconds, so convert to minutes\n        isdst: !!packed.getByte(),\n        abbreviationIndex: packed.getByte()\n      });\n    }\n\n    var allAbbreviations = packed.getString(tzh_charcnt);\n\n    for (var _i = 0; _i < tzh_typecnt; _i++) {\n      var abbreviation = allAbbreviations.substring(this.zoneInfo[_i].abbreviationIndex);\n      this.zoneInfo[_i].abbreviation = abbreviation.substring(0, abbreviation.indexOf('\\x00'));\n    } // ignore the leap seconds\n\n\n    if (tzh_leapcnt) {\n      packed.skip(tzh_leapcnt * 2);\n    } // skip the standard/wall time indicators\n\n\n    if (tzh_ttisstdcnt) {\n      packed.skip(tzh_ttisstdcnt);\n    } // ignore the UTC/local time indicators -- everything should be UTC\n\n\n    if (tzh_ttisgmtcnt) {\n      packed.skip(tzh_ttisgmtcnt);\n    } // finished reading\n    // Replace ttinfo indexes for ttinfo objects.\n\n\n    var that = this;\n    this.ruleIndex = this.ruleIndex.map(function (item) {\n      return {\n        offset: that.zoneInfo[item].offset,\n        isdst: that.zoneInfo[item].isdst,\n        abbreviation: that.zoneInfo[item].abbreviation\n      };\n    }); // calculate the dst savings for each daylight time\n\n    for (var _i2 = 0; _i2 < tzh_timecnt; _i2++) {\n      if (_i2 > 0 && this.ruleIndex[_i2].isdst) {\n        this.ruleIndex[_i2].savings = this.ruleIndex[_i2].offset - this.ruleIndex[_i2 - 1].offset;\n      }\n    } // Set standard, dst, and before ttinfos. before will be\n    // used when a given time is before any transitions,\n    // and will be set to the first non-dst ttinfo, or to\n    // the first dst, if all of them are dst.\n\n\n    if (!this.transitionTimes.length) {\n      this.standardTime = this.zoneInfo[0];\n    } else {\n      for (var j = tzh_timecnt - 1; j > -1; j--) {\n        var tti = this.ruleIndex[j];\n\n        if (!this.standardTime && !tti.isdst) {\n          this.standardTime = tti;\n        } else if (!this.daylightTime && tti.isdst) {\n          this.daylightTime = tti;\n        }\n\n        if (this.daylightTime && this.standardTime) {\n          break;\n        }\n      }\n\n      if (this.daylightTime && !this.standardTime) {\n        this.standardTime = this.daylightTime;\n      }\n\n      for (var k = this.zoneInfo.length - 1; k > 0; k--) {\n        if (!this.zoneInfo[k].isdst) {\n          this.defaultTime = this.zoneInfo[k];\n          break;\n        }\n      }\n    }\n\n    if (!this.defaultTime) {\n      this.defaultTime = this.zoneInfo[this.zoneInfo.length - 1];\n    }\n  }\n};\n/**\n * Binary search a sorted array of numbers for a particular target value.\n * If the exact value is not found, it returns the index of the largest\n * entry that is smaller than the given target value.<p>\n *\n * @param {number} target element being sought\n * @param {Array} arr the array being searched\n * @returns {number} the index of the array into which the value would fit if\n * inserted, or -1 if given array is not an array or the target is not\n * a number\n */\n\n\nZoneInfoFile.prototype.bsearch = function (target, arr) {\n  if (typeof arr === 'undefined' || !arr || typeof target === 'undefined' || target < arr[0]) {\n    return -1;\n  } // greater than the end of the array\n\n\n  if (target > arr[arr.length - 1]) {\n    return arr.length - 1;\n  }\n\n  var high = arr.length - 1,\n      low = 0,\n      mid = 0,\n      value;\n\n  while (low <= high) {\n    mid = Math.floor((high + low) / 2);\n    value = arr[mid] - target;\n\n    if (value > 0) {\n      high = mid - 1;\n    } else if (value < 0) {\n      low = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return high;\n};\n/**\n * Return whether or not this zone uses DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {boolean} true if the zone uses DST in the given year\n */\n\n\nZoneInfoFile.prototype.usesDST = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for the zone that was effective Jan 1 of this year\n  // to Jan 1 of next year, and if any of the infos is DST, then\n  // this zone supports DST in the given year.\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n\n  if (index !== -1) {\n    while (index < this.transitionTimes.length && this.transitionTimes[index] < nextYear) {\n      if (this.ruleIndex[index++].isdst) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Return the raw offset from UTC that this zone uses at the given time.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} offset from from UTC in number of minutes. Negative\n * numbers are west of Greenwich, positive are east of Greenwich\n */\n\n\nZoneInfoFile.prototype.getRawOffset = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var offset = this.defaultTime.offset;\n\n  if (index > -1) {\n    while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n      offset = this.ruleIndex[index].offset;\n    }\n  }\n\n  return offset;\n};\n/**\n * If this zone uses DST in the given year, return the DST savings\n * in use. If the zone does not use DST in the given year, this\n * method will return 0.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} number of minutes in DST savings if the zone\n * uses DST in the given year, or zero otherwise\n */\n\n\nZoneInfoFile.prototype.getDSTSavings = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year\n  // from now, and calculate the difference in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var savings = 0;\n\n  if (index > -1) {\n    while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n      savings = this.ruleIndex[index].savings;\n    }\n  }\n\n  return savings;\n};\n/**\n * Return the start date/time of DST if this zone uses\n * DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} unixtime representation of the start\n * of DST in the given year, or -1 if the zone does not\n * use DST in the given year\n */\n\n\nZoneInfoFile.prototype.getDSTStartDate = function (date) {\n  var year = date.getFullYear();\n  var thisYear = new Date(year, 0, 1).getTime();\n  var nextYear = new Date(year + 1, 0, 1).getTime(); // search for all transitions between Jan 1 of this year\n  // to Jan 1 of next year, and calculate the difference\n  // in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var startDate = -1;\n\n  if (index > -1) {\n    if (this.transitionTimes[index] < thisYear) {\n      index++; // start in this year instead of the previous year\n    }\n\n    while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n      startDate = this.transitionTimes[index];\n    }\n  }\n\n  return startDate;\n};\n/**\n * Return the end date/time of DST if this zone uses\n * DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} unixtime representation of the end\n * of DST in the given year, or -1 if the zone does not\n * use DST in the given year\n */\n\n\nZoneInfoFile.prototype.getDSTEndDate = function (date) {\n  var year = date.getFullYear();\n  var thisYear = new Date(year, 0, 1).getTime();\n  var nextYear = new Date(year + 1, 0, 1).getTime(); // search for all transitions between Jan 1 of this year\n  // to Jan 1 of next year, and calculate the difference\n  // in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var endDate = -1;\n\n  if (index > -1) {\n    if (this.transitionTimes[index] < thisYear) {\n      index++; // start in this year instead of the previous year\n    }\n\n    while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n      endDate = this.transitionTimes[index];\n    }\n  }\n\n  return endDate;\n};\n/**\n * Return the abbreviation used by this zone in standard\n * time.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {string} a string representing the abbreviation\n * used in this time zone during standard time\n */\n\n\nZoneInfoFile.prototype.getAbbreviation = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year from now, and calculate the difference\n  // in DST (if any)\n\n  var abbr;\n\n  if (this.transitionTimes.length > 0) {\n    var index = this.bsearch(thisYear, this.transitionTimes);\n    abbr = this.ruleIndex[index].abbreviation;\n\n    if (index > -1) {\n      while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n        index++;\n      }\n\n      if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n        abbr = this.ruleIndex[index].abbreviation;\n      }\n    }\n  } else {\n    abbr = this.standardTime.abbreviation;\n  }\n\n  return abbr;\n};\n/**\n * Return the abbreviation used by this zone in daylight\n * time. If the zone does not use DST in the given year,\n * this returns the same thing as getAbbreviation().\n *\n * @param {Date} date the Gregorian date to test\n * @returns {string} a string representing the abbreviation\n * used in this time zone during daylight time\n */\n\n\nZoneInfoFile.prototype.getDSTAbbreviation = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year from now, and calculate the difference\n  // in DST (if any)\n\n  var abbr;\n\n  if (this.transitionTimes.length > 0) {\n    var index = this.bsearch(thisYear, this.transitionTimes);\n    abbr = this.ruleIndex[index].abbreviation;\n\n    if (index > -1) {\n      while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n        index++;\n      }\n\n      if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n        abbr = this.ruleIndex[index].abbreviation;\n      }\n    }\n  } else {\n    abbr = this.standardTime.abbreviation;\n  }\n\n  return abbr;\n};\n/**\n * Return the zone information for the given date in ilib\n * format.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {Object} an object containing the zone information\n * for the given date in the format that ilib can use directly\n */\n\n\nZoneInfoFile.prototype.getIlibZoneInfo = function (date) {\n  function minutesToStr(min) {\n    var hours = Math.floor(min / 60);\n    var minutes = min - hours * 60;\n    return hours + ':' + minutes;\n  }\n\n  function unixtimeToJD(millis) {\n    return 2440587.5 + millis / 86400000;\n  }\n\n  var res = {\n    'o': minutesToStr(this.getRawOffset(date))\n  };\n\n  if (this.usesDST(date)) {\n    res.f = '{c}';\n    res.e = {\n      'c': this.getAbbreviation(date),\n      'j': unixtimeToJD(this.getDSTEndDate(date))\n    };\n    res.s = {\n      'c': this.getDSTAbbreviation(date),\n      'j': unixtimeToJD(this.getDSTStartDate(date)),\n      'v': minutesToStr(this.getDSTSavings(date))\n    };\n  } else {\n    res.f = this.getAbbreviation(date);\n  }\n\n  return res;\n};\n\nmodule.exports = ZoneInfoFile;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/i18n/src/zoneinfo.js"],"names":["PackedBuffer","require","_platform","PalmSystem","ZoneInfoFile","path","that","req","XMLHttpRequest","open","overrideMimeType","onload","byteArray","Uint8Array","response","length","i","charCodeAt","_parseInfo","onerror","Error","send","prototype","buffer","packed","getString","skip","tzh_ttisgmtcnt","getLong","tzh_ttisstdcnt","tzh_leapcnt","tzh_timecnt","tzh_typecnt","tzh_charcnt","transitionTimes","getLongs","map","item","ruleIndex","getUnsignedBytes","zoneInfo","push","offset","Math","floor","isdst","getByte","abbreviationIndex","allAbbreviations","_i","abbreviation","substring","indexOf","_i2","savings","standardTime","j","tti","daylightTime","k","defaultTime","bsearch","target","arr","high","low","mid","value","usesDST","date","thisYear","getTime","nextYear","index","getRawOffset","getDSTSavings","getDSTStartDate","year","getFullYear","Date","startDate","getDSTEndDate","endDate","getAbbreviation","abbr","getDSTAbbreviation","getIlibZoneInfo","minutesToStr","min","hours","minutes","unixtimeToJD","millis","res","f","e","s","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/* eslint-env browser,es6 */\n\n/*\n * zoneinfo.js - represent a binary zone info file\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * The portion of this code that parses the zone info file format is derived\n * from the code in the node-zoneinfo project by Gregory McWhirter licensed\n * under the MIT license:\n *\n * Copyright (c) 2013 Gregory McWhirter\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject\n * to the following conditions:\n\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nvar PackedBuffer = require('./packedbuffer.js');\n\nvar _platform = typeof PalmSystem !== 'undefined' ? 'webos' : 'browser';\n/**\n * Represents a binary zone info file of the sort that the Unix Zone Info Compiler\n * produces.\n * @constructor\n * @param {string} path path to the file to be loaded\n * @param {number} year year of the zone info rules needed\n */\n\n\nvar ZoneInfoFile = function ZoneInfoFile(path) {\n  var that = this;\n\n  switch (_platform) {\n    /*\n    Uncomment and use this when enyo works for binary load.\n    case 'enyo':\n    \tlet ajax = new enyo.Ajax({\n    \t\txhrFields: {\n    \t\t\tresponseType:'arraybuffer'\n    \t\t},\n    \t\tcacheBust: false,\n    \t\tsync: true,\n    \t\thandleAs: 'binary',\n    \t\turl: 'file://' + path\n    \t});\n    \tajax.response(this, function (s, r) {\n    \t\tlet byteArray = new Uint8Array(r);\n    \t\t// console.log('ZoneInfoFile bytes received: ' + byteArray.length);\n    \t\tthat._parseInfo(byteArray);\n    \t});\n    \t//ajax.error(this, function (s, r) {\n    \t//\tconsole.log('ZoneInfoFile: failed to load files ' + JSON.stringify(s) + ' ' + r);\n    \t//});\n    \tajax.go();\n    \tbreak;\n    */\n    default:\n      {\n        // use normal web techniques for sync binary data fetching\n        // see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data\n        var req = new XMLHttpRequest();\n        req.open('GET', 'file:' + path, false);\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n\n        req.onload = function () {\n          var byteArray = new Uint8Array(req.response.length);\n\n          for (var i = 0; i < req.response.length; i++) {\n            byteArray[i] = req.response.charCodeAt(i) & 0xff;\n          } // console.log('ZoneInfoFile bytes received: ' + byteArray.length);\n\n\n          that._parseInfo(byteArray);\n        };\n\n        req.onerror = function () {\n          throw new Error('Cannot load file ' + path);\n        };\n\n        req.send();\n        break;\n      }\n  }\n};\n/**\n * @private\n * Parse the binary buffer to find the zone info\n * @param {Buffer} buffer The buffer to process\n * @returns {void}\n */\n\n\nZoneInfoFile.prototype._parseInfo = function (buffer) {\n  var packed = new PackedBuffer(buffer); // The time zone information files used by tzset(3)\n  // begin with the magic characters 'TZif' to identify\n  // them as time zone information files, followed by\n  // sixteen bytes reserved for future use, followed by\n  // six four-byte values of type long, written in a\n  // ''standard'' byte order (the high-order byte\n  // of the value is written first).\n\n  if (packed.getString(4) !== 'TZif') {\n    throw new Error('file format not recognized');\n  } else {\n    // ignore 16 bytes\n    packed.skip(16);\n    /* eslint-disable camelcase */\n    // The number of UTC/local indicators stored in the file.\n\n    var tzh_ttisgmtcnt = packed.getLong(); // The number of standard/wall indicators stored in the file.\n\n    var tzh_ttisstdcnt = packed.getLong(); // The number of leap seconds for which data is stored in the file.\n\n    var tzh_leapcnt = packed.getLong(); // The number of 'transition times' for which data is stored in the file.\n\n    var tzh_timecnt = packed.getLong(); // The number of 'local time types' for which data is stored in the file (must not be zero).\n\n    var tzh_typecnt = packed.getLong(); // The number of characters of 'time zone abbreviation strings' stored in the file.\n\n    var tzh_charcnt = packed.getLong();\n    this.transitionTimes = tzh_timecnt ? packed.getLongs(tzh_timecnt) : [];\n    this.transitionTimes = this.transitionTimes.map(function (item) {\n      return item * 1000;\n    }); // these are indexes into the zonesInfo that correspond to each transition time\n\n    this.ruleIndex = tzh_timecnt ? packed.getUnsignedBytes(tzh_timecnt) : [];\n    this.zoneInfo = [];\n\n    for (var i = 0; i < tzh_typecnt; i++) {\n      this.zoneInfo.push({\n        offset: Math.floor(packed.getLong() / 60),\n        // offset in seconds, so convert to minutes\n        isdst: !!packed.getByte(),\n        abbreviationIndex: packed.getByte()\n      });\n    }\n\n    var allAbbreviations = packed.getString(tzh_charcnt);\n\n    for (var _i = 0; _i < tzh_typecnt; _i++) {\n      var abbreviation = allAbbreviations.substring(this.zoneInfo[_i].abbreviationIndex);\n      this.zoneInfo[_i].abbreviation = abbreviation.substring(0, abbreviation.indexOf('\\x00'));\n    } // ignore the leap seconds\n\n\n    if (tzh_leapcnt) {\n      packed.skip(tzh_leapcnt * 2);\n    } // skip the standard/wall time indicators\n\n\n    if (tzh_ttisstdcnt) {\n      packed.skip(tzh_ttisstdcnt);\n    } // ignore the UTC/local time indicators -- everything should be UTC\n\n\n    if (tzh_ttisgmtcnt) {\n      packed.skip(tzh_ttisgmtcnt);\n    } // finished reading\n    // Replace ttinfo indexes for ttinfo objects.\n\n\n    var that = this;\n    this.ruleIndex = this.ruleIndex.map(function (item) {\n      return {\n        offset: that.zoneInfo[item].offset,\n        isdst: that.zoneInfo[item].isdst,\n        abbreviation: that.zoneInfo[item].abbreviation\n      };\n    }); // calculate the dst savings for each daylight time\n\n    for (var _i2 = 0; _i2 < tzh_timecnt; _i2++) {\n      if (_i2 > 0 && this.ruleIndex[_i2].isdst) {\n        this.ruleIndex[_i2].savings = this.ruleIndex[_i2].offset - this.ruleIndex[_i2 - 1].offset;\n      }\n    } // Set standard, dst, and before ttinfos. before will be\n    // used when a given time is before any transitions,\n    // and will be set to the first non-dst ttinfo, or to\n    // the first dst, if all of them are dst.\n\n\n    if (!this.transitionTimes.length) {\n      this.standardTime = this.zoneInfo[0];\n    } else {\n      for (var j = tzh_timecnt - 1; j > -1; j--) {\n        var tti = this.ruleIndex[j];\n\n        if (!this.standardTime && !tti.isdst) {\n          this.standardTime = tti;\n        } else if (!this.daylightTime && tti.isdst) {\n          this.daylightTime = tti;\n        }\n\n        if (this.daylightTime && this.standardTime) {\n          break;\n        }\n      }\n\n      if (this.daylightTime && !this.standardTime) {\n        this.standardTime = this.daylightTime;\n      }\n\n      for (var k = this.zoneInfo.length - 1; k > 0; k--) {\n        if (!this.zoneInfo[k].isdst) {\n          this.defaultTime = this.zoneInfo[k];\n          break;\n        }\n      }\n    }\n\n    if (!this.defaultTime) {\n      this.defaultTime = this.zoneInfo[this.zoneInfo.length - 1];\n    }\n  }\n};\n/**\n * Binary search a sorted array of numbers for a particular target value.\n * If the exact value is not found, it returns the index of the largest\n * entry that is smaller than the given target value.<p>\n *\n * @param {number} target element being sought\n * @param {Array} arr the array being searched\n * @returns {number} the index of the array into which the value would fit if\n * inserted, or -1 if given array is not an array or the target is not\n * a number\n */\n\n\nZoneInfoFile.prototype.bsearch = function (target, arr) {\n  if (typeof arr === 'undefined' || !arr || typeof target === 'undefined' || target < arr[0]) {\n    return -1;\n  } // greater than the end of the array\n\n\n  if (target > arr[arr.length - 1]) {\n    return arr.length - 1;\n  }\n\n  var high = arr.length - 1,\n      low = 0,\n      mid = 0,\n      value;\n\n  while (low <= high) {\n    mid = Math.floor((high + low) / 2);\n    value = arr[mid] - target;\n\n    if (value > 0) {\n      high = mid - 1;\n    } else if (value < 0) {\n      low = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return high;\n};\n/**\n * Return whether or not this zone uses DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {boolean} true if the zone uses DST in the given year\n */\n\n\nZoneInfoFile.prototype.usesDST = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for the zone that was effective Jan 1 of this year\n  // to Jan 1 of next year, and if any of the infos is DST, then\n  // this zone supports DST in the given year.\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n\n  if (index !== -1) {\n    while (index < this.transitionTimes.length && this.transitionTimes[index] < nextYear) {\n      if (this.ruleIndex[index++].isdst) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Return the raw offset from UTC that this zone uses at the given time.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} offset from from UTC in number of minutes. Negative\n * numbers are west of Greenwich, positive are east of Greenwich\n */\n\n\nZoneInfoFile.prototype.getRawOffset = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var offset = this.defaultTime.offset;\n\n  if (index > -1) {\n    while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n      offset = this.ruleIndex[index].offset;\n    }\n  }\n\n  return offset;\n};\n/**\n * If this zone uses DST in the given year, return the DST savings\n * in use. If the zone does not use DST in the given year, this\n * method will return 0.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} number of minutes in DST savings if the zone\n * uses DST in the given year, or zero otherwise\n */\n\n\nZoneInfoFile.prototype.getDSTSavings = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year\n  // from now, and calculate the difference in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var savings = 0;\n\n  if (index > -1) {\n    while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n      savings = this.ruleIndex[index].savings;\n    }\n  }\n\n  return savings;\n};\n/**\n * Return the start date/time of DST if this zone uses\n * DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} unixtime representation of the start\n * of DST in the given year, or -1 if the zone does not\n * use DST in the given year\n */\n\n\nZoneInfoFile.prototype.getDSTStartDate = function (date) {\n  var year = date.getFullYear();\n  var thisYear = new Date(year, 0, 1).getTime();\n  var nextYear = new Date(year + 1, 0, 1).getTime(); // search for all transitions between Jan 1 of this year\n  // to Jan 1 of next year, and calculate the difference\n  // in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var startDate = -1;\n\n  if (index > -1) {\n    if (this.transitionTimes[index] < thisYear) {\n      index++; // start in this year instead of the previous year\n    }\n\n    while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n      startDate = this.transitionTimes[index];\n    }\n  }\n\n  return startDate;\n};\n/**\n * Return the end date/time of DST if this zone uses\n * DST in the given year.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {number} unixtime representation of the end\n * of DST in the given year, or -1 if the zone does not\n * use DST in the given year\n */\n\n\nZoneInfoFile.prototype.getDSTEndDate = function (date) {\n  var year = date.getFullYear();\n  var thisYear = new Date(year, 0, 1).getTime();\n  var nextYear = new Date(year + 1, 0, 1).getTime(); // search for all transitions between Jan 1 of this year\n  // to Jan 1 of next year, and calculate the difference\n  // in DST (if any)\n\n  var index = this.bsearch(thisYear, this.transitionTimes);\n  var endDate = -1;\n\n  if (index > -1) {\n    if (this.transitionTimes[index] < thisYear) {\n      index++; // start in this year instead of the previous year\n    }\n\n    while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n      index++;\n    }\n\n    if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n      endDate = this.transitionTimes[index];\n    }\n  }\n\n  return endDate;\n};\n/**\n * Return the abbreviation used by this zone in standard\n * time.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {string} a string representing the abbreviation\n * used in this time zone during standard time\n */\n\n\nZoneInfoFile.prototype.getAbbreviation = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year from now, and calculate the difference\n  // in DST (if any)\n\n  var abbr;\n\n  if (this.transitionTimes.length > 0) {\n    var index = this.bsearch(thisYear, this.transitionTimes);\n    abbr = this.ruleIndex[index].abbreviation;\n\n    if (index > -1) {\n      while (index < this.transitionTimes.length && this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n        index++;\n      }\n\n      if (index < this.transitionTimes.length && !this.ruleIndex[index].isdst) {\n        abbr = this.ruleIndex[index].abbreviation;\n      }\n    }\n  } else {\n    abbr = this.standardTime.abbreviation;\n  }\n\n  return abbr;\n};\n/**\n * Return the abbreviation used by this zone in daylight\n * time. If the zone does not use DST in the given year,\n * this returns the same thing as getAbbreviation().\n *\n * @param {Date} date the Gregorian date to test\n * @returns {string} a string representing the abbreviation\n * used in this time zone during daylight time\n */\n\n\nZoneInfoFile.prototype.getDSTAbbreviation = function (date) {\n  var thisYear = date.getTime();\n  var nextYear = thisYear + 31536000000; // this is the number of ms in 1 Gregorian year\n  // search for all transitions between now and one year from now, and calculate the difference\n  // in DST (if any)\n\n  var abbr;\n\n  if (this.transitionTimes.length > 0) {\n    var index = this.bsearch(thisYear, this.transitionTimes);\n    abbr = this.ruleIndex[index].abbreviation;\n\n    if (index > -1) {\n      while (index < this.transitionTimes.length && !this.ruleIndex[index].isdst && this.transitionTimes[index + 1] < nextYear) {\n        index++;\n      }\n\n      if (index < this.transitionTimes.length && this.ruleIndex[index].isdst) {\n        abbr = this.ruleIndex[index].abbreviation;\n      }\n    }\n  } else {\n    abbr = this.standardTime.abbreviation;\n  }\n\n  return abbr;\n};\n/**\n * Return the zone information for the given date in ilib\n * format.\n *\n * @param {Date} date the Gregorian date to test\n * @returns {Object} an object containing the zone information\n * for the given date in the format that ilib can use directly\n */\n\n\nZoneInfoFile.prototype.getIlibZoneInfo = function (date) {\n  function minutesToStr(min) {\n    var hours = Math.floor(min / 60);\n    var minutes = min - hours * 60;\n    return hours + ':' + minutes;\n  }\n\n  function unixtimeToJD(millis) {\n    return 2440587.5 + millis / 86400000;\n  }\n\n  var res = {\n    'o': minutesToStr(this.getRawOffset(date))\n  };\n\n  if (this.usesDST(date)) {\n    res.f = '{c}';\n    res.e = {\n      'c': this.getAbbreviation(date),\n      'j': unixtimeToJD(this.getDSTEndDate(date))\n    };\n    res.s = {\n      'c': this.getDSTAbbreviation(date),\n      'j': unixtimeToJD(this.getDSTStartDate(date)),\n      'v': minutesToStr(this.getDSTSavings(date))\n    };\n  } else {\n    res.f = this.getAbbreviation(date);\n  }\n\n  return res;\n};\n\nmodule.exports = ZoneInfoFile;"]},"metadata":{},"sourceType":"module"}