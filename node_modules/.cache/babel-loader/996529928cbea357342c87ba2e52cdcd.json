{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeModal = exports.addModal = void 0;\n\nvar _dispatcher = require(\"@enact/core/dispatcher\"); // Contains references to modal Cancelable instances in LIFO order to allow multiple modals to be\n// displayed with the last having the first priority to handle the cancel.\n\n\nvar modals = [];\n/**\n * Dispatches the cancel event to each modal `Cancelable` instance. Consistent with\n * {@link core/handle.handle}, returning a `true` value means the event was handled and anything\n * falsy allows the event to pass to the next handler.\n *\n * @param\t{Object}\tev\tEvent payload\n *\n * @returns\t{undefined}\n * @private\n */\n\nvar dispatchToModals = function dispatchToModals(ev) {\n  for (var i = modals.length - 1, handled = false; !handled && i >= 0; i--) {\n    handled = modals[i].handleCancel(ev);\n  }\n};\n/**\n * Adds a modal `Cancelable` instance to the list of modals.\n *\n * @param\t{ui/Cancelable.Cancelable}\tobj\tCancelable instance\n *\n * @returns\t{undefined}\n * @private\n */\n\n\nvar addModal = function addModal(obj) {\n  if (modals.push(obj) === 1 && typeof window !== 'undefined') {\n    (0, _dispatcher.on)('keyup', dispatchToModals, window);\n  }\n};\n/**\n * Removes a modal `Cancelable` instance from the list of modals.\n *\n * @param\t{ui/Cancelable.Cancelable}\tobj\tCancelable instance\n *\n * @returns\t{undefined}\n * @private\n */\n\n\nexports.addModal = addModal;\n\nvar removeModal = function removeModal(obj) {\n  var index = modals.indexOf(obj);\n\n  if (index >= 0) {\n    modals.splice(index, 1);\n  }\n\n  if (modals.length === 0 && typeof window !== 'undefined') {\n    (0, _dispatcher.off)('keyup', dispatchToModals, window);\n  }\n};\n\nexports.removeModal = removeModal;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/ui/Cancelable/modalHandler.js"],"names":["Object","defineProperty","exports","value","removeModal","addModal","_dispatcher","require","modals","dispatchToModals","ev","i","length","handled","handleCancel","obj","push","window","on","index","indexOf","splice","off"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,WAAR,GAAsBF,OAAO,CAACG,QAAR,GAAmB,KAAK,CAA9C;;AAEA,IAAIC,WAAW,GAAGC,OAAO,CAAC,wBAAD,CAAzB,C,CAEA;AACA;;;AACA,IAAIC,MAAM,GAAG,EAAb;AACA;;;;;;;;;;;AAWA,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,EAA1B,EAA8B;AACnD,OAAK,IAAIC,CAAC,GAAGH,MAAM,CAACI,MAAP,GAAgB,CAAxB,EAA2BC,OAAO,GAAG,KAA1C,EAAiD,CAACA,OAAD,IAAYF,CAAC,IAAI,CAAlE,EAAqEA,CAAC,EAAtE,EAA0E;AACxEE,IAAAA,OAAO,GAAGL,MAAM,CAACG,CAAD,CAAN,CAAUG,YAAV,CAAuBJ,EAAvB,CAAV;AACD;AACF,CAJD;AAKA;;;;;;;;;;AAUA,IAAIL,QAAQ,GAAG,SAASA,QAAT,CAAkBU,GAAlB,EAAuB;AACpC,MAAIP,MAAM,CAACQ,IAAP,CAAYD,GAAZ,MAAqB,CAArB,IAA0B,OAAOE,MAAP,KAAkB,WAAhD,EAA6D;AAC3D,KAAC,GAAGX,WAAW,CAACY,EAAhB,EAAoB,OAApB,EAA6BT,gBAA7B,EAA+CQ,MAA/C;AACD;AACF,CAJD;AAKA;;;;;;;;;;AAUAf,OAAO,CAACG,QAAR,GAAmBA,QAAnB;;AAEA,IAAID,WAAW,GAAG,SAASA,WAAT,CAAqBW,GAArB,EAA0B;AAC1C,MAAII,KAAK,GAAGX,MAAM,CAACY,OAAP,CAAeL,GAAf,CAAZ;;AAEA,MAAII,KAAK,IAAI,CAAb,EAAgB;AACdX,IAAAA,MAAM,CAACa,MAAP,CAAcF,KAAd,EAAqB,CAArB;AACD;;AAED,MAAIX,MAAM,CAACI,MAAP,KAAkB,CAAlB,IAAuB,OAAOK,MAAP,KAAkB,WAA7C,EAA0D;AACxD,KAAC,GAAGX,WAAW,CAACgB,GAAhB,EAAqB,OAArB,EAA8Bb,gBAA9B,EAAgDQ,MAAhD;AACD;AACF,CAVD;;AAYAf,OAAO,CAACE,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeModal = exports.addModal = void 0;\n\nvar _dispatcher = require(\"@enact/core/dispatcher\");\n\n// Contains references to modal Cancelable instances in LIFO order to allow multiple modals to be\n// displayed with the last having the first priority to handle the cancel.\nvar modals = [];\n/**\n * Dispatches the cancel event to each modal `Cancelable` instance. Consistent with\n * {@link core/handle.handle}, returning a `true` value means the event was handled and anything\n * falsy allows the event to pass to the next handler.\n *\n * @param\t{Object}\tev\tEvent payload\n *\n * @returns\t{undefined}\n * @private\n */\n\nvar dispatchToModals = function dispatchToModals(ev) {\n  for (var i = modals.length - 1, handled = false; !handled && i >= 0; i--) {\n    handled = modals[i].handleCancel(ev);\n  }\n};\n/**\n * Adds a modal `Cancelable` instance to the list of modals.\n *\n * @param\t{ui/Cancelable.Cancelable}\tobj\tCancelable instance\n *\n * @returns\t{undefined}\n * @private\n */\n\n\nvar addModal = function addModal(obj) {\n  if (modals.push(obj) === 1 && typeof window !== 'undefined') {\n    (0, _dispatcher.on)('keyup', dispatchToModals, window);\n  }\n};\n/**\n * Removes a modal `Cancelable` instance from the list of modals.\n *\n * @param\t{ui/Cancelable.Cancelable}\tobj\tCancelable instance\n *\n * @returns\t{undefined}\n * @private\n */\n\n\nexports.addModal = addModal;\n\nvar removeModal = function removeModal(obj) {\n  var index = modals.indexOf(obj);\n\n  if (index >= 0) {\n    modals.splice(index, 1);\n  }\n\n  if (modals.length === 0 && typeof window !== 'undefined') {\n    (0, _dispatcher.off)('keyup', dispatchToModals, window);\n  }\n};\n\nexports.removeModal = removeModal;"]},"metadata":{},"sourceType":"module"}