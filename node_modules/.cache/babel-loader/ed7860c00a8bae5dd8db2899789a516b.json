{"ast":null,"code":"\"use strict\";\n/*\n * HanDate.js - Represent a date in the Han algorithmic calendar\n * \n * Copyright © 2014-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends\nilib.js\nIDate.js\nGregorianDate.js \nHanCal.js\nAstro.js \nJSUtils.js\nMathUtils.js\nLocaleInfo.js \nLocale.js\nTimeZone.js\nHanRataDie.js\nRataDie.js\n*/\n\nvar ilib = require(\"./ilib.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IDate = require(\"./IDate.js\");\n\nvar TimeZone = require(\"./TimeZone.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar Astro = require(\"./Astro.js\");\n\nvar HanCal = require(\"./HanCal.js\");\n\nvar GregorianDate = require(\"./GregorianDate.js\");\n\nvar HanRataDie = require(\"./HanRataDie.js\");\n\nvar RataDie = require(\"./RataDie.js\");\n/**\n * @class\n * \n * Construct a new Han date object. The constructor parameters can \n * contain any of the following properties:\n * \n * <ul>\n * <li><i>unixtime<i> - sets the time of this instance according to the given \n * unix time. Unix time is the number of milliseconds since midnight on Jan 1, 1970, Gregorian\n * \n * <li><i>julianday</i> - sets the time of this instance according to the given\n * Julian Day instance or the Julian Day given as a float\n * \n * <li><i>cycle</i> - any integer giving the number of 60-year cycle in which the date is located.\n * If the cycle is not given but the year is, it is assumed that the year parameter is a fictitious \n * linear count of years since the beginning of the epoch, much like other calendars. This linear\n * count is never used. If both the cycle and year are given, the year is wrapped to the range 0 \n * to 60 and treated as if it were a year in the regular 60-year cycle.\n * \n * <li><i>year</i> - any integer, including 0\n * \n * <li><i>month</i> - 1 to 12, where 1 means Farvardin, 2 means Ordibehesht, etc.\n * \n * <li><i>day</i> - 1 to 31\n * \n * <li><i>hour</i> - 0 to 23. A formatter is used to display 12 hour clocks, but this representation \n * is always done with an unambiguous 24 hour representation\n * \n * <li><i>minute</i> - 0 to 59\n * \n * <li><i>second</i> - 0 to 59\n * \n * <li><i>millisecond</i> - 0 to 999\n * \n * <li><i>timezone</i> - the TimeZone instance or time zone name as a string \n * of this han date. The date/time is kept in the local time. The time zone\n * is used later if this date is formatted according to a different time zone and\n * the difference has to be calculated, or when the date format has a time zone\n * component in it.\n * \n * <li><i>locale</i> - locale for this han date. If the time zone is not \n * given, it can be inferred from this locale. For locales that span multiple\n * time zones, the one with the largest population is chosen as the one that \n * represents the locale.\n * \n * <li><i>date</i> - use the given intrinsic Javascript date to initialize this one.\n * </ul>\n *\n * If the constructor is called with another Han date instance instead of\n * a parameter block, the other instance acts as a parameter block and its\n * settings are copied into the current instance.<p>\n * \n * If the constructor is called with no arguments at all or if none of the \n * properties listed above \n * from <i>unixtime</i> through <i>millisecond</i> are present, then the date \n * components are \n * filled in with the current date at the time of instantiation. Note that if\n * you do not give the time zone when defaulting to the current time and the \n * time zone for all of ilib was not set with <i>ilib.setTimeZone()</i>, then the\n * time zone will default to UTC (\"Universal Time, Coordinated\" or \"Greenwich \n * Mean Time\").<p>\n * \n * If any of the properties from <i>year</i> through <i>millisecond</i> are not\n * specified in the params, it is assumed that they have the smallest possible\n * value in the range for the property (zero or one).<p>\n * \n * \n * @constructor\n * @extends Date\n * @param {Object=} params parameters that govern the settings and behaviour of this Han date\n */\n\n\nvar HanDate = function HanDate(params) {\n  params = params || {};\n\n  if (params.locale) {\n    this.locale = typeof params.locale === 'string' ? new Locale(params.locale) : params.locale;\n  }\n\n  if (params.timezone) {\n    this.timezone = params.timezone;\n  }\n\n  if (!this.timezone) {\n    if (this.locale) {\n      new LocaleInfo(this.locale, {\n        sync: params.sync,\n        loadParams: params.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.timezone = li.getTimeZone();\n\n          this._init(params);\n        })\n      });\n    } else {\n      this.timezone = \"local\";\n\n      this._init(params);\n    }\n  } else {\n    this._init(params);\n  }\n};\n\nHanDate.prototype = new IDate({\n  noinstance: true\n});\nHanDate.prototype.parent = IDate;\nHanDate.prototype.constructor = HanDate;\n/**\n * Initialize the han date\n * @private\n */\n\nHanDate.prototype._init = function (params) {\n  new HanCal({\n    sync: params && typeof params.sync === 'boolean' ? params.sync : true,\n    loadParams: params && params.loadParams,\n    onLoad: ilib.bind(this, function (cal) {\n      this.cal = cal;\n\n      if (params.year || params.month || params.day || params.hour || params.minute || params.second || params.millisecond || params.cycle || params.cycleYear) {\n        if (typeof params.cycle !== 'undefined') {\n          /**\n           * Cycle number in the Han calendar.\n           * @type number\n           */\n          this.cycle = parseInt(params.cycle, 10) || 0;\n          var year = (typeof params.year !== 'undefined' ? parseInt(params.year, 10) : parseInt(params.cycleYear, 10)) || 0;\n          /**\n           * Year in the Han calendar.\n           * @type number\n           */\n\n          this.year = HanCal._getElapsedYear(year, this.cycle);\n        } else {\n          if (typeof params.year !== 'undefined') {\n            this.year = parseInt(params.year, 10) || 0;\n            this.cycle = Math.floor((this.year - 1) / 60);\n          } else {\n            this.year = this.cycle = 0;\n          }\n        }\n        /**\n         * The month number, ranging from 1 to 13\n         * @type number\n         */\n\n\n        this.month = parseInt(params.month, 10) || 1;\n        /**\n         * The day of the month. This ranges from 1 to 30.\n         * @type number\n         */\n\n        this.day = parseInt(params.day, 10) || 1;\n        /**\n         * The hour of the day. This can be a number from 0 to 23, as times are\n         * stored unambiguously in the 24-hour clock.\n         * @type number\n         */\n\n        this.hour = parseInt(params.hour, 10) || 0;\n        /**\n         * The minute of the hours. Ranges from 0 to 59.\n         * @type number\n         */\n\n        this.minute = parseInt(params.minute, 10) || 0;\n        /**\n         * The second of the minute. Ranges from 0 to 59.\n         * @type number\n         */\n\n        this.second = parseInt(params.second, 10) || 0;\n        /**\n         * The millisecond of the second. Ranges from 0 to 999.\n         * @type number\n         */\n\n        this.millisecond = parseInt(params.millisecond, 10) || 0; // derived properties\n\n        /**\n         * Year in the cycle of the Han calendar\n         * @type number\n         */\n\n        this.cycleYear = MathUtils.amod(this.year, 60);\n        /**\n         * The day of the year. Ranges from 1 to 384.\n         * @type number\n         */\n\n        this.dayOfYear = parseInt(params.dayOfYear, 10);\n\n        if (typeof params.dst === 'boolean') {\n          this.dst = params.dst;\n        }\n\n        this.newRd({\n          cal: this.cal,\n          cycle: this.cycle,\n          year: this.year,\n          month: this.month,\n          day: this.day,\n          hour: this.hour,\n          minute: this.minute,\n          second: this.second,\n          millisecond: this.millisecond,\n          sync: params.sync,\n          loadParams: params.loadParams,\n          callback: ilib.bind(this, function (rd) {\n            if (rd) {\n              this.rd = rd; // add the time zone offset to the rd to convert to UTC\n\n              new TimeZone({\n                id: this.timezone,\n                sync: params.sync,\n                loadParams: params.loadParams,\n                onLoad: ilib.bind(this, function (tz) {\n                  this.tz = tz; // getOffsetMillis requires that this.year, this.rd, and this.dst \n                  // are set in order to figure out which time zone rules apply and \n                  // what the offset is at that point in the year\n\n                  this.offset = this.tz._getOffsetMillisWallTime(this) / 86400000;\n\n                  if (this.offset !== 0) {\n                    // this newRd can be called synchronously because we already called\n                    // it asynchronously above, so all of the astro data should \n                    // already be loaded.\n                    this.rd = this.newRd({\n                      cal: this.cal,\n                      rd: this.rd.getRataDie() - this.offset\n                    });\n\n                    this._calcLeap();\n                  } else {\n                    // re-use the derived properties from the RD calculations\n                    this.leapMonth = this.rd.leapMonth;\n                    this.priorLeapMonth = this.rd.priorLeapMonth;\n                    this.leapYear = this.rd.leapYear;\n                  }\n\n                  this._init2(params);\n                })\n              });\n            } else {\n              this._init2(params);\n            }\n          })\n        });\n      } else {\n        this._init2(params);\n      }\n    })\n  });\n};\n/**\n * Finish the initialization for the han date.\n * @private\n */\n\n\nHanDate.prototype._init2 = function (params) {\n  if (!this.rd) {\n    // init2() may be called without newRd having been called before,\n    // so we cannot guarantee that the astro data is already loaded.\n    // That means, we have to treat this as a possibly asynchronous\n    // call.\n    this.newRd(JSUtils.merge(params || {}, {\n      cal: this.cal,\n      sync: params.sync,\n      loadParams: params.loadParams,\n      callback: ilib.bind(this, function (rd) {\n        this.rd = rd;\n\n        this._calcDateComponents();\n\n        if (params && typeof params.onLoad === 'function') {\n          params.onLoad(this);\n        }\n      })\n    }));\n  } else {\n    if (params && typeof params.onLoad === 'function') {\n      params.onLoad(this);\n    }\n  }\n};\n/**\n * Return a new RD for this date type using the given params.\n * @protected\n * @param {Object=} params the parameters used to create this rata die instance\n * @returns {RataDie} the new RD instance for the given params\n */\n\n\nHanDate.prototype.newRd = function (params) {\n  return new HanRataDie(params);\n};\n/**\n * Return the year for the given RD\n * @protected\n * @param {number} rd RD to calculate from \n * @returns {number} the year for the RD\n */\n\n\nHanDate.prototype._calcYear = function (rd) {\n  var gregdate = new GregorianDate({\n    rd: rd,\n    timezone: this.timezone\n  });\n  var hanyear = gregdate.year + 2697;\n  var newYears = this.cal.newYears(hanyear);\n  return hanyear - (rd + RataDie.gregorianEpoch < newYears ? 1 : 0);\n};\n/** \n * @private \n * Calculate the leap year and months from the RD.\n */\n\n\nHanDate.prototype._calcLeap = function () {\n  var jd = this.rd.getRataDie() + RataDie.gregorianEpoch;\n\n  var calc = HanCal._leapYearCalc(this.year);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n  var newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2;\n\n  var m = HanCal._newMoonBefore(jd + 1);\n\n  this.priorLeapMonth = HanRataDie._priorLeapMonth(newYears, HanCal._newMoonBefore(m));\n  this.leapMonth = this.leapYear && HanCal._noMajorST(m) && !this.priorLeapMonth;\n};\n/**\n * @private\n * Calculate date components for the given RD date.\n */\n\n\nHanDate.prototype._calcDateComponents = function () {\n  var remainder,\n      jd = this.rd.getRataDie() + RataDie.gregorianEpoch; // console.log(\"HanDate._calcDateComponents: calculating for jd \" + jd);\n\n  if (typeof this.offset === \"undefined\") {\n    // now offset the jd by the time zone, then recalculate in case we were \n    // near the year boundary\n    if (!this.tz) {\n      this.tz = new TimeZone({\n        id: this.timezone\n      });\n    }\n\n    this.offset = this.tz.getOffsetMillis(this) / 86400000;\n  }\n\n  if (this.offset !== 0) {\n    jd += this.offset;\n  } // use the Gregorian calendar objects as a convenient way to short-cut some\n  // of the date calculations\n\n\n  var gregyear = GregorianDate._calcYear(this.rd.getRataDie());\n\n  this.year = gregyear + 2697;\n\n  var calc = HanCal._leapYearCalc(this.year);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n  var newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2; // See if it's between Jan 1 and the Chinese new years of that Gregorian year. If\n  // so, then the Han year is actually the previous one\n\n  if (jd < newYears) {\n    this.year--;\n    calc = HanCal._leapYearCalc(this.year);\n    m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n    this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n    newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2;\n  } // month is elapsed month, not the month number + leap month boolean\n\n\n  var m = HanCal._newMoonBefore(jd + 1);\n\n  this.month = Math.round((m - calc.m1) / 29.530588853000001);\n  this.priorLeapMonth = HanRataDie._priorLeapMonth(newYears, HanCal._newMoonBefore(m));\n  this.leapMonth = this.leapYear && HanCal._noMajorST(m) && !this.priorLeapMonth;\n  this.cycle = Math.floor((this.year - 1) / 60);\n  this.cycleYear = MathUtils.amod(this.year, 60);\n  this.day = Astro._floorToJD(jd) - m + 1;\n  /*\n  console.log(\"HanDate._calcDateComponents: year is \" + this.year);\n  console.log(\"HanDate._calcDateComponents: isLeapYear is \" + this.leapYear);\n  console.log(\"HanDate._calcDateComponents: cycle is \" + this.cycle);\n  console.log(\"HanDate._calcDateComponents: cycleYear is \" + this.cycleYear);\n  console.log(\"HanDate._calcDateComponents: month is \" + this.month);\n  console.log(\"HanDate._calcDateComponents: isLeapMonth is \" + this.leapMonth);\n  console.log(\"HanDate._calcDateComponents: day is \" + this.day);\n  */\n  // floor to the start of the julian day\n\n  remainder = jd - Astro._floorToJD(jd); // console.log(\"HanDate._calcDateComponents: time remainder is \" + remainder);\n  // now convert to milliseconds for the rest of the calculation\n\n  remainder = Math.round(remainder * 86400000);\n  this.hour = Math.floor(remainder / 3600000);\n  remainder -= this.hour * 3600000;\n  this.minute = Math.floor(remainder / 60000);\n  remainder -= this.minute * 60000;\n  this.second = Math.floor(remainder / 1000);\n  remainder -= this.second * 1000;\n  this.millisecond = remainder;\n};\n/**\n * Return the year within the Chinese cycle of this date. Cycles are 60 \n * years long, and the value returned from this method is the number of the year \n * within this cycle. The year returned from getYear() is the total elapsed \n * years since the beginning of the Chinese epoch and does not include \n * the cycles. \n * \n * @return {number} the year within the current Chinese cycle\n */\n\n\nHanDate.prototype.getCycleYears = function () {\n  return this.cycleYear;\n};\n/**\n * Return the Chinese cycle number of this date. Cycles are 60 years long,\n * and the value returned from getCycleYear() is the number of the year \n * within this cycle. The year returned from getYear() is the total elapsed \n * years since the beginning of the Chinese epoch and does not include \n * the cycles. \n * \n * @return {number} the current Chinese cycle\n */\n\n\nHanDate.prototype.getCycles = function () {\n  return this.cycle;\n};\n/**\n * Return whether the year of this date is a leap year in the Chinese Han \n * calendar. \n * \n * @return {boolean} true if the year of this date is a leap year in the \n * Chinese Han calendar. \n */\n\n\nHanDate.prototype.isLeapYear = function () {\n  return this.leapYear;\n};\n/**\n * Return whether the month of this date is a leap month in the Chinese Han \n * calendar.\n * \n * @return {boolean} true if the month of this date is a leap month in the \n * Chinese Han calendar.\n */\n\n\nHanDate.prototype.isLeapMonth = function () {\n  return this.leapMonth;\n};\n/**\n * Return the day of the week of this date. The day of the week is encoded\n * as number from 0 to 6, with 0=Sunday, 1=Monday, etc., until 6=Saturday.\n * \n * @return {number} the day of the week\n */\n\n\nHanDate.prototype.getDayOfWeek = function () {\n  var rd = Math.floor(this.rd.getRataDie() + (this.offset || 0));\n  return MathUtils.mod(rd, 7);\n};\n/**\n * Return the ordinal day of the year. Days are counted from 1 and proceed linearly up to \n * 365, regardless of months or weeks, etc. That is, Farvardin 1st is day 1, and \n * December 31st is 365 in regular years, or 366 in leap years.\n * @return {number} the ordinal day of the year\n */\n\n\nHanDate.prototype.getDayOfYear = function () {\n  var newYears = this.cal.newYears(this.year);\n\n  var priorNewMoon = HanCal._newMoonOnOrAfter(newYears + (this.month - 1) * 29);\n\n  return priorNewMoon - newYears + this.day;\n};\n/**\n * Return the era for this date as a number. The value for the era for Han \n * calendars is -1 for \"before the han era\" (BP) and 1 for \"the han era\" (anno \n * persico or AP). \n * BP dates are any date before Farvardin 1, 1 AP. In the proleptic Han calendar, \n * there is a year 0, so any years that are negative or zero are BP.\n * @return {number} 1 if this date is in the common era, -1 if it is before the \n * common era \n */\n\n\nHanDate.prototype.getEra = function () {\n  return this.year < 1 ? -1 : 1;\n};\n/**\n * Return the name of the calendar that governs this date.\n * \n * @return {string} a string giving the name of the calendar\n */\n\n\nHanDate.prototype.getCalendar = function () {\n  return \"han\";\n}; // register with the factory method\n\n\nIDate._constructors[\"han\"] = HanDate;\nmodule.exports = HanDate;","map":{"version":3,"sources":["/home/cdi/SteApp/node_modules/@enact/i18n/ilib/lib/HanDate.js"],"names":["ilib","require","JSUtils","MathUtils","Locale","LocaleInfo","IDate","TimeZone","Calendar","Astro","HanCal","GregorianDate","HanRataDie","RataDie","HanDate","params","locale","timezone","sync","loadParams","onLoad","bind","li","getTimeZone","_init","prototype","noinstance","parent","constructor","cal","year","month","day","hour","minute","second","millisecond","cycle","cycleYear","parseInt","_getElapsedYear","Math","floor","amod","dayOfYear","dst","newRd","callback","rd","id","tz","offset","_getOffsetMillisWallTime","getRataDie","_calcLeap","leapMonth","priorLeapMonth","leapYear","_init2","merge","_calcDateComponents","_calcYear","gregdate","hanyear","newYears","gregorianEpoch","jd","calc","_leapYearCalc","m2","_newMoonOnOrAfter","m1","round","_noMajorST","m","_newMoonBefore","_priorLeapMonth","remainder","getOffsetMillis","gregyear","_floorToJD","getCycleYears","getCycles","isLeapYear","isLeapMonth","getDayOfWeek","mod","getDayOfYear","priorNewMoon","getEra","getCalendar","_constructors","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * HanDate.js - Represent a date in the Han algorithmic calendar\n * \n * Copyright © 2014-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends\nilib.js\nIDate.js\nGregorianDate.js \nHanCal.js\nAstro.js \nJSUtils.js\nMathUtils.js\nLocaleInfo.js \nLocale.js\nTimeZone.js\nHanRataDie.js\nRataDie.js\n*/\nvar ilib = require(\"./ilib.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IDate = require(\"./IDate.js\");\n\nvar TimeZone = require(\"./TimeZone.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar Astro = require(\"./Astro.js\");\n\nvar HanCal = require(\"./HanCal.js\");\n\nvar GregorianDate = require(\"./GregorianDate.js\");\n\nvar HanRataDie = require(\"./HanRataDie.js\");\n\nvar RataDie = require(\"./RataDie.js\");\n/**\n * @class\n * \n * Construct a new Han date object. The constructor parameters can \n * contain any of the following properties:\n * \n * <ul>\n * <li><i>unixtime<i> - sets the time of this instance according to the given \n * unix time. Unix time is the number of milliseconds since midnight on Jan 1, 1970, Gregorian\n * \n * <li><i>julianday</i> - sets the time of this instance according to the given\n * Julian Day instance or the Julian Day given as a float\n * \n * <li><i>cycle</i> - any integer giving the number of 60-year cycle in which the date is located.\n * If the cycle is not given but the year is, it is assumed that the year parameter is a fictitious \n * linear count of years since the beginning of the epoch, much like other calendars. This linear\n * count is never used. If both the cycle and year are given, the year is wrapped to the range 0 \n * to 60 and treated as if it were a year in the regular 60-year cycle.\n * \n * <li><i>year</i> - any integer, including 0\n * \n * <li><i>month</i> - 1 to 12, where 1 means Farvardin, 2 means Ordibehesht, etc.\n * \n * <li><i>day</i> - 1 to 31\n * \n * <li><i>hour</i> - 0 to 23. A formatter is used to display 12 hour clocks, but this representation \n * is always done with an unambiguous 24 hour representation\n * \n * <li><i>minute</i> - 0 to 59\n * \n * <li><i>second</i> - 0 to 59\n * \n * <li><i>millisecond</i> - 0 to 999\n * \n * <li><i>timezone</i> - the TimeZone instance or time zone name as a string \n * of this han date. The date/time is kept in the local time. The time zone\n * is used later if this date is formatted according to a different time zone and\n * the difference has to be calculated, or when the date format has a time zone\n * component in it.\n * \n * <li><i>locale</i> - locale for this han date. If the time zone is not \n * given, it can be inferred from this locale. For locales that span multiple\n * time zones, the one with the largest population is chosen as the one that \n * represents the locale.\n * \n * <li><i>date</i> - use the given intrinsic Javascript date to initialize this one.\n * </ul>\n *\n * If the constructor is called with another Han date instance instead of\n * a parameter block, the other instance acts as a parameter block and its\n * settings are copied into the current instance.<p>\n * \n * If the constructor is called with no arguments at all or if none of the \n * properties listed above \n * from <i>unixtime</i> through <i>millisecond</i> are present, then the date \n * components are \n * filled in with the current date at the time of instantiation. Note that if\n * you do not give the time zone when defaulting to the current time and the \n * time zone for all of ilib was not set with <i>ilib.setTimeZone()</i>, then the\n * time zone will default to UTC (\"Universal Time, Coordinated\" or \"Greenwich \n * Mean Time\").<p>\n * \n * If any of the properties from <i>year</i> through <i>millisecond</i> are not\n * specified in the params, it is assumed that they have the smallest possible\n * value in the range for the property (zero or one).<p>\n * \n * \n * @constructor\n * @extends Date\n * @param {Object=} params parameters that govern the settings and behaviour of this Han date\n */\n\n\nvar HanDate = function HanDate(params) {\n  params = params || {};\n\n  if (params.locale) {\n    this.locale = typeof params.locale === 'string' ? new Locale(params.locale) : params.locale;\n  }\n\n  if (params.timezone) {\n    this.timezone = params.timezone;\n  }\n\n  if (!this.timezone) {\n    if (this.locale) {\n      new LocaleInfo(this.locale, {\n        sync: params.sync,\n        loadParams: params.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.timezone = li.getTimeZone();\n\n          this._init(params);\n        })\n      });\n    } else {\n      this.timezone = \"local\";\n\n      this._init(params);\n    }\n  } else {\n    this._init(params);\n  }\n};\n\nHanDate.prototype = new IDate({\n  noinstance: true\n});\nHanDate.prototype.parent = IDate;\nHanDate.prototype.constructor = HanDate;\n/**\n * Initialize the han date\n * @private\n */\n\nHanDate.prototype._init = function (params) {\n  new HanCal({\n    sync: params && typeof params.sync === 'boolean' ? params.sync : true,\n    loadParams: params && params.loadParams,\n    onLoad: ilib.bind(this, function (cal) {\n      this.cal = cal;\n\n      if (params.year || params.month || params.day || params.hour || params.minute || params.second || params.millisecond || params.cycle || params.cycleYear) {\n        if (typeof params.cycle !== 'undefined') {\n          /**\n           * Cycle number in the Han calendar.\n           * @type number\n           */\n          this.cycle = parseInt(params.cycle, 10) || 0;\n          var year = (typeof params.year !== 'undefined' ? parseInt(params.year, 10) : parseInt(params.cycleYear, 10)) || 0;\n          /**\n           * Year in the Han calendar.\n           * @type number\n           */\n\n          this.year = HanCal._getElapsedYear(year, this.cycle);\n        } else {\n          if (typeof params.year !== 'undefined') {\n            this.year = parseInt(params.year, 10) || 0;\n            this.cycle = Math.floor((this.year - 1) / 60);\n          } else {\n            this.year = this.cycle = 0;\n          }\n        }\n        /**\n         * The month number, ranging from 1 to 13\n         * @type number\n         */\n\n\n        this.month = parseInt(params.month, 10) || 1;\n        /**\n         * The day of the month. This ranges from 1 to 30.\n         * @type number\n         */\n\n        this.day = parseInt(params.day, 10) || 1;\n        /**\n         * The hour of the day. This can be a number from 0 to 23, as times are\n         * stored unambiguously in the 24-hour clock.\n         * @type number\n         */\n\n        this.hour = parseInt(params.hour, 10) || 0;\n        /**\n         * The minute of the hours. Ranges from 0 to 59.\n         * @type number\n         */\n\n        this.minute = parseInt(params.minute, 10) || 0;\n        /**\n         * The second of the minute. Ranges from 0 to 59.\n         * @type number\n         */\n\n        this.second = parseInt(params.second, 10) || 0;\n        /**\n         * The millisecond of the second. Ranges from 0 to 999.\n         * @type number\n         */\n\n        this.millisecond = parseInt(params.millisecond, 10) || 0; // derived properties\n\n        /**\n         * Year in the cycle of the Han calendar\n         * @type number\n         */\n\n        this.cycleYear = MathUtils.amod(this.year, 60);\n        /**\n         * The day of the year. Ranges from 1 to 384.\n         * @type number\n         */\n\n        this.dayOfYear = parseInt(params.dayOfYear, 10);\n\n        if (typeof params.dst === 'boolean') {\n          this.dst = params.dst;\n        }\n\n        this.newRd({\n          cal: this.cal,\n          cycle: this.cycle,\n          year: this.year,\n          month: this.month,\n          day: this.day,\n          hour: this.hour,\n          minute: this.minute,\n          second: this.second,\n          millisecond: this.millisecond,\n          sync: params.sync,\n          loadParams: params.loadParams,\n          callback: ilib.bind(this, function (rd) {\n            if (rd) {\n              this.rd = rd; // add the time zone offset to the rd to convert to UTC\n\n              new TimeZone({\n                id: this.timezone,\n                sync: params.sync,\n                loadParams: params.loadParams,\n                onLoad: ilib.bind(this, function (tz) {\n                  this.tz = tz; // getOffsetMillis requires that this.year, this.rd, and this.dst \n                  // are set in order to figure out which time zone rules apply and \n                  // what the offset is at that point in the year\n\n                  this.offset = this.tz._getOffsetMillisWallTime(this) / 86400000;\n\n                  if (this.offset !== 0) {\n                    // this newRd can be called synchronously because we already called\n                    // it asynchronously above, so all of the astro data should \n                    // already be loaded.\n                    this.rd = this.newRd({\n                      cal: this.cal,\n                      rd: this.rd.getRataDie() - this.offset\n                    });\n\n                    this._calcLeap();\n                  } else {\n                    // re-use the derived properties from the RD calculations\n                    this.leapMonth = this.rd.leapMonth;\n                    this.priorLeapMonth = this.rd.priorLeapMonth;\n                    this.leapYear = this.rd.leapYear;\n                  }\n\n                  this._init2(params);\n                })\n              });\n            } else {\n              this._init2(params);\n            }\n          })\n        });\n      } else {\n        this._init2(params);\n      }\n    })\n  });\n};\n/**\n * Finish the initialization for the han date.\n * @private\n */\n\n\nHanDate.prototype._init2 = function (params) {\n  if (!this.rd) {\n    // init2() may be called without newRd having been called before,\n    // so we cannot guarantee that the astro data is already loaded.\n    // That means, we have to treat this as a possibly asynchronous\n    // call.\n    this.newRd(JSUtils.merge(params || {}, {\n      cal: this.cal,\n      sync: params.sync,\n      loadParams: params.loadParams,\n      callback: ilib.bind(this, function (rd) {\n        this.rd = rd;\n\n        this._calcDateComponents();\n\n        if (params && typeof params.onLoad === 'function') {\n          params.onLoad(this);\n        }\n      })\n    }));\n  } else {\n    if (params && typeof params.onLoad === 'function') {\n      params.onLoad(this);\n    }\n  }\n};\n/**\n * Return a new RD for this date type using the given params.\n * @protected\n * @param {Object=} params the parameters used to create this rata die instance\n * @returns {RataDie} the new RD instance for the given params\n */\n\n\nHanDate.prototype.newRd = function (params) {\n  return new HanRataDie(params);\n};\n/**\n * Return the year for the given RD\n * @protected\n * @param {number} rd RD to calculate from \n * @returns {number} the year for the RD\n */\n\n\nHanDate.prototype._calcYear = function (rd) {\n  var gregdate = new GregorianDate({\n    rd: rd,\n    timezone: this.timezone\n  });\n  var hanyear = gregdate.year + 2697;\n  var newYears = this.cal.newYears(hanyear);\n  return hanyear - (rd + RataDie.gregorianEpoch < newYears ? 1 : 0);\n};\n/** \n * @private \n * Calculate the leap year and months from the RD.\n */\n\n\nHanDate.prototype._calcLeap = function () {\n  var jd = this.rd.getRataDie() + RataDie.gregorianEpoch;\n\n  var calc = HanCal._leapYearCalc(this.year);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n  var newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2;\n\n  var m = HanCal._newMoonBefore(jd + 1);\n\n  this.priorLeapMonth = HanRataDie._priorLeapMonth(newYears, HanCal._newMoonBefore(m));\n  this.leapMonth = this.leapYear && HanCal._noMajorST(m) && !this.priorLeapMonth;\n};\n/**\n * @private\n * Calculate date components for the given RD date.\n */\n\n\nHanDate.prototype._calcDateComponents = function () {\n  var remainder,\n      jd = this.rd.getRataDie() + RataDie.gregorianEpoch; // console.log(\"HanDate._calcDateComponents: calculating for jd \" + jd);\n\n  if (typeof this.offset === \"undefined\") {\n    // now offset the jd by the time zone, then recalculate in case we were \n    // near the year boundary\n    if (!this.tz) {\n      this.tz = new TimeZone({\n        id: this.timezone\n      });\n    }\n\n    this.offset = this.tz.getOffsetMillis(this) / 86400000;\n  }\n\n  if (this.offset !== 0) {\n    jd += this.offset;\n  } // use the Gregorian calendar objects as a convenient way to short-cut some\n  // of the date calculations\n\n\n  var gregyear = GregorianDate._calcYear(this.rd.getRataDie());\n\n  this.year = gregyear + 2697;\n\n  var calc = HanCal._leapYearCalc(this.year);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n  var newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2; // See if it's between Jan 1 and the Chinese new years of that Gregorian year. If\n  // so, then the Han year is actually the previous one\n\n  if (jd < newYears) {\n    this.year--;\n    calc = HanCal._leapYearCalc(this.year);\n    m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n    this.leapYear = Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n    newYears = this.leapYear && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2)) ? HanCal._newMoonOnOrAfter(m2 + 1) : m2;\n  } // month is elapsed month, not the month number + leap month boolean\n\n\n  var m = HanCal._newMoonBefore(jd + 1);\n\n  this.month = Math.round((m - calc.m1) / 29.530588853000001);\n  this.priorLeapMonth = HanRataDie._priorLeapMonth(newYears, HanCal._newMoonBefore(m));\n  this.leapMonth = this.leapYear && HanCal._noMajorST(m) && !this.priorLeapMonth;\n  this.cycle = Math.floor((this.year - 1) / 60);\n  this.cycleYear = MathUtils.amod(this.year, 60);\n  this.day = Astro._floorToJD(jd) - m + 1;\n  /*\n  console.log(\"HanDate._calcDateComponents: year is \" + this.year);\n  console.log(\"HanDate._calcDateComponents: isLeapYear is \" + this.leapYear);\n  console.log(\"HanDate._calcDateComponents: cycle is \" + this.cycle);\n  console.log(\"HanDate._calcDateComponents: cycleYear is \" + this.cycleYear);\n  console.log(\"HanDate._calcDateComponents: month is \" + this.month);\n  console.log(\"HanDate._calcDateComponents: isLeapMonth is \" + this.leapMonth);\n  console.log(\"HanDate._calcDateComponents: day is \" + this.day);\n  */\n  // floor to the start of the julian day\n\n  remainder = jd - Astro._floorToJD(jd); // console.log(\"HanDate._calcDateComponents: time remainder is \" + remainder);\n  // now convert to milliseconds for the rest of the calculation\n\n  remainder = Math.round(remainder * 86400000);\n  this.hour = Math.floor(remainder / 3600000);\n  remainder -= this.hour * 3600000;\n  this.minute = Math.floor(remainder / 60000);\n  remainder -= this.minute * 60000;\n  this.second = Math.floor(remainder / 1000);\n  remainder -= this.second * 1000;\n  this.millisecond = remainder;\n};\n/**\n * Return the year within the Chinese cycle of this date. Cycles are 60 \n * years long, and the value returned from this method is the number of the year \n * within this cycle. The year returned from getYear() is the total elapsed \n * years since the beginning of the Chinese epoch and does not include \n * the cycles. \n * \n * @return {number} the year within the current Chinese cycle\n */\n\n\nHanDate.prototype.getCycleYears = function () {\n  return this.cycleYear;\n};\n/**\n * Return the Chinese cycle number of this date. Cycles are 60 years long,\n * and the value returned from getCycleYear() is the number of the year \n * within this cycle. The year returned from getYear() is the total elapsed \n * years since the beginning of the Chinese epoch and does not include \n * the cycles. \n * \n * @return {number} the current Chinese cycle\n */\n\n\nHanDate.prototype.getCycles = function () {\n  return this.cycle;\n};\n/**\n * Return whether the year of this date is a leap year in the Chinese Han \n * calendar. \n * \n * @return {boolean} true if the year of this date is a leap year in the \n * Chinese Han calendar. \n */\n\n\nHanDate.prototype.isLeapYear = function () {\n  return this.leapYear;\n};\n/**\n * Return whether the month of this date is a leap month in the Chinese Han \n * calendar.\n * \n * @return {boolean} true if the month of this date is a leap month in the \n * Chinese Han calendar.\n */\n\n\nHanDate.prototype.isLeapMonth = function () {\n  return this.leapMonth;\n};\n/**\n * Return the day of the week of this date. The day of the week is encoded\n * as number from 0 to 6, with 0=Sunday, 1=Monday, etc., until 6=Saturday.\n * \n * @return {number} the day of the week\n */\n\n\nHanDate.prototype.getDayOfWeek = function () {\n  var rd = Math.floor(this.rd.getRataDie() + (this.offset || 0));\n  return MathUtils.mod(rd, 7);\n};\n/**\n * Return the ordinal day of the year. Days are counted from 1 and proceed linearly up to \n * 365, regardless of months or weeks, etc. That is, Farvardin 1st is day 1, and \n * December 31st is 365 in regular years, or 366 in leap years.\n * @return {number} the ordinal day of the year\n */\n\n\nHanDate.prototype.getDayOfYear = function () {\n  var newYears = this.cal.newYears(this.year);\n\n  var priorNewMoon = HanCal._newMoonOnOrAfter(newYears + (this.month - 1) * 29);\n\n  return priorNewMoon - newYears + this.day;\n};\n/**\n * Return the era for this date as a number. The value for the era for Han \n * calendars is -1 for \"before the han era\" (BP) and 1 for \"the han era\" (anno \n * persico or AP). \n * BP dates are any date before Farvardin 1, 1 AP. In the proleptic Han calendar, \n * there is a year 0, so any years that are negative or zero are BP.\n * @return {number} 1 if this date is in the common era, -1 if it is before the \n * common era \n */\n\n\nHanDate.prototype.getEra = function () {\n  return this.year < 1 ? -1 : 1;\n};\n/**\n * Return the name of the calendar that governs this date.\n * \n * @return {string} a string giving the name of the calendar\n */\n\n\nHanDate.prototype.getCalendar = function () {\n  return \"han\";\n}; // register with the factory method\n\n\nIDate._constructors[\"han\"] = HanDate;\nmodule.exports = HanDate;"]},"metadata":{},"sourceType":"module"}