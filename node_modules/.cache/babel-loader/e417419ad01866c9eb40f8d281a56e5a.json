{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Skinnable = exports[\"default\"] = void 0;\n\nvar _kind = _interopRequireDefault(require(\"@enact/core/kind\"));\n\nvar _hoc = _interopRequireDefault(require(\"@enact/core/hoc\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n/**\n * Default config for `Skinnable`.\n *\n * @memberof ui/Skinnable.Skinnable\n * @hocconfig\n * @public\n */\n\n\nvar defaultConfig = {\n  /**\n   * The prop in which to pass the skinVariants value to the wrapped component. The recommended\n   * value is \"skinVariants\".\n   *\n   * If left unset, the skinVariant will not be passed to the wrapped component.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  variantsProp: null,\n\n  /**\n   * The prop in which to pass the effective skin to the wrapped component.\n   *\n   * If left unset, the current skin will not be passed to the wrapped component.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  prop: null,\n\n  /**\n   * A hash mapping the available skin names to their CSS class name.\n   *\n   * The keys are accepted as the only valid values for the `skin` prop on the wrapped component.\n   *\n   * @type {Object}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  skins: null,\n\n  /**\n   * Assign a default skin from the `skins` list.\n   *\n   * This will be used if the instantiator of the wrapped component provides no value to the\n   * `skin` prop.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  defaultSkin: null,\n\n  /**\n   * Initial collection of applied variants\n   *\n   * This will be used if the instantiator of the wrapped component provides no value to the\n   * `skinVariants` prop.\n   *\n   * @type {String|String[]}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  defaultVariants: null,\n\n  /**\n   * A complete list of all supported variants.\n   *\n   * These will translate to CSS class names so should not conflict with any skin names.\n   * CamelCase is recommended for the values.\n   *\n   * @type {String[]}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  allowedVariants: null\n};\n/**\n * Allows a component to respond to skin changes via the Context API\n *\n * Example:\n * ```\n * <App skin=\"dark\">\n * \t<Section>\n * \t\t<Button>Gray Button</Button>\n * \t<Section>\n * \t<Popup skin=\"light\">\n * \t\t<Button>White Button</Button>\n * \t</Popup>\n * </App>\n * ```\n *\n * @class SkinContext\n * @memberof ui/Skinnable\n * @hoc\n * @public\n */\n\nvar SkinContext = _react[\"default\"].createContext(null);\n/**\n * A higher-order component that assigns skinning classes for the purposes of styling children components.\n *\n * Use the config options to specify the skins your theme has. Set this up in your theme's decorator\n * component to establish your supported skins.\n *\n * Example:\n * ```\n * App = Skinnable({\n * \tskins: {\n * \t\tdark: 'moonstone',\n * \t\tlight: 'moonstone-light'\n * \t},\n * \tdefaultTheme: 'dark'\n * \tdefaultVariants: ['highContrast'],\n * \tallowedVariants: ['highContrast', 'largeText', 'grayscale']\n * }, App);\n * ```\n *\n * @class Skinnable\n * @memberof ui/Skinnable\n * @hoc\n * @public\n */\n\n\nvar Skinnable = (0, _hoc[\"default\"])(defaultConfig, function (config, Wrapped) {\n  var prop = config.prop,\n      skins = config.skins,\n      defaultSkin = config.defaultSkin,\n      allowedVariants = config.allowedVariants,\n      variantsProp = config.variantsProp;\n  var defaultVariants = (0, _util.objectify)(config.defaultVariants);\n\n  function determineSkin(authorSkin, parentSkin) {\n    return authorSkin || defaultSkin || parentSkin;\n  }\n\n  function determineVariants(authorVariants, parentVariants) {\n    if (!allowedVariants || !(allowedVariants instanceof Array)) {\n      // There are no allowed variants, so just return an empty object, indicating that there are no viable determined variants.\n      return {};\n    }\n\n    authorVariants = (0, _util.objectify)(authorVariants);\n    parentVariants = (0, _util.objectify)(parentVariants); // Merge all of the variants objects, preferring values in objects from left to right.\n\n    var mergedObj = [defaultVariants, parentVariants, authorVariants].reduce(function (obj, a) {\n      Object.keys(a).forEach(function (key) {\n        obj[key] = (0, _util.preferDefined)(a[key], obj[key]);\n      });\n      return obj;\n    }, {}); // Clean up the merged object\n\n    for (var key in mergedObj) {\n      // Delete keys that are null or undefined and delete keys that aren't allowed\n      if (mergedObj[key] == null || !allowedVariants.includes(key)) {\n        delete mergedObj[key];\n      }\n    }\n\n    return mergedObj;\n  }\n\n  function getClassName(effectiveSkin, className, variants) {\n    var skin = skins && skins[effectiveSkin]; // only apply the skin class if it's set and different from the \"current\" skin as\n    // defined by the value in context\n\n    if (skin || variants) {\n      className = (0, _classnames[\"default\"])(skin, variants, className);\n    }\n\n    if (className) return className;\n  }\n\n  return (0, _kind[\"default\"])({\n    name: 'Skinnable',\n    propTypes:\n    /** @lends ui/Skinnable.Skinnable.prototype */\n    {\n      /**\n       * The name of the skin a component should use to render itself. Available skins are\n       * defined in the \"defaultConfig\" for this HOC.\n       *\n       * @type {String}\n       * @public\n       */\n      skin: _propTypes[\"default\"].string,\n\n      /**\n       * The variant(s) on a skin that a component should use when rendering. These will\n       * typically alter the appearance of a skin's existing definition in a way that does not\n       * override that skin's general styling.\n       *\n       * Multiple data types are supported by this prop, which afford different conveniences\n       * and abilities. String and Array are effectively the same, supporting just additions\n       * to the variants being applied to a component, and are much more convenient. Objects\n       * may also be used, and have the ability to disable variants being passed by their\n       * ancestors. Objects take the format of a basic hash, with variants as key names and\n       * true/false Booleans as values, depicting their state. If a variant is excluded from\n       * any version of data type used to set this prop, that variant will ignored, falling\n       * back to the defaultVariant or parent variant, in that order.\n       *\n       * skinVariants examples:\n       * ```\n       *  // String\n       *  skinVariants=\"highContrast\"\n       *\n       *  // Array\n       *  skinVariants={['highContrast']}\n       *\n       *  // Object\n       *  skinVariants={{\n       *  \thighContrast: true,\n       *  \tgrayscale: false\n       *  }}\n       * ```\n       *\n       * @type {String|String[]|Object}\n       * @public\n       */\n      skinVariants: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].string, _propTypes[\"default\"].array, _propTypes[\"default\"].object])\n    },\n    render: function render(_ref) {\n      var className = _ref.className,\n          skin = _ref.skin,\n          skinVariants = _ref.skinVariants,\n          rest = _objectWithoutProperties(_ref, [\"className\", \"skin\", \"skinVariants\"]);\n\n      return _react[\"default\"].createElement(SkinContext.Consumer, null, function (value) {\n        var _ref2 = value || {},\n            parentSkin = _ref2.parentSkin,\n            parentVariants = _ref2.parentVariants;\n\n        var effectiveSkin = determineSkin(skin, parentSkin);\n        var variants = determineVariants(skinVariants, parentVariants);\n        var allClassNames = getClassName(effectiveSkin, className, variants);\n\n        if (allClassNames) {\n          rest.className = allClassNames;\n        }\n\n        if (prop) {\n          rest[prop] = effectiveSkin;\n        }\n\n        if (variantsProp) {\n          rest[variantsProp] = variants;\n        }\n\n        return _react[\"default\"].createElement(SkinContext.Provider, {\n          value: {\n            parentSkin: effectiveSkin,\n            parentVariants: variants\n          }\n        }, _react[\"default\"].createElement(Wrapped, rest));\n      });\n    }\n  });\n});\nexports.Skinnable = Skinnable;\nvar _default = Skinnable;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/ui/Skinnable/Skinnable.js"],"names":["Object","defineProperty","exports","value","Skinnable","_kind","_interopRequireDefault","require","_hoc","_react","_propTypes","_classnames","_util","obj","__esModule","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","keys","defaultConfig","variantsProp","prop","skins","defaultSkin","defaultVariants","allowedVariants","SkinContext","createContext","config","Wrapped","objectify","determineSkin","authorSkin","parentSkin","determineVariants","authorVariants","parentVariants","Array","mergedObj","reduce","a","forEach","preferDefined","includes","getClassName","effectiveSkin","className","variants","skin","name","propTypes","string","skinVariants","oneOfType","array","object","render","_ref","rest","createElement","Consumer","_ref2","allClassNames","Provider","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Skinnable = exports[\"default\"] = void 0;\n\nvar _kind = _interopRequireDefault(require(\"@enact/core/kind\"));\n\nvar _hoc = _interopRequireDefault(require(\"@enact/core/hoc\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/**\n * Default config for `Skinnable`.\n *\n * @memberof ui/Skinnable.Skinnable\n * @hocconfig\n * @public\n */\nvar defaultConfig = {\n  /**\n   * The prop in which to pass the skinVariants value to the wrapped component. The recommended\n   * value is \"skinVariants\".\n   *\n   * If left unset, the skinVariant will not be passed to the wrapped component.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  variantsProp: null,\n\n  /**\n   * The prop in which to pass the effective skin to the wrapped component.\n   *\n   * If left unset, the current skin will not be passed to the wrapped component.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  prop: null,\n\n  /**\n   * A hash mapping the available skin names to their CSS class name.\n   *\n   * The keys are accepted as the only valid values for the `skin` prop on the wrapped component.\n   *\n   * @type {Object}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  skins: null,\n\n  /**\n   * Assign a default skin from the `skins` list.\n   *\n   * This will be used if the instantiator of the wrapped component provides no value to the\n   * `skin` prop.\n   *\n   * @type {String}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  defaultSkin: null,\n\n  /**\n   * Initial collection of applied variants\n   *\n   * This will be used if the instantiator of the wrapped component provides no value to the\n   * `skinVariants` prop.\n   *\n   * @type {String|String[]}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  defaultVariants: null,\n\n  /**\n   * A complete list of all supported variants.\n   *\n   * These will translate to CSS class names so should not conflict with any skin names.\n   * CamelCase is recommended for the values.\n   *\n   * @type {String[]}\n   * @memberof ui/Skinnable.Skinnable.defaultConfig\n   */\n  allowedVariants: null\n};\n/**\n * Allows a component to respond to skin changes via the Context API\n *\n * Example:\n * ```\n * <App skin=\"dark\">\n * \t<Section>\n * \t\t<Button>Gray Button</Button>\n * \t<Section>\n * \t<Popup skin=\"light\">\n * \t\t<Button>White Button</Button>\n * \t</Popup>\n * </App>\n * ```\n *\n * @class SkinContext\n * @memberof ui/Skinnable\n * @hoc\n * @public\n */\n\nvar SkinContext = _react[\"default\"].createContext(null);\n/**\n * A higher-order component that assigns skinning classes for the purposes of styling children components.\n *\n * Use the config options to specify the skins your theme has. Set this up in your theme's decorator\n * component to establish your supported skins.\n *\n * Example:\n * ```\n * App = Skinnable({\n * \tskins: {\n * \t\tdark: 'moonstone',\n * \t\tlight: 'moonstone-light'\n * \t},\n * \tdefaultTheme: 'dark'\n * \tdefaultVariants: ['highContrast'],\n * \tallowedVariants: ['highContrast', 'largeText', 'grayscale']\n * }, App);\n * ```\n *\n * @class Skinnable\n * @memberof ui/Skinnable\n * @hoc\n * @public\n */\n\n\nvar Skinnable = (0, _hoc[\"default\"])(defaultConfig, function (config, Wrapped) {\n  var prop = config.prop,\n      skins = config.skins,\n      defaultSkin = config.defaultSkin,\n      allowedVariants = config.allowedVariants,\n      variantsProp = config.variantsProp;\n  var defaultVariants = (0, _util.objectify)(config.defaultVariants);\n\n  function determineSkin(authorSkin, parentSkin) {\n    return authorSkin || defaultSkin || parentSkin;\n  }\n\n  function determineVariants(authorVariants, parentVariants) {\n    if (!allowedVariants || !(allowedVariants instanceof Array)) {\n      // There are no allowed variants, so just return an empty object, indicating that there are no viable determined variants.\n      return {};\n    }\n\n    authorVariants = (0, _util.objectify)(authorVariants);\n    parentVariants = (0, _util.objectify)(parentVariants); // Merge all of the variants objects, preferring values in objects from left to right.\n\n    var mergedObj = [defaultVariants, parentVariants, authorVariants].reduce(function (obj, a) {\n      Object.keys(a).forEach(function (key) {\n        obj[key] = (0, _util.preferDefined)(a[key], obj[key]);\n      });\n      return obj;\n    }, {}); // Clean up the merged object\n\n    for (var key in mergedObj) {\n      // Delete keys that are null or undefined and delete keys that aren't allowed\n      if (mergedObj[key] == null || !allowedVariants.includes(key)) {\n        delete mergedObj[key];\n      }\n    }\n\n    return mergedObj;\n  }\n\n  function getClassName(effectiveSkin, className, variants) {\n    var skin = skins && skins[effectiveSkin]; // only apply the skin class if it's set and different from the \"current\" skin as\n    // defined by the value in context\n\n    if (skin || variants) {\n      className = (0, _classnames[\"default\"])(skin, variants, className);\n    }\n\n    if (className) return className;\n  }\n\n  return (0, _kind[\"default\"])({\n    name: 'Skinnable',\n    propTypes:\n    /** @lends ui/Skinnable.Skinnable.prototype */\n    {\n      /**\n       * The name of the skin a component should use to render itself. Available skins are\n       * defined in the \"defaultConfig\" for this HOC.\n       *\n       * @type {String}\n       * @public\n       */\n      skin: _propTypes[\"default\"].string,\n\n      /**\n       * The variant(s) on a skin that a component should use when rendering. These will\n       * typically alter the appearance of a skin's existing definition in a way that does not\n       * override that skin's general styling.\n       *\n       * Multiple data types are supported by this prop, which afford different conveniences\n       * and abilities. String and Array are effectively the same, supporting just additions\n       * to the variants being applied to a component, and are much more convenient. Objects\n       * may also be used, and have the ability to disable variants being passed by their\n       * ancestors. Objects take the format of a basic hash, with variants as key names and\n       * true/false Booleans as values, depicting their state. If a variant is excluded from\n       * any version of data type used to set this prop, that variant will ignored, falling\n       * back to the defaultVariant or parent variant, in that order.\n       *\n       * skinVariants examples:\n       * ```\n       *  // String\n       *  skinVariants=\"highContrast\"\n       *\n       *  // Array\n       *  skinVariants={['highContrast']}\n       *\n       *  // Object\n       *  skinVariants={{\n       *  \thighContrast: true,\n       *  \tgrayscale: false\n       *  }}\n       * ```\n       *\n       * @type {String|String[]|Object}\n       * @public\n       */\n      skinVariants: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].string, _propTypes[\"default\"].array, _propTypes[\"default\"].object])\n    },\n    render: function render(_ref) {\n      var className = _ref.className,\n          skin = _ref.skin,\n          skinVariants = _ref.skinVariants,\n          rest = _objectWithoutProperties(_ref, [\"className\", \"skin\", \"skinVariants\"]);\n\n      return _react[\"default\"].createElement(SkinContext.Consumer, null, function (value) {\n        var _ref2 = value || {},\n            parentSkin = _ref2.parentSkin,\n            parentVariants = _ref2.parentVariants;\n\n        var effectiveSkin = determineSkin(skin, parentSkin);\n        var variants = determineVariants(skinVariants, parentVariants);\n        var allClassNames = getClassName(effectiveSkin, className, variants);\n\n        if (allClassNames) {\n          rest.className = allClassNames;\n        }\n\n        if (prop) {\n          rest[prop] = effectiveSkin;\n        }\n\n        if (variantsProp) {\n          rest[variantsProp] = variants;\n        }\n\n        return _react[\"default\"].createElement(SkinContext.Provider, {\n          value: {\n            parentSkin: effectiveSkin,\n            parentVariants: variants\n          }\n        }, _react[\"default\"].createElement(Wrapped, rest));\n      });\n    }\n  });\n});\nexports.Skinnable = Skinnable;\nvar _default = Skinnable;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}