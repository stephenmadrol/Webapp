{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n/*\n * INumber.js - Parse a number in any locale\n * \n * Copyright Â© 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends \nilib.js \nLocale.js \nisDigit.js \nisSpace.js\nLocaleInfo.js\nUtils.js\nJSUtils.js\nCurrency.js\n*/\n\n\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar CType = require(\"./CType.js\");\n\nvar isDigit = require(\"./isDigit.js\");\n\nvar isSpace = require(\"./isSpace.js\");\n\nvar Currency = require(\"./Currency.js\");\n/**\n * @class\n * Parse a string as a number, ignoring all locale-specific formatting.<p>\n * \n * This class is different from the standard Javascript parseInt() and parseFloat() \n * functions in that the number to be parsed can have formatting characters in it \n * that are not supported by those two\n * functions, and it handles numbers written in other locales properly. For example, \n * if you pass the string \"203,231.23\" to the parseFloat() function in Javascript, it \n * will return you the number 203. The INumber class will parse it correctly and \n * the value() function will return the number 203231.23. If you pass parseFloat() the \n * string \"203.231,23\" with the locale set to de-DE, it will return you 203 again. This\n * class will return the correct number 203231.23 again.<p>\n * \n * The options object may contain any of the following properties:\n * \n * <ul>\n * <li><i>locale</i> - specify the locale of the string to parse. This is used to\n * figure out what the decimal point character is. If not specified, the default locale\n * for the app or browser is used.\n * <li><i>type</i> - specify whether this string should be interpretted as a number,\n * currency, or percentage amount. When the number is interpretted as a currency\n * amount, the getCurrency() method will return something useful, otherwise it will\n * return undefined. If\n * the number is to be interpretted as percentage amount and there is a percentage sign\n * in the string, then the number will be returned\n * as a fraction from the valueOf() method. If there is no percentage sign, then the \n * number will be returned as a regular number. That is \"58.3%\" will be returned as the \n * number 0.583 but \"58.3\" will be returned as 58.3. Valid values for this property \n * are \"number\", \"currency\", and \"percentage\". Default if this is not specified is\n * \"number\".\n * <li><i>onLoad</i> - a callback function to call when the locale data is fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two. \n * \n * <li><i>sync</i> - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *  \n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * <p>\n * \n * This class is named INumber (\"ilib number\") so as not to conflict with the \n * built-in Javascript Number class.\n * \n * @constructor\n * @param {string|number|INumber|Number|undefined} str a string to parse as a number, or a number value\n * @param {Object=} options Options controlling how the instance should be created \n */\n\n\nvar INumber = function INumber(str, options) {\n  var i,\n      stripped = \"\",\n      sync = true;\n  this.locale = new Locale();\n  this.type = \"number\";\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.type) {\n      switch (options.type) {\n        case \"number\":\n        case \"currency\":\n        case \"percentage\":\n          this.type = options.type;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (typeof options.sync !== 'undefined') {\n      sync = options.sync == true;\n    }\n  } else {\n    options = {\n      sync: true\n    };\n  }\n\n  isDigit._init(sync, options.loadParams, ilib.bind(this, function () {\n    isSpace._init(sync, options.loadParams, ilib.bind(this, function () {\n      new LocaleInfo(this.locale, {\n        sync: sync,\n        loadParams: options.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.decimal = li.getDecimalSeparator();\n          var nativeDecimal = this.li.getNativeDecimalSeparator() || \"\";\n\n          switch (_typeof(str)) {\n            case 'string':\n              // stripping should work for all locales, because you just ignore all the\n              // formatting except the decimal char\n              var unary = true; // looking for the unary minus still?\n\n              var lastNumericChar = 0;\n              this.str = str || \"0\";\n              i = 0;\n\n              for (i = 0; i < this.str.length; i++) {\n                if (unary && this.str.charAt(i) === '-') {\n                  unary = false;\n                  stripped += this.str.charAt(i);\n                  lastNumericChar = i;\n                } else if (isDigit(this.str.charAt(i))) {\n                  stripped += this.str.charAt(i);\n                  unary = false;\n                  lastNumericChar = i;\n                } else if (this.str.charAt(i) === this.decimal || this.str.charAt(i) === nativeDecimal) {\n                  stripped += \".\"; // always convert to period\n\n                  unary = false;\n                  lastNumericChar = i;\n                } // else ignore\n\n              } // record what we actually parsed\n\n\n              this.parsed = this.str.substring(0, lastNumericChar + 1);\n              /** @type {number} */\n\n              this.value = parseFloat(this._mapToLatinDigits(stripped));\n              break;\n\n            case 'number':\n              this.str = \"\" + str;\n              this.value = str;\n              break;\n\n            case 'object':\n              // call parseFloat to coerse the type to number\n              this.value = parseFloat(str.valueOf());\n              this.str = \"\" + this.value;\n              break;\n\n            case 'undefined':\n              this.value = 0;\n              this.str = \"0\";\n              break;\n          }\n\n          switch (this.type) {\n            default:\n              // don't need to do anything special for other types\n              break;\n\n            case \"percentage\":\n              if (this.str.indexOf(li.getPercentageSymbol()) !== -1) {\n                this.value /= 100;\n              }\n\n              break;\n\n            case \"currency\":\n              stripped = \"\";\n              i = 0;\n\n              while (i < this.str.length && !isDigit(this.str.charAt(i)) && !isSpace(this.str.charAt(i))) {\n                stripped += this.str.charAt(i++);\n              }\n\n              if (stripped.length === 0) {\n                while (i < this.str.length && isDigit(this.str.charAt(i)) || isSpace(this.str.charAt(i)) || this.str.charAt(i) === '.' || this.str.charAt(i) === ',') {\n                  i++;\n                }\n\n                while (i < this.str.length && !isDigit(this.str.charAt(i)) && !isSpace(this.str.charAt(i))) {\n                  stripped += this.str.charAt(i++);\n                }\n              }\n\n              new Currency({\n                locale: this.locale,\n                sign: stripped,\n                sync: sync,\n                loadParams: options.loadParams,\n                onLoad: ilib.bind(this, function (cur) {\n                  this.currency = cur;\n\n                  if (options && typeof options.onLoad === 'function') {\n                    options.onLoad(this);\n                  }\n                })\n              });\n              return;\n          }\n\n          if (options && typeof options.onLoad === 'function') {\n            options.onLoad(this);\n          }\n        })\n      });\n    }));\n  }));\n};\n\nINumber.prototype = {\n  /**\n   * @private\n   */\n  _mapToLatinDigits: function _mapToLatinDigits(str) {\n    // only map if there are actual native digits\n    var digits = this.li.getNativeDigits();\n    if (!digits) return str;\n    var digitMap = {};\n\n    for (var i = 0; i < digits.length; i++) {\n      digitMap[digits[i]] = String(i);\n    }\n\n    var decimal = this.li.getNativeDecimalSeparator();\n    return str.split(\"\").map(function (ch) {\n      if (ch == decimal) return \".\";\n      return digitMap[ch] || ch;\n    }).join(\"\");\n  },\n\n  /**\n   * Return the locale for this formatter instance.\n   * @return {Locale} the locale instance for this formatter\n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Return the original string that this number instance was created with.\n   * @return {string} the original string\n   */\n  toString: function toString() {\n    return this.str;\n  },\n\n  /**\n   * If the type of this INumber instance is \"currency\", then the parser will attempt\n   * to figure out which currency this amount represents. The amount can be written\n   * with any of the currency signs or ISO 4217 codes that are currently\n   * recognized by ilib, and the currency signs may occur before or after the\n   * numeric portion of the string. If no currency can be recognized, then the \n   * default currency for the locale is returned. If multiple currencies can be\n   * recognized (for example if the currency sign is \"$\"), then this method \n   * will prefer the one for the current locale. If multiple currencies can be\n   * recognized, but none are used in the current locale, then the first currency\n   * encountered will be used. This may produce random results, though the larger\n   * currencies occur earlier in the list. For example, if the sign found in the\n   * string is \"$\" and that is not the sign of the currency of the current locale\n   * then the US dollar will be recognized, as it is the largest currency that uses\n   * the \"$\" as its sign.\n   * \n   * @return {Currency|undefined} the currency instance for this amount, or \n   * undefined if this INumber object is not of type currency\n   */\n  getCurrency: function getCurrency() {\n    return this.currency;\n  },\n\n  /**\n   * Return the value of this INumber object as a primitive number instance.\n   * @return {number} the value of this number instance\n   */\n  valueOf: function valueOf() {\n    return this.value;\n  }\n};\nmodule.exports = INumber;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/i18n/ilib/lib/INumber.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","ilib","require","Utils","JSUtils","Locale","LocaleInfo","CType","isDigit","isSpace","Currency","INumber","str","options","i","stripped","sync","locale","type","_init","loadParams","bind","onLoad","li","decimal","getDecimalSeparator","nativeDecimal","getNativeDecimalSeparator","unary","lastNumericChar","length","charAt","parsed","substring","value","parseFloat","_mapToLatinDigits","valueOf","indexOf","getPercentageSymbol","sign","cur","currency","digits","getNativeDigits","digitMap","String","split","map","ch","join","getLocale","toString","getCurrency","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * INumber.js - Parse a number in any locale\n * \n * Copyright Â© 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends \nilib.js \nLocale.js \nisDigit.js \nisSpace.js\nLocaleInfo.js\nUtils.js\nJSUtils.js\nCurrency.js\n*/\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar CType = require(\"./CType.js\");\n\nvar isDigit = require(\"./isDigit.js\");\n\nvar isSpace = require(\"./isSpace.js\");\n\nvar Currency = require(\"./Currency.js\");\n/**\n * @class\n * Parse a string as a number, ignoring all locale-specific formatting.<p>\n * \n * This class is different from the standard Javascript parseInt() and parseFloat() \n * functions in that the number to be parsed can have formatting characters in it \n * that are not supported by those two\n * functions, and it handles numbers written in other locales properly. For example, \n * if you pass the string \"203,231.23\" to the parseFloat() function in Javascript, it \n * will return you the number 203. The INumber class will parse it correctly and \n * the value() function will return the number 203231.23. If you pass parseFloat() the \n * string \"203.231,23\" with the locale set to de-DE, it will return you 203 again. This\n * class will return the correct number 203231.23 again.<p>\n * \n * The options object may contain any of the following properties:\n * \n * <ul>\n * <li><i>locale</i> - specify the locale of the string to parse. This is used to\n * figure out what the decimal point character is. If not specified, the default locale\n * for the app or browser is used.\n * <li><i>type</i> - specify whether this string should be interpretted as a number,\n * currency, or percentage amount. When the number is interpretted as a currency\n * amount, the getCurrency() method will return something useful, otherwise it will\n * return undefined. If\n * the number is to be interpretted as percentage amount and there is a percentage sign\n * in the string, then the number will be returned\n * as a fraction from the valueOf() method. If there is no percentage sign, then the \n * number will be returned as a regular number. That is \"58.3%\" will be returned as the \n * number 0.583 but \"58.3\" will be returned as 58.3. Valid values for this property \n * are \"number\", \"currency\", and \"percentage\". Default if this is not specified is\n * \"number\".\n * <li><i>onLoad</i> - a callback function to call when the locale data is fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two. \n * \n * <li><i>sync</i> - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *  \n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * <p>\n * \n * This class is named INumber (\"ilib number\") so as not to conflict with the \n * built-in Javascript Number class.\n * \n * @constructor\n * @param {string|number|INumber|Number|undefined} str a string to parse as a number, or a number value\n * @param {Object=} options Options controlling how the instance should be created \n */\n\n\nvar INumber = function INumber(str, options) {\n  var i,\n      stripped = \"\",\n      sync = true;\n  this.locale = new Locale();\n  this.type = \"number\";\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.type) {\n      switch (options.type) {\n        case \"number\":\n        case \"currency\":\n        case \"percentage\":\n          this.type = options.type;\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    if (typeof options.sync !== 'undefined') {\n      sync = options.sync == true;\n    }\n  } else {\n    options = {\n      sync: true\n    };\n  }\n\n  isDigit._init(sync, options.loadParams, ilib.bind(this, function () {\n    isSpace._init(sync, options.loadParams, ilib.bind(this, function () {\n      new LocaleInfo(this.locale, {\n        sync: sync,\n        loadParams: options.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.decimal = li.getDecimalSeparator();\n          var nativeDecimal = this.li.getNativeDecimalSeparator() || \"\";\n\n          switch (_typeof(str)) {\n            case 'string':\n              // stripping should work for all locales, because you just ignore all the\n              // formatting except the decimal char\n              var unary = true; // looking for the unary minus still?\n\n              var lastNumericChar = 0;\n              this.str = str || \"0\";\n              i = 0;\n\n              for (i = 0; i < this.str.length; i++) {\n                if (unary && this.str.charAt(i) === '-') {\n                  unary = false;\n                  stripped += this.str.charAt(i);\n                  lastNumericChar = i;\n                } else if (isDigit(this.str.charAt(i))) {\n                  stripped += this.str.charAt(i);\n                  unary = false;\n                  lastNumericChar = i;\n                } else if (this.str.charAt(i) === this.decimal || this.str.charAt(i) === nativeDecimal) {\n                  stripped += \".\"; // always convert to period\n\n                  unary = false;\n                  lastNumericChar = i;\n                } // else ignore\n\n              } // record what we actually parsed\n\n\n              this.parsed = this.str.substring(0, lastNumericChar + 1);\n              /** @type {number} */\n\n              this.value = parseFloat(this._mapToLatinDigits(stripped));\n              break;\n\n            case 'number':\n              this.str = \"\" + str;\n              this.value = str;\n              break;\n\n            case 'object':\n              // call parseFloat to coerse the type to number\n              this.value = parseFloat(str.valueOf());\n              this.str = \"\" + this.value;\n              break;\n\n            case 'undefined':\n              this.value = 0;\n              this.str = \"0\";\n              break;\n          }\n\n          switch (this.type) {\n            default:\n              // don't need to do anything special for other types\n              break;\n\n            case \"percentage\":\n              if (this.str.indexOf(li.getPercentageSymbol()) !== -1) {\n                this.value /= 100;\n              }\n\n              break;\n\n            case \"currency\":\n              stripped = \"\";\n              i = 0;\n\n              while (i < this.str.length && !isDigit(this.str.charAt(i)) && !isSpace(this.str.charAt(i))) {\n                stripped += this.str.charAt(i++);\n              }\n\n              if (stripped.length === 0) {\n                while (i < this.str.length && isDigit(this.str.charAt(i)) || isSpace(this.str.charAt(i)) || this.str.charAt(i) === '.' || this.str.charAt(i) === ',') {\n                  i++;\n                }\n\n                while (i < this.str.length && !isDigit(this.str.charAt(i)) && !isSpace(this.str.charAt(i))) {\n                  stripped += this.str.charAt(i++);\n                }\n              }\n\n              new Currency({\n                locale: this.locale,\n                sign: stripped,\n                sync: sync,\n                loadParams: options.loadParams,\n                onLoad: ilib.bind(this, function (cur) {\n                  this.currency = cur;\n\n                  if (options && typeof options.onLoad === 'function') {\n                    options.onLoad(this);\n                  }\n                })\n              });\n              return;\n          }\n\n          if (options && typeof options.onLoad === 'function') {\n            options.onLoad(this);\n          }\n        })\n      });\n    }));\n  }));\n};\n\nINumber.prototype = {\n  /**\n   * @private\n   */\n  _mapToLatinDigits: function _mapToLatinDigits(str) {\n    // only map if there are actual native digits\n    var digits = this.li.getNativeDigits();\n    if (!digits) return str;\n    var digitMap = {};\n\n    for (var i = 0; i < digits.length; i++) {\n      digitMap[digits[i]] = String(i);\n    }\n\n    var decimal = this.li.getNativeDecimalSeparator();\n    return str.split(\"\").map(function (ch) {\n      if (ch == decimal) return \".\";\n      return digitMap[ch] || ch;\n    }).join(\"\");\n  },\n\n  /**\n   * Return the locale for this formatter instance.\n   * @return {Locale} the locale instance for this formatter\n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Return the original string that this number instance was created with.\n   * @return {string} the original string\n   */\n  toString: function toString() {\n    return this.str;\n  },\n\n  /**\n   * If the type of this INumber instance is \"currency\", then the parser will attempt\n   * to figure out which currency this amount represents. The amount can be written\n   * with any of the currency signs or ISO 4217 codes that are currently\n   * recognized by ilib, and the currency signs may occur before or after the\n   * numeric portion of the string. If no currency can be recognized, then the \n   * default currency for the locale is returned. If multiple currencies can be\n   * recognized (for example if the currency sign is \"$\"), then this method \n   * will prefer the one for the current locale. If multiple currencies can be\n   * recognized, but none are used in the current locale, then the first currency\n   * encountered will be used. This may produce random results, though the larger\n   * currencies occur earlier in the list. For example, if the sign found in the\n   * string is \"$\" and that is not the sign of the currency of the current locale\n   * then the US dollar will be recognized, as it is the largest currency that uses\n   * the \"$\" as its sign.\n   * \n   * @return {Currency|undefined} the currency instance for this amount, or \n   * undefined if this INumber object is not of type currency\n   */\n  getCurrency: function getCurrency() {\n    return this.currency;\n  },\n\n  /**\n   * Return the value of this INumber object as a primitive number instance.\n   * @return {number} the value of this number instance\n   */\n  valueOf: function valueOf() {\n    return this.value;\n  }\n};\nmodule.exports = INumber;"]},"metadata":{},"sourceType":"module"}