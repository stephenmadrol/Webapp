{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getArrowPosition = exports.calcOverflow = exports.adjustAnchor = exports.adjustDirection = void 0;\n\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n} // TooltipDecorator util.js\n//\n\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\n\n\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    } // Flip sideways if it overflows to the sides\n\n\n    if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    }\n\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n\n  return arrowAnchor;\n};\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\n\n\nexports.adjustAnchor = adjustAnchor;\n\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  } // Flip tooltip if it overflows towards the tooltip direction\n\n\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n\n  return tooltipDirection;\n};\n/**\n * Calculates the overflow of `Tooltip` — if `Tooltip` is at the edge of the viewport.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\n\n\nexports.adjustDirection = adjustDirection;\n\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, tooltipHeight) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var rightDelta = tooltipNode.width > clientNode.left + clientNode.width / 2;\n  var leftDelta = tooltipNode.width > window.innerWidth - clientNode.right - clientNode.width / 2;\n  var isTooltipWide = tooltipNode.width > window.innerWidth || leftDelta && rightDelta;\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    return {\n      isOverTop: clientNode.top - tooltipNode.height - tooltipHeight < 0,\n      isOverBottom: clientNode.bottom + tooltipNode.height + tooltipHeight > window.innerHeight,\n      isOverLeft: clientNode.left - tooltipNode.width + clientNode.width / 2 < 0,\n      isOverRight: clientNode.right + tooltipNode.width - clientNode.width / 2 > window.innerWidth,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    return {\n      isOverTop: clientNode.top - tooltipNode.height + clientNode.height / 2 < 0,\n      isOverBottom: clientNode.bottom + tooltipNode.height - clientNode.height / 2 > window.innerHeight,\n      isOverLeft: clientNode.left - tooltipNode.width < 0,\n      isOverRight: clientNode.right + tooltipNode.width > window.innerWidth,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\n\n\nexports.calcOverflow = calcOverflow;\n\nvar getPosition = function getPosition(tooltipNode, clientNode, arrowAnchor, tooltipDirection, tooltipHeight, overflow, rtl) {\n  var position = {};\n\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top - tooltipNode.height - tooltipHeight;\n      break;\n\n    case 'below':\n      position.top = clientNode.bottom + tooltipHeight;\n      break;\n\n    case 'right':\n      position.left = clientNode.right + tooltipHeight;\n      break;\n\n    case 'left':\n      position.left = clientNode.left - tooltipNode.width - tooltipHeight;\n      break;\n\n    default:\n      position = {};\n  }\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n\n    if (arrowAnchor === 'left') {\n      position.left -= tooltipNode.width;\n    } else if (arrowAnchor === 'center') {\n      position.left -= tooltipNode.width / 2;\n    }\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n\n    if (arrowAnchor === 'top') {\n      position.top -= tooltipNode.height;\n    } else if (arrowAnchor === 'middle') {\n      position.top -= tooltipNode.height / 2;\n    }\n  } // When tooltip is too wide, shift the tooltip so that the first part of the tooltip is always visible. Does not affect tooltips with `tooltipDirection` of `left` and `right`\n\n\n  if (overflow.isOverWide && !(tooltipDirection === 'left' || tooltipDirection === 'right') && arrowAnchor !== 'right') {\n    position.left = rtl ? window.innerWidth - tooltipNode.width : 0;\n  }\n\n  return position;\n};\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object}  clientNode        The `getBoundingClientRect` values for client node\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Number}                    Tooltip anchor's left position in percentage between 0 and 1 relative to the tooltip\n * @private\n */\n\n\nexports.getPosition = getPosition;\n\nvar getArrowPosition = function getArrowPosition(tooltipNode, clientNode, tooltipDirection, overflow, rtl) {\n  if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width; // finding out where the middle of the clientNode is and figuring out where that is in relation to the tooltip node in percentage between 0 and 1\n\n    var arrowPosition = rtl ? 1 - (window.innerWidth - clientNode.right + clientNode.width / 2) / tooltipWidth : (clientNode.left + clientNode.width / 2) / tooltipWidth;\n\n    var borderRadius = _resolution[\"default\"].scale(33); // based on @moon-tooltip-border-radius\n    // max arrow position before the arrow is detached because of border radius\n\n\n    var maxArrowPosition = 1 - borderRadius / tooltipWidth; // if arrow position is above the max arrow position, use max arrow position instead\n\n    var adjustedArrowPosition = arrowPosition > maxArrowPosition ? maxArrowPosition : arrowPosition;\n    return adjustedArrowPosition;\n  }\n\n  return null;\n};\n\nexports.getArrowPosition = getArrowPosition;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteApp\\node_modules\\@enact\\moonstone\\TooltipDecorator\\util.js"],"names":["Object","defineProperty","exports","value","getPosition","getArrowPosition","calcOverflow","adjustAnchor","adjustDirection","_resolution","_interopRequireDefault","require","obj","__esModule","arrowAnchor","tooltipDirection","overflow","rtl","isOverRight","isOverLeft","isOverWide","isOverTop","isOverBottom","tooltipNode","clientNode","tooltipHeight","rightDelta","width","left","leftDelta","window","innerWidth","right","isTooltipWide","top","height","bottom","innerHeight","position","tooltipWidth","arrowPosition","borderRadius","scale","maxArrowPosition","adjustedArrowPosition"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getArrowPosition = exports.calcOverflow = exports.adjustAnchor = exports.adjustDirection = void 0;\n\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// TooltipDecorator util.js\n//\n\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    } // Flip sideways if it overflows to the sides\n\n\n    if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    }\n\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n\n  return arrowAnchor;\n};\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\n\n\nexports.adjustAnchor = adjustAnchor;\n\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  } // Flip tooltip if it overflows towards the tooltip direction\n\n\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n\n  return tooltipDirection;\n};\n/**\n * Calculates the overflow of `Tooltip` — if `Tooltip` is at the edge of the viewport.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\n\n\nexports.adjustDirection = adjustDirection;\n\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, tooltipHeight) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var rightDelta = tooltipNode.width > clientNode.left + clientNode.width / 2;\n  var leftDelta = tooltipNode.width > window.innerWidth - clientNode.right - clientNode.width / 2;\n  var isTooltipWide = tooltipNode.width > window.innerWidth || leftDelta && rightDelta;\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    return {\n      isOverTop: clientNode.top - tooltipNode.height - tooltipHeight < 0,\n      isOverBottom: clientNode.bottom + tooltipNode.height + tooltipHeight > window.innerHeight,\n      isOverLeft: clientNode.left - tooltipNode.width + clientNode.width / 2 < 0,\n      isOverRight: clientNode.right + tooltipNode.width - clientNode.width / 2 > window.innerWidth,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    return {\n      isOverTop: clientNode.top - tooltipNode.height + clientNode.height / 2 < 0,\n      isOverBottom: clientNode.bottom + tooltipNode.height - clientNode.height / 2 > window.innerHeight,\n      isOverLeft: clientNode.left - tooltipNode.width < 0,\n      isOverRight: clientNode.right + tooltipNode.width > window.innerWidth,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\n\n\nexports.calcOverflow = calcOverflow;\n\nvar getPosition = function getPosition(tooltipNode, clientNode, arrowAnchor, tooltipDirection, tooltipHeight, overflow, rtl) {\n  var position = {};\n\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top - tooltipNode.height - tooltipHeight;\n      break;\n\n    case 'below':\n      position.top = clientNode.bottom + tooltipHeight;\n      break;\n\n    case 'right':\n      position.left = clientNode.right + tooltipHeight;\n      break;\n\n    case 'left':\n      position.left = clientNode.left - tooltipNode.width - tooltipHeight;\n      break;\n\n    default:\n      position = {};\n  }\n\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n\n    if (arrowAnchor === 'left') {\n      position.left -= tooltipNode.width;\n    } else if (arrowAnchor === 'center') {\n      position.left -= tooltipNode.width / 2;\n    }\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n\n    if (arrowAnchor === 'top') {\n      position.top -= tooltipNode.height;\n    } else if (arrowAnchor === 'middle') {\n      position.top -= tooltipNode.height / 2;\n    }\n  } // When tooltip is too wide, shift the tooltip so that the first part of the tooltip is always visible. Does not affect tooltips with `tooltipDirection` of `left` and `right`\n\n\n  if (overflow.isOverWide && !(tooltipDirection === 'left' || tooltipDirection === 'right') && arrowAnchor !== 'right') {\n    position.left = rtl ? window.innerWidth - tooltipNode.width : 0;\n  }\n\n  return position;\n};\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof moonstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object}  clientNode        The `getBoundingClientRect` values for client node\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Number}                    Tooltip anchor's left position in percentage between 0 and 1 relative to the tooltip\n * @private\n */\n\n\nexports.getPosition = getPosition;\n\nvar getArrowPosition = function getArrowPosition(tooltipNode, clientNode, tooltipDirection, overflow, rtl) {\n  if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width; // finding out where the middle of the clientNode is and figuring out where that is in relation to the tooltip node in percentage between 0 and 1\n\n    var arrowPosition = rtl ? 1 - (window.innerWidth - clientNode.right + clientNode.width / 2) / tooltipWidth : (clientNode.left + clientNode.width / 2) / tooltipWidth;\n\n    var borderRadius = _resolution[\"default\"].scale(33); // based on @moon-tooltip-border-radius\n    // max arrow position before the arrow is detached because of border radius\n\n\n    var maxArrowPosition = 1 - borderRadius / tooltipWidth; // if arrow position is above the max arrow position, use max arrow position instead\n\n    var adjustedArrowPosition = arrowPosition > maxArrowPosition ? maxArrowPosition : arrowPosition;\n    return adjustedArrowPosition;\n  }\n\n  return null;\n};\n\nexports.getArrowPosition = getArrowPosition;"]},"metadata":{},"sourceType":"module"}