{"ast":null,"code":"\"use strict\";\n/*\n * NumFmt.js - Number formatter definition\n *\n * Copyright © 2012-2015, 2018 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends\nilib.js\nLocale.js\nLocaleInfo.js\nUtils.js\nMathUtils.js\nCurrency.js\nIString.js\nJSUtils.js\nINumber.js\n*/\n// !data localeinfo currency\n\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar Currency = require(\"./Currency.js\");\n\nvar IString = require(\"./IString.js\");\n\nvar INumber = require(\"./INumber.js\");\n/**\n * @class\n * Create a new number formatter instance. Locales differ in the way that digits\n * in a formatted number are grouped, in the way the decimal character is represented,\n * etc. Use this formatter to get it right for any locale.<p>\n *\n * This formatter can format plain numbers, currency amounts, and percentage amounts.<p>\n *\n * As with all formatters, the recommended\n * practice is to create one formatter and use it multiple times to format various\n * numbers.<p>\n *\n * The options can contain any of the following properties:\n *\n * <ul>\n * <li><i>locale</i> - use the conventions of the specified locale when figuring out how to\n * format a number.\n * <li><i>type</i> - the type of this formatter. Valid values are \"number\", \"currency\", or\n * \"percentage\". If this property is not specified, the default is \"number\".\n * <li><i>currency</i> - the ISO 4217 3-letter currency code to use when the formatter type\n * is \"currency\". This property is required for currency formatting. If the type property\n * is \"currency\" and the currency property is not specified, the constructor will throw a\n * an exception.\n * <li><i>maxFractionDigits</i> - the maximum number of digits that should appear in the\n * formatted output after the decimal. A value of -1 means unlimited, and 0 means only print\n * the integral part of the number.\n * <li><i>minFractionDigits</i> - the minimum number of fractional digits that should\n * appear in the formatted output. If the number does not have enough fractional digits\n * to reach this minimum, the number will be zero-padded at the end to get to the limit.\n * If the type of the formatter is \"currency\" and this\n * property is not specified, then the minimum fraction digits is set to the normal number\n * of digits used with that currency, which is almost always 0, 2, or 3 digits.\n * <li><i>significantDigits</i> - specify that max number of significant digits in the\n * formatted output. This applies before and after the decimal point. The amount is\n * rounded according to the rounding mode specified, or the rounding mode as given in\n * the locale information. If the significant digits and the max or min fraction digits\n * are both specified, this formatter will attempt to honour them both by choosing the\n * one that is smaller if there is a conflict. For example, if the max fraction digits\n * is 6 and the significant digits is 5 and the number to be formatted has a long\n * fraction, it will only format 5 digits. The default is \"unlimited digits\", which means\n * to format as many digits as the javascript engine can represent internally (usually\n * around 13-15 or so on a 64-bit machine).\n * <li><i>useNative</i> - the flag used to determaine whether to use the native script settings\n * for formatting the numbers .\n * <li><i>roundingMode</i> - When the maxFractionDigits or maxIntegerDigits is specified,\n * this property governs how the least significant digits are rounded to conform to that\n * maximum. The value of this property is a string with one of the following values:\n * <ul>\n *   <li><i>up</i> - round away from zero\n *   <li><i>down</i> - round towards zero. This has the effect of truncating the number\n *   <li><i>ceiling</i> - round towards positive infinity\n *   <li><i>floor</i> - round towards negative infinity\n *   <li><i>halfup</i> - round towards nearest neighbour. If equidistant, round up.\n *   <li><i>halfdown</i> - round towards nearest neighbour. If equidistant, round down.\n *   <li><i>halfeven</i> - round towards nearest neighbour. If equidistant, round towards the even neighbour\n *   <li><i>halfodd</i> - round towards nearest neighbour. If equidistant, round towards the odd neighbour\n * </ul>\n * When the type of the formatter is \"currency\" and the <i>roundingMode</i> property is not\n * set, then the standard legal rounding rules for the locale are followed. If the type\n * is \"number\" or \"percentage\" and the <i>roundingMode</i> property is not set, then the\n * default mode is \"halfdown\".</i>.\n *\n * <li><i>style</i> - When the type of this formatter is \"currency\", the currency amount\n * can be formatted in the following styles: \"common\" and \"iso\". The common style is the\n * one commonly used in every day writing where the currency unit is represented using a\n * symbol. eg. \"$57.35\" for fifty-seven dollars and thirty five cents. The iso style is\n * the international style where the currency unit is represented using the ISO 4217 code.\n * eg. \"USD 57.35\" for the same amount. The default is \"common\" style if the style is\n * not specified.<p>\n *\n * When the type of this formatter is \"number\", the style can be one of the following:\n * <ul>\n *   <li><i>standard - format a fully specified floating point number properly for the locale\n *   <li><i>scientific</i> - use scientific notation for all numbers. That is, 1 integral\n *   digit, followed by a number of fractional digits, followed by an \"e\" which denotes\n *   exponentiation, followed digits which give the power of 10 in the exponent.\n *   <li><i>native</i> - format a floating point number using the native digits and\n *   formatting symbols for the script of the locale.\n *   <li><i>nogrouping</i> - format a floating point number without grouping digits for\n *   the integral portion of the number\n * </ul>\n * Note that if you specify a maximum number\n * of integral digits, the formatter with a standard style will give you standard\n * formatting for smaller numbers and scientific notation for larger numbers. The default\n * is standard style if this is not specified.\n *\n * <li><i>onLoad</i> - a callback function to call when the format data is fully\n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the\n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two.\n *\n * <li>sync - tell whether to load any missing locale data synchronously or\n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the\n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object\n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * <p>\n *\n *\n * @constructor\n * @param {Object.<string,*>} options A set of options that govern how the formatter will behave\n */\n\n\nvar NumFmt = function NumFmt(options) {\n  var sync = true;\n  this.locale = new Locale();\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this.type = \"number\";\n  var loadParams = undefined;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.type) {\n      if (options.type === 'number' || options.type === 'currency' || options.type === 'percentage') {\n        this.type = options.type;\n      }\n    }\n\n    if (options.currency) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.currency = options.currency;\n    }\n\n    if (typeof options.maxFractionDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.maxFractionDigits = Number(options.maxFractionDigits);\n    }\n\n    if (typeof options.minFractionDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.minFractionDigits = Number(options.minFractionDigits); // enforce the limits to avoid JS exceptions\n\n      if (this.minFractionDigits < 0) {\n        this.minFractionDigits = 0;\n      }\n\n      if (this.minFractionDigits > 20) {\n        this.minFractionDigits = 20;\n      }\n    }\n\n    if (typeof options.significantDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.significantDigits = Number(options.significantDigits); // enforce the limits to avoid JS exceptions\n\n      if (this.significantDigits < 1) {\n        this.significantDigits = 1;\n      }\n\n      if (this.significantDigits > 20) {\n        this.significantDigits = 20;\n      }\n    }\n\n    if (options.style) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.style = options.style;\n    }\n\n    if (typeof options.useNative === 'boolean') {\n      /**\n       * @private\n       * @type {boolean}\n       * */\n      this.useNative = options.useNative;\n    }\n    /**\n     * @private\n     * @type {string}\n     */\n\n\n    this.roundingMode = options.roundingMode;\n\n    if (typeof options.sync === 'boolean') {\n      sync = options.sync;\n    }\n\n    loadParams = options.loadParams;\n  }\n  /**\n   * @private\n   * @type {LocaleInfo|undefined}\n   */\n\n\n  this.localeInfo = undefined;\n  new LocaleInfo(this.locale, {\n    sync: sync,\n    loadParams: loadParams,\n    onLoad: ilib.bind(this, function (li) {\n      /**\n       * @private\n       * @type {LocaleInfo|undefined}\n       */\n      this.localeInfo = li;\n\n      if (this.type === \"number\") {\n        this.templateNegative = new IString(this.localeInfo.getNegativeNumberFormat() || \"-{n}\");\n      } else if (this.type === \"currency\") {\n        var templates;\n\n        if (!this.currency || typeof this.currency != 'string') {\n          throw \"A currency property is required in the options to the number formatter constructor when the type property is set to currency.\";\n        }\n\n        new Currency({\n          locale: this.locale,\n          code: this.currency,\n          sync: sync,\n          loadParams: loadParams,\n          onLoad: ilib.bind(this, function (cur) {\n            this.currencyInfo = cur;\n\n            if (this.style !== \"common\" && this.style !== \"iso\") {\n              this.style = \"common\";\n            }\n\n            if (typeof this.maxFractionDigits !== 'number' && typeof this.minFractionDigits !== 'number') {\n              this.minFractionDigits = this.maxFractionDigits = this.currencyInfo.getFractionDigits();\n            }\n\n            templates = this.localeInfo.getCurrencyFormats();\n            this.template = new IString(templates[this.style] || templates.common);\n            this.templateNegative = new IString(templates[this.style + \"Negative\"] || templates[\"commonNegative\"]);\n            this.sign = this.style === \"iso\" ? this.currencyInfo.getCode() : this.currencyInfo.getSign();\n\n            if (!this.roundingMode) {\n              this.roundingMode = this.currencyInfo && this.currencyInfo.roundingMode;\n            }\n\n            this._init();\n\n            if (options && typeof options.onLoad === 'function') {\n              options.onLoad(this);\n            }\n          })\n        });\n        return;\n      } else if (this.type === \"percentage\") {\n        this.template = new IString(this.localeInfo.getPercentageFormat() || \"{n}%\");\n        this.templateNegative = new IString(this.localeInfo.getNegativePercentageFormat() || this.localeInfo.getNegativeNumberFormat() + \"%\");\n      }\n\n      this._init();\n\n      if (options && typeof options.onLoad === 'function') {\n        options.onLoad(this);\n      }\n    })\n  });\n};\n/**\n * Return an array of available locales that this formatter can format\n * @static\n * @return {Array.<Locale>|undefined} an array of available locales\n */\n\n\nNumFmt.getAvailableLocales = function () {\n  return undefined;\n};\n/**\n * @private\n * @const\n * @type string\n */\n\n\nNumFmt.zeros = \"0000000000000000000000000000000000000000000000000000000000000000000000\";\nNumFmt.prototype = {\n  /**\n   * Return true if this formatter uses native digits to format the number. If the useNative\n   * option is given to the constructor, then this flag will be honoured. If the useNative\n   * option is not given to the constructor, this this formatter will use native digits if\n   * the locale typically uses native digits.\n   *\n   *  @return {boolean} true if this formatter will format with native digits, false otherwise\n   */\n  getUseNative: function getUseNative() {\n    if (typeof this.useNative === \"boolean\") {\n      return this.useNative;\n    }\n\n    return this.localeInfo.getDigitsStyle() === \"native\";\n  },\n\n  /**\n   * @private\n   */\n  _init: function _init() {\n    if (this.maxFractionDigits < this.minFractionDigits) {\n      this.minFractionDigits = this.maxFractionDigits;\n    }\n\n    if (!this.roundingMode) {\n      this.roundingMode = this.localeInfo.getRoundingMode();\n    }\n\n    if (!this.roundingMode) {\n      this.roundingMode = \"halfdown\";\n    } // set up the function, so we only have to figure it out once\n    // and not every time we do format()\n\n\n    this.round = MathUtils[this.roundingMode];\n\n    if (!this.round) {\n      this.roundingMode = \"halfdown\";\n      this.round = MathUtils[this.roundingMode];\n    }\n\n    if (this.style === \"nogrouping\") {\n      this.prigroupSize = this.secgroupSize = 0;\n    } else {\n      this.prigroupSize = this.localeInfo.getPrimaryGroupingDigits();\n      this.secgroupSize = this.localeInfo.getSecondaryGroupingDigits();\n      this.groupingSeparator = this.getUseNative() ? this.localeInfo.getNativeGroupingSeparator() : this.localeInfo.getGroupingSeparator();\n    }\n\n    this.decimalSeparator = this.getUseNative() ? this.localeInfo.getNativeDecimalSeparator() : this.localeInfo.getDecimalSeparator();\n\n    if (this.getUseNative()) {\n      var nd = this.localeInfo.getNativeDigits() || this.localeInfo.getDigits();\n\n      if (nd) {\n        this.digits = nd.split(\"\");\n      }\n    }\n\n    this.exponentSymbol = this.localeInfo.getExponential() || \"e\";\n  },\n\n  /**\n   * Apply the constraints used in the current formatter to the given number. This will\n   * will apply the maxFractionDigits, significantDigits, and rounding mode\n   * constraints and return the result. The result is further\n   * manipulated in the format method to produce the final formatted number string.\n   * This method is intended for use by code that needs to use the same number that\n   * this formatter instance uses for formatting before that number is turned into a\n   * formatted string.\n   *\n   * @param {number} num the number to constrain\n   * @returns {number} the number with the constraints applied to it\n   */\n  constrain: function constrain(num) {\n    var parts = (\"\" + num).split(\".\"),\n        result = num; // only apply the either significantDigits or the maxFractionDigits -- whichever results in a shorter fractional part\n\n    if (typeof this.significantDigits !== 'undefined' && this.significantDigits > 0 && (typeof this.maxFractionDigits === 'undefined' || this.maxFractionDigits < 0 || parts[0].length + this.maxFractionDigits > this.significantDigits)) {\n      result = MathUtils.significant(result, this.significantDigits, this.round);\n    }\n\n    if (typeof this.maxFractionDigits !== 'undefined' && this.maxFractionDigits > -1) {\n      result = MathUtils.shiftDecimal(this.round(MathUtils.shiftDecimal(result, this.maxFractionDigits)), -this.maxFractionDigits);\n    }\n\n    return result;\n  },\n\n  /**\n   * Format the number using scientific notation as a positive number. Negative\n   * formatting to be applied later.\n   * @private\n   * @param {number} num the number to format\n   * @return {string} the formatted number\n   */\n  _formatScientific: function _formatScientific(num) {\n    var n = new Number(num);\n    var formatted;\n    var factor,\n        str = n.toExponential(),\n        parts = str.split(\"e\"),\n        significant = parts[0],\n        exponent = parts[1],\n        numparts,\n        integral,\n        fraction;\n\n    if (this.maxFractionDigits > 0 || this.significantDigits > 0) {\n      // if there is a max fraction digits setting, round the fraction to\n      // the right length first by dividing or multiplying by powers of 10.\n      // manipulate the fraction digits so as to\n      // avoid the rounding errors of floating point numbers\n      var maxDigits = (this.maxFractionDigits || 25) + 1;\n\n      if (this.significantDigits > 0) {\n        maxDigits = Math.min(maxDigits, this.significantDigits);\n      }\n\n      significant = MathUtils.significant(significant, maxDigits, this.round);\n    }\n\n    numparts = (\"\" + significant).split(\".\");\n    integral = numparts[0];\n    fraction = numparts[1];\n\n    if (typeof this.maxFractionDigits !== 'undefined') {\n      fraction = fraction.substring(0, this.maxFractionDigits);\n    }\n\n    if (typeof this.minFractionDigits !== 'undefined') {\n      fraction = JSUtils.pad(fraction || \"\", this.minFractionDigits, true);\n    }\n\n    formatted = integral;\n\n    if (fraction.length) {\n      formatted += this.decimalSeparator + fraction;\n    }\n\n    formatted += this.exponentSymbol + exponent;\n    return formatted;\n  },\n\n  /**\n   * Formats the number as a positive number. Negative formatting to be applied later.\n   * @private\n   * @param {number} num the number to format\n   * @return {string} the formatted number\n   */\n  _formatStandard: function _formatStandard(num) {\n    var i;\n    var k;\n    var parts, integral, fraction, cycle, formatted;\n    num = Math.abs(this.constrain(num));\n    parts = (\"\" + num).split(\".\");\n    integral = parts[0].toString();\n    fraction = parts[1];\n\n    if (this.minFractionDigits > 0) {\n      fraction = JSUtils.pad(fraction || \"\", this.minFractionDigits, true);\n    }\n\n    if (this.secgroupSize > 0) {\n      if (integral.length > this.prigroupSize) {\n        var size1 = this.prigroupSize;\n        var size2 = integral.length;\n        var size3 = size2 - size1;\n        integral = integral.slice(0, size3) + this.groupingSeparator + integral.slice(size3);\n        var num_sec = integral.substring(0, integral.indexOf(this.groupingSeparator));\n        k = num_sec.length;\n\n        while (k > this.secgroupSize) {\n          var secsize1 = this.secgroupSize;\n          var secsize2 = num_sec.length;\n          var secsize3 = secsize2 - secsize1;\n          integral = integral.slice(0, secsize3) + this.groupingSeparator + integral.slice(secsize3);\n          num_sec = integral.substring(0, integral.indexOf(this.groupingSeparator));\n          k = num_sec.length;\n        }\n      }\n\n      formatted = integral;\n    } else if (this.prigroupSize !== 0) {\n      cycle = MathUtils.mod(integral.length - 1, this.prigroupSize);\n      formatted = \"\";\n\n      for (i = 0; i < integral.length - 1; i++) {\n        formatted += integral.charAt(i);\n\n        if (cycle === 0) {\n          formatted += this.groupingSeparator;\n        }\n\n        cycle = MathUtils.mod(cycle - 1, this.prigroupSize);\n      }\n\n      formatted += integral.charAt(integral.length - 1);\n    } else {\n      formatted = integral;\n    }\n\n    if (fraction && (typeof this.maxFractionDigits === 'undefined' && typeof this.significantDigits === 'undefined' || this.maxFractionDigits > 0 || this.significantDigits > 0)) {\n      formatted += this.decimalSeparator;\n      formatted += fraction;\n    }\n\n    if (this.digits) {\n      formatted = JSUtils.mapString(formatted, this.digits);\n    }\n\n    return formatted;\n  },\n\n  /**\n   * Format a number according to the settings of this number formatter instance.\n   * @param num {number|string|INumber|Number} a floating point number to format\n   * @return {string} a string containing the formatted number\n   */\n  format: function format(num) {\n    var formatted, n;\n\n    if (typeof num === 'undefined') {\n      return \"\";\n    } // convert to a real primitive number type\n\n\n    n = Number(num);\n\n    if (this.type === \"number\") {\n      formatted = this.style === \"scientific\" ? this._formatScientific(n) : this._formatStandard(n);\n\n      if (num < 0) {\n        formatted = this.templateNegative.format({\n          n: formatted\n        });\n      }\n    } else {\n      formatted = this._formatStandard(n);\n      var template = n < 0 ? this.templateNegative : this.template;\n      formatted = template.format({\n        n: formatted,\n        s: this.sign\n      });\n    }\n\n    return formatted;\n  },\n\n  /**\n   * Return the type of formatter. Valid values are \"number\", \"currency\", and\n   * \"percentage\".\n   *\n   * @return {string} the type of formatter\n   */\n  getType: function getType() {\n    return this.type;\n  },\n\n  /**\n   * Return the locale for this formatter instance.\n   * @return {Locale} the locale instance for this formatter\n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Returns true if this formatter groups together digits in the integral\n   * portion of a number, based on the options set up in the constructor. In\n   * most western European cultures, this means separating every 3 digits\n   * of the integral portion of a number with a particular character.\n   *\n   * @return {boolean} true if this formatter groups digits in the integral\n   * portion of the number\n   */\n  isGroupingUsed: function isGroupingUsed() {\n    return this.groupingSeparator !== 'undefined' && this.groupingSeparator.length > 0;\n  },\n\n  /**\n   * Returns the maximum fraction digits set up in the constructor.\n   *\n   * @return {number} the maximum number of fractional digits this\n   * formatter will format, or -1 for no maximum\n   */\n  getMaxFractionDigits: function getMaxFractionDigits() {\n    return typeof this.maxFractionDigits !== 'undefined' ? this.maxFractionDigits : -1;\n  },\n\n  /**\n   * Returns the minimum fraction digits set up in the constructor. If\n   * the formatter has the type \"currency\", then the minimum fraction\n   * digits is the amount of digits that is standard for the currency\n   * in question unless overridden in the options to the constructor.\n   *\n   * @return {number} the minimum number of fractional digits this\n   * formatter will format, or -1 for no minimum\n   */\n  getMinFractionDigits: function getMinFractionDigits() {\n    return typeof this.minFractionDigits !== 'undefined' ? this.minFractionDigits : -1;\n  },\n\n  /**\n    * Returns the significant digits set up in the constructor.\n    *\n    * @return {number} the number of significant digits this\n    * formatter will format, or -1 for no minimum\n    */\n  getSignificantDigits: function getSignificantDigits() {\n    return typeof this.significantDigits !== 'undefined' ? this.significantDigits : -1;\n  },\n\n  /**\n   * Returns the ISO 4217 code for the currency that this formatter formats.\n   * IF the typeof this formatter is not \"currency\", then this method will\n   * return undefined.\n   *\n   * @return {string} the ISO 4217 code for the currency that this formatter\n   * formats, or undefined if this not a currency formatter\n   */\n  getCurrency: function getCurrency() {\n    return this.currencyInfo && this.currencyInfo.getCode();\n  },\n\n  /**\n   * Returns the rounding mode set up in the constructor. The rounding mode\n   * controls how numbers are rounded when the integral or fraction digits\n   * of a number are limited.\n   *\n   * @return {string} the name of the rounding mode used in this formatter\n   */\n  getRoundingMode: function getRoundingMode() {\n    return this.roundingMode;\n  },\n\n  /**\n   * If this formatter is a currency formatter, then the style determines how the\n   * currency is denoted in the formatted output. This method returns the style\n   * that this formatter will produce. (See the constructor comment for more about\n   * the styles.)\n   * @return {string} the name of the style this formatter will use to format\n   * currency amounts, or \"undefined\" if this formatter is not a currency formatter\n   */\n  getStyle: function getStyle() {\n    return this.style;\n  }\n};\nmodule.exports = NumFmt;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/i18n/ilib/lib/NumFmt.js"],"names":["ilib","require","Utils","JSUtils","MathUtils","Locale","LocaleInfo","Currency","IString","INumber","NumFmt","options","sync","locale","type","loadParams","undefined","currency","maxFractionDigits","Number","minFractionDigits","significantDigits","style","useNative","roundingMode","localeInfo","onLoad","bind","li","templateNegative","getNegativeNumberFormat","templates","code","cur","currencyInfo","getFractionDigits","getCurrencyFormats","template","common","sign","getCode","getSign","_init","getPercentageFormat","getNegativePercentageFormat","getAvailableLocales","zeros","prototype","getUseNative","getDigitsStyle","getRoundingMode","round","prigroupSize","secgroupSize","getPrimaryGroupingDigits","getSecondaryGroupingDigits","groupingSeparator","getNativeGroupingSeparator","getGroupingSeparator","decimalSeparator","getNativeDecimalSeparator","getDecimalSeparator","nd","getNativeDigits","getDigits","digits","split","exponentSymbol","getExponential","constrain","num","parts","result","length","significant","shiftDecimal","_formatScientific","n","formatted","factor","str","toExponential","exponent","numparts","integral","fraction","maxDigits","Math","min","substring","pad","_formatStandard","i","k","cycle","abs","toString","size1","size2","size3","slice","num_sec","indexOf","secsize1","secsize2","secsize3","mod","charAt","mapString","format","s","getType","getLocale","isGroupingUsed","getMaxFractionDigits","getMinFractionDigits","getSignificantDigits","getCurrency","getStyle","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * NumFmt.js - Number formatter definition\n *\n * Copyright © 2012-2015, 2018 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends\nilib.js\nLocale.js\nLocaleInfo.js\nUtils.js\nMathUtils.js\nCurrency.js\nIString.js\nJSUtils.js\nINumber.js\n*/\n// !data localeinfo currency\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar Currency = require(\"./Currency.js\");\n\nvar IString = require(\"./IString.js\");\n\nvar INumber = require(\"./INumber.js\");\n/**\n * @class\n * Create a new number formatter instance. Locales differ in the way that digits\n * in a formatted number are grouped, in the way the decimal character is represented,\n * etc. Use this formatter to get it right for any locale.<p>\n *\n * This formatter can format plain numbers, currency amounts, and percentage amounts.<p>\n *\n * As with all formatters, the recommended\n * practice is to create one formatter and use it multiple times to format various\n * numbers.<p>\n *\n * The options can contain any of the following properties:\n *\n * <ul>\n * <li><i>locale</i> - use the conventions of the specified locale when figuring out how to\n * format a number.\n * <li><i>type</i> - the type of this formatter. Valid values are \"number\", \"currency\", or\n * \"percentage\". If this property is not specified, the default is \"number\".\n * <li><i>currency</i> - the ISO 4217 3-letter currency code to use when the formatter type\n * is \"currency\". This property is required for currency formatting. If the type property\n * is \"currency\" and the currency property is not specified, the constructor will throw a\n * an exception.\n * <li><i>maxFractionDigits</i> - the maximum number of digits that should appear in the\n * formatted output after the decimal. A value of -1 means unlimited, and 0 means only print\n * the integral part of the number.\n * <li><i>minFractionDigits</i> - the minimum number of fractional digits that should\n * appear in the formatted output. If the number does not have enough fractional digits\n * to reach this minimum, the number will be zero-padded at the end to get to the limit.\n * If the type of the formatter is \"currency\" and this\n * property is not specified, then the minimum fraction digits is set to the normal number\n * of digits used with that currency, which is almost always 0, 2, or 3 digits.\n * <li><i>significantDigits</i> - specify that max number of significant digits in the\n * formatted output. This applies before and after the decimal point. The amount is\n * rounded according to the rounding mode specified, or the rounding mode as given in\n * the locale information. If the significant digits and the max or min fraction digits\n * are both specified, this formatter will attempt to honour them both by choosing the\n * one that is smaller if there is a conflict. For example, if the max fraction digits\n * is 6 and the significant digits is 5 and the number to be formatted has a long\n * fraction, it will only format 5 digits. The default is \"unlimited digits\", which means\n * to format as many digits as the javascript engine can represent internally (usually\n * around 13-15 or so on a 64-bit machine).\n * <li><i>useNative</i> - the flag used to determaine whether to use the native script settings\n * for formatting the numbers .\n * <li><i>roundingMode</i> - When the maxFractionDigits or maxIntegerDigits is specified,\n * this property governs how the least significant digits are rounded to conform to that\n * maximum. The value of this property is a string with one of the following values:\n * <ul>\n *   <li><i>up</i> - round away from zero\n *   <li><i>down</i> - round towards zero. This has the effect of truncating the number\n *   <li><i>ceiling</i> - round towards positive infinity\n *   <li><i>floor</i> - round towards negative infinity\n *   <li><i>halfup</i> - round towards nearest neighbour. If equidistant, round up.\n *   <li><i>halfdown</i> - round towards nearest neighbour. If equidistant, round down.\n *   <li><i>halfeven</i> - round towards nearest neighbour. If equidistant, round towards the even neighbour\n *   <li><i>halfodd</i> - round towards nearest neighbour. If equidistant, round towards the odd neighbour\n * </ul>\n * When the type of the formatter is \"currency\" and the <i>roundingMode</i> property is not\n * set, then the standard legal rounding rules for the locale are followed. If the type\n * is \"number\" or \"percentage\" and the <i>roundingMode</i> property is not set, then the\n * default mode is \"halfdown\".</i>.\n *\n * <li><i>style</i> - When the type of this formatter is \"currency\", the currency amount\n * can be formatted in the following styles: \"common\" and \"iso\". The common style is the\n * one commonly used in every day writing where the currency unit is represented using a\n * symbol. eg. \"$57.35\" for fifty-seven dollars and thirty five cents. The iso style is\n * the international style where the currency unit is represented using the ISO 4217 code.\n * eg. \"USD 57.35\" for the same amount. The default is \"common\" style if the style is\n * not specified.<p>\n *\n * When the type of this formatter is \"number\", the style can be one of the following:\n * <ul>\n *   <li><i>standard - format a fully specified floating point number properly for the locale\n *   <li><i>scientific</i> - use scientific notation for all numbers. That is, 1 integral\n *   digit, followed by a number of fractional digits, followed by an \"e\" which denotes\n *   exponentiation, followed digits which give the power of 10 in the exponent.\n *   <li><i>native</i> - format a floating point number using the native digits and\n *   formatting symbols for the script of the locale.\n *   <li><i>nogrouping</i> - format a floating point number without grouping digits for\n *   the integral portion of the number\n * </ul>\n * Note that if you specify a maximum number\n * of integral digits, the formatter with a standard style will give you standard\n * formatting for smaller numbers and scientific notation for larger numbers. The default\n * is standard style if this is not specified.\n *\n * <li><i>onLoad</i> - a callback function to call when the format data is fully\n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the\n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two.\n *\n * <li>sync - tell whether to load any missing locale data synchronously or\n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the\n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object\n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * <p>\n *\n *\n * @constructor\n * @param {Object.<string,*>} options A set of options that govern how the formatter will behave\n */\n\n\nvar NumFmt = function NumFmt(options) {\n  var sync = true;\n  this.locale = new Locale();\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this.type = \"number\";\n  var loadParams = undefined;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.type) {\n      if (options.type === 'number' || options.type === 'currency' || options.type === 'percentage') {\n        this.type = options.type;\n      }\n    }\n\n    if (options.currency) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.currency = options.currency;\n    }\n\n    if (typeof options.maxFractionDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.maxFractionDigits = Number(options.maxFractionDigits);\n    }\n\n    if (typeof options.minFractionDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.minFractionDigits = Number(options.minFractionDigits); // enforce the limits to avoid JS exceptions\n\n      if (this.minFractionDigits < 0) {\n        this.minFractionDigits = 0;\n      }\n\n      if (this.minFractionDigits > 20) {\n        this.minFractionDigits = 20;\n      }\n    }\n\n    if (typeof options.significantDigits !== 'undefined') {\n      /**\n       * @private\n       * @type {number|undefined}\n       */\n      this.significantDigits = Number(options.significantDigits); // enforce the limits to avoid JS exceptions\n\n      if (this.significantDigits < 1) {\n        this.significantDigits = 1;\n      }\n\n      if (this.significantDigits > 20) {\n        this.significantDigits = 20;\n      }\n    }\n\n    if (options.style) {\n      /**\n       * @private\n       * @type {string}\n       */\n      this.style = options.style;\n    }\n\n    if (typeof options.useNative === 'boolean') {\n      /**\n       * @private\n       * @type {boolean}\n       * */\n      this.useNative = options.useNative;\n    }\n    /**\n     * @private\n     * @type {string}\n     */\n\n\n    this.roundingMode = options.roundingMode;\n\n    if (typeof options.sync === 'boolean') {\n      sync = options.sync;\n    }\n\n    loadParams = options.loadParams;\n  }\n  /**\n   * @private\n   * @type {LocaleInfo|undefined}\n   */\n\n\n  this.localeInfo = undefined;\n  new LocaleInfo(this.locale, {\n    sync: sync,\n    loadParams: loadParams,\n    onLoad: ilib.bind(this, function (li) {\n      /**\n       * @private\n       * @type {LocaleInfo|undefined}\n       */\n      this.localeInfo = li;\n\n      if (this.type === \"number\") {\n        this.templateNegative = new IString(this.localeInfo.getNegativeNumberFormat() || \"-{n}\");\n      } else if (this.type === \"currency\") {\n        var templates;\n\n        if (!this.currency || typeof this.currency != 'string') {\n          throw \"A currency property is required in the options to the number formatter constructor when the type property is set to currency.\";\n        }\n\n        new Currency({\n          locale: this.locale,\n          code: this.currency,\n          sync: sync,\n          loadParams: loadParams,\n          onLoad: ilib.bind(this, function (cur) {\n            this.currencyInfo = cur;\n\n            if (this.style !== \"common\" && this.style !== \"iso\") {\n              this.style = \"common\";\n            }\n\n            if (typeof this.maxFractionDigits !== 'number' && typeof this.minFractionDigits !== 'number') {\n              this.minFractionDigits = this.maxFractionDigits = this.currencyInfo.getFractionDigits();\n            }\n\n            templates = this.localeInfo.getCurrencyFormats();\n            this.template = new IString(templates[this.style] || templates.common);\n            this.templateNegative = new IString(templates[this.style + \"Negative\"] || templates[\"commonNegative\"]);\n            this.sign = this.style === \"iso\" ? this.currencyInfo.getCode() : this.currencyInfo.getSign();\n\n            if (!this.roundingMode) {\n              this.roundingMode = this.currencyInfo && this.currencyInfo.roundingMode;\n            }\n\n            this._init();\n\n            if (options && typeof options.onLoad === 'function') {\n              options.onLoad(this);\n            }\n          })\n        });\n        return;\n      } else if (this.type === \"percentage\") {\n        this.template = new IString(this.localeInfo.getPercentageFormat() || \"{n}%\");\n        this.templateNegative = new IString(this.localeInfo.getNegativePercentageFormat() || this.localeInfo.getNegativeNumberFormat() + \"%\");\n      }\n\n      this._init();\n\n      if (options && typeof options.onLoad === 'function') {\n        options.onLoad(this);\n      }\n    })\n  });\n};\n/**\n * Return an array of available locales that this formatter can format\n * @static\n * @return {Array.<Locale>|undefined} an array of available locales\n */\n\n\nNumFmt.getAvailableLocales = function () {\n  return undefined;\n};\n/**\n * @private\n * @const\n * @type string\n */\n\n\nNumFmt.zeros = \"0000000000000000000000000000000000000000000000000000000000000000000000\";\nNumFmt.prototype = {\n  /**\n   * Return true if this formatter uses native digits to format the number. If the useNative\n   * option is given to the constructor, then this flag will be honoured. If the useNative\n   * option is not given to the constructor, this this formatter will use native digits if\n   * the locale typically uses native digits.\n   *\n   *  @return {boolean} true if this formatter will format with native digits, false otherwise\n   */\n  getUseNative: function getUseNative() {\n    if (typeof this.useNative === \"boolean\") {\n      return this.useNative;\n    }\n\n    return this.localeInfo.getDigitsStyle() === \"native\";\n  },\n\n  /**\n   * @private\n   */\n  _init: function _init() {\n    if (this.maxFractionDigits < this.minFractionDigits) {\n      this.minFractionDigits = this.maxFractionDigits;\n    }\n\n    if (!this.roundingMode) {\n      this.roundingMode = this.localeInfo.getRoundingMode();\n    }\n\n    if (!this.roundingMode) {\n      this.roundingMode = \"halfdown\";\n    } // set up the function, so we only have to figure it out once\n    // and not every time we do format()\n\n\n    this.round = MathUtils[this.roundingMode];\n\n    if (!this.round) {\n      this.roundingMode = \"halfdown\";\n      this.round = MathUtils[this.roundingMode];\n    }\n\n    if (this.style === \"nogrouping\") {\n      this.prigroupSize = this.secgroupSize = 0;\n    } else {\n      this.prigroupSize = this.localeInfo.getPrimaryGroupingDigits();\n      this.secgroupSize = this.localeInfo.getSecondaryGroupingDigits();\n      this.groupingSeparator = this.getUseNative() ? this.localeInfo.getNativeGroupingSeparator() : this.localeInfo.getGroupingSeparator();\n    }\n\n    this.decimalSeparator = this.getUseNative() ? this.localeInfo.getNativeDecimalSeparator() : this.localeInfo.getDecimalSeparator();\n\n    if (this.getUseNative()) {\n      var nd = this.localeInfo.getNativeDigits() || this.localeInfo.getDigits();\n\n      if (nd) {\n        this.digits = nd.split(\"\");\n      }\n    }\n\n    this.exponentSymbol = this.localeInfo.getExponential() || \"e\";\n  },\n\n  /**\n   * Apply the constraints used in the current formatter to the given number. This will\n   * will apply the maxFractionDigits, significantDigits, and rounding mode\n   * constraints and return the result. The result is further\n   * manipulated in the format method to produce the final formatted number string.\n   * This method is intended for use by code that needs to use the same number that\n   * this formatter instance uses for formatting before that number is turned into a\n   * formatted string.\n   *\n   * @param {number} num the number to constrain\n   * @returns {number} the number with the constraints applied to it\n   */\n  constrain: function constrain(num) {\n    var parts = (\"\" + num).split(\".\"),\n        result = num; // only apply the either significantDigits or the maxFractionDigits -- whichever results in a shorter fractional part\n\n    if (typeof this.significantDigits !== 'undefined' && this.significantDigits > 0 && (typeof this.maxFractionDigits === 'undefined' || this.maxFractionDigits < 0 || parts[0].length + this.maxFractionDigits > this.significantDigits)) {\n      result = MathUtils.significant(result, this.significantDigits, this.round);\n    }\n\n    if (typeof this.maxFractionDigits !== 'undefined' && this.maxFractionDigits > -1) {\n      result = MathUtils.shiftDecimal(this.round(MathUtils.shiftDecimal(result, this.maxFractionDigits)), -this.maxFractionDigits);\n    }\n\n    return result;\n  },\n\n  /**\n   * Format the number using scientific notation as a positive number. Negative\n   * formatting to be applied later.\n   * @private\n   * @param {number} num the number to format\n   * @return {string} the formatted number\n   */\n  _formatScientific: function _formatScientific(num) {\n    var n = new Number(num);\n    var formatted;\n    var factor,\n        str = n.toExponential(),\n        parts = str.split(\"e\"),\n        significant = parts[0],\n        exponent = parts[1],\n        numparts,\n        integral,\n        fraction;\n\n    if (this.maxFractionDigits > 0 || this.significantDigits > 0) {\n      // if there is a max fraction digits setting, round the fraction to\n      // the right length first by dividing or multiplying by powers of 10.\n      // manipulate the fraction digits so as to\n      // avoid the rounding errors of floating point numbers\n      var maxDigits = (this.maxFractionDigits || 25) + 1;\n\n      if (this.significantDigits > 0) {\n        maxDigits = Math.min(maxDigits, this.significantDigits);\n      }\n\n      significant = MathUtils.significant(significant, maxDigits, this.round);\n    }\n\n    numparts = (\"\" + significant).split(\".\");\n    integral = numparts[0];\n    fraction = numparts[1];\n\n    if (typeof this.maxFractionDigits !== 'undefined') {\n      fraction = fraction.substring(0, this.maxFractionDigits);\n    }\n\n    if (typeof this.minFractionDigits !== 'undefined') {\n      fraction = JSUtils.pad(fraction || \"\", this.minFractionDigits, true);\n    }\n\n    formatted = integral;\n\n    if (fraction.length) {\n      formatted += this.decimalSeparator + fraction;\n    }\n\n    formatted += this.exponentSymbol + exponent;\n    return formatted;\n  },\n\n  /**\n   * Formats the number as a positive number. Negative formatting to be applied later.\n   * @private\n   * @param {number} num the number to format\n   * @return {string} the formatted number\n   */\n  _formatStandard: function _formatStandard(num) {\n    var i;\n    var k;\n    var parts, integral, fraction, cycle, formatted;\n    num = Math.abs(this.constrain(num));\n    parts = (\"\" + num).split(\".\");\n    integral = parts[0].toString();\n    fraction = parts[1];\n\n    if (this.minFractionDigits > 0) {\n      fraction = JSUtils.pad(fraction || \"\", this.minFractionDigits, true);\n    }\n\n    if (this.secgroupSize > 0) {\n      if (integral.length > this.prigroupSize) {\n        var size1 = this.prigroupSize;\n        var size2 = integral.length;\n        var size3 = size2 - size1;\n        integral = integral.slice(0, size3) + this.groupingSeparator + integral.slice(size3);\n        var num_sec = integral.substring(0, integral.indexOf(this.groupingSeparator));\n        k = num_sec.length;\n\n        while (k > this.secgroupSize) {\n          var secsize1 = this.secgroupSize;\n          var secsize2 = num_sec.length;\n          var secsize3 = secsize2 - secsize1;\n          integral = integral.slice(0, secsize3) + this.groupingSeparator + integral.slice(secsize3);\n          num_sec = integral.substring(0, integral.indexOf(this.groupingSeparator));\n          k = num_sec.length;\n        }\n      }\n\n      formatted = integral;\n    } else if (this.prigroupSize !== 0) {\n      cycle = MathUtils.mod(integral.length - 1, this.prigroupSize);\n      formatted = \"\";\n\n      for (i = 0; i < integral.length - 1; i++) {\n        formatted += integral.charAt(i);\n\n        if (cycle === 0) {\n          formatted += this.groupingSeparator;\n        }\n\n        cycle = MathUtils.mod(cycle - 1, this.prigroupSize);\n      }\n\n      formatted += integral.charAt(integral.length - 1);\n    } else {\n      formatted = integral;\n    }\n\n    if (fraction && (typeof this.maxFractionDigits === 'undefined' && typeof this.significantDigits === 'undefined' || this.maxFractionDigits > 0 || this.significantDigits > 0)) {\n      formatted += this.decimalSeparator;\n      formatted += fraction;\n    }\n\n    if (this.digits) {\n      formatted = JSUtils.mapString(formatted, this.digits);\n    }\n\n    return formatted;\n  },\n\n  /**\n   * Format a number according to the settings of this number formatter instance.\n   * @param num {number|string|INumber|Number} a floating point number to format\n   * @return {string} a string containing the formatted number\n   */\n  format: function format(num) {\n    var formatted, n;\n\n    if (typeof num === 'undefined') {\n      return \"\";\n    } // convert to a real primitive number type\n\n\n    n = Number(num);\n\n    if (this.type === \"number\") {\n      formatted = this.style === \"scientific\" ? this._formatScientific(n) : this._formatStandard(n);\n\n      if (num < 0) {\n        formatted = this.templateNegative.format({\n          n: formatted\n        });\n      }\n    } else {\n      formatted = this._formatStandard(n);\n      var template = n < 0 ? this.templateNegative : this.template;\n      formatted = template.format({\n        n: formatted,\n        s: this.sign\n      });\n    }\n\n    return formatted;\n  },\n\n  /**\n   * Return the type of formatter. Valid values are \"number\", \"currency\", and\n   * \"percentage\".\n   *\n   * @return {string} the type of formatter\n   */\n  getType: function getType() {\n    return this.type;\n  },\n\n  /**\n   * Return the locale for this formatter instance.\n   * @return {Locale} the locale instance for this formatter\n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Returns true if this formatter groups together digits in the integral\n   * portion of a number, based on the options set up in the constructor. In\n   * most western European cultures, this means separating every 3 digits\n   * of the integral portion of a number with a particular character.\n   *\n   * @return {boolean} true if this formatter groups digits in the integral\n   * portion of the number\n   */\n  isGroupingUsed: function isGroupingUsed() {\n    return this.groupingSeparator !== 'undefined' && this.groupingSeparator.length > 0;\n  },\n\n  /**\n   * Returns the maximum fraction digits set up in the constructor.\n   *\n   * @return {number} the maximum number of fractional digits this\n   * formatter will format, or -1 for no maximum\n   */\n  getMaxFractionDigits: function getMaxFractionDigits() {\n    return typeof this.maxFractionDigits !== 'undefined' ? this.maxFractionDigits : -1;\n  },\n\n  /**\n   * Returns the minimum fraction digits set up in the constructor. If\n   * the formatter has the type \"currency\", then the minimum fraction\n   * digits is the amount of digits that is standard for the currency\n   * in question unless overridden in the options to the constructor.\n   *\n   * @return {number} the minimum number of fractional digits this\n   * formatter will format, or -1 for no minimum\n   */\n  getMinFractionDigits: function getMinFractionDigits() {\n    return typeof this.minFractionDigits !== 'undefined' ? this.minFractionDigits : -1;\n  },\n\n  /**\n    * Returns the significant digits set up in the constructor.\n    *\n    * @return {number} the number of significant digits this\n    * formatter will format, or -1 for no minimum\n    */\n  getSignificantDigits: function getSignificantDigits() {\n    return typeof this.significantDigits !== 'undefined' ? this.significantDigits : -1;\n  },\n\n  /**\n   * Returns the ISO 4217 code for the currency that this formatter formats.\n   * IF the typeof this formatter is not \"currency\", then this method will\n   * return undefined.\n   *\n   * @return {string} the ISO 4217 code for the currency that this formatter\n   * formats, or undefined if this not a currency formatter\n   */\n  getCurrency: function getCurrency() {\n    return this.currencyInfo && this.currencyInfo.getCode();\n  },\n\n  /**\n   * Returns the rounding mode set up in the constructor. The rounding mode\n   * controls how numbers are rounded when the integral or fraction digits\n   * of a number are limited.\n   *\n   * @return {string} the name of the rounding mode used in this formatter\n   */\n  getRoundingMode: function getRoundingMode() {\n    return this.roundingMode;\n  },\n\n  /**\n   * If this formatter is a currency formatter, then the style determines how the\n   * currency is denoted in the formatted output. This method returns the style\n   * that this formatter will produce. (See the constructor comment for more about\n   * the styles.)\n   * @return {string} the name of the style this formatter will use to format\n   * currency amounts, or \"undefined\" if this formatter is not a currency formatter\n   */\n  getStyle: function getStyle() {\n    return this.style;\n  }\n};\nmodule.exports = NumFmt;"]},"metadata":{},"sourceType":"module"}