{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n/*\n * JSUtils.js - Misc utilities to work around Javascript engine differences\n * \n * Copyright © 2013-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js\n\n\nvar ilib = require(\"./ilib.js\");\n\nvar JSUtils = {};\n/**\n * Perform a shallow copy of the source object to the target object. This only \n * copies the assignments of the source properties to the target properties, \n * but not recursively from there.<p>\n * \n * \n * @static\n * @param {Object} source the source object to copy properties from\n * @param {Object} target the target object to copy properties into\n */\n\nJSUtils.shallowCopy = function (source, target) {\n  var prop = undefined;\n\n  if (source && target) {\n    for (prop in source) {\n      if (prop !== undefined && typeof source[prop] !== 'undefined') {\n        target[prop] = source[prop];\n      }\n    }\n  }\n};\n/**\n * Perform a recursive deep copy from the \"from\" object to the \"deep\" object.\n * \n * @static\n * @param {Object} from the object to copy from\n * @param {Object} to the object to copy to\n * @return {Object} a reference to the the \"to\" object\n */\n\n\nJSUtils.deepCopy = function (from, to) {\n  var prop;\n\n  for (prop in from) {\n    if (prop) {\n      if (_typeof(from[prop]) === 'object') {\n        to[prop] = {};\n        JSUtils.deepCopy(from[prop], to[prop]);\n      } else {\n        to[prop] = from[prop];\n      }\n    }\n  }\n\n  return to;\n};\n/**\n * Map a string to the given set of alternate characters. If the target set\n * does not contain a particular character in the input string, then that\n * character will be copied to the output unmapped.\n * \n * @static\n * @param {string} str a string to map to an alternate set of characters\n * @param {Array.<string>|Object} map a mapping to alternate characters\n * @return {string} the source string where each character is mapped to alternate characters\n */\n\n\nJSUtils.mapString = function (str, map) {\n  var mapped = \"\";\n\n  if (map && str) {\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i); // TODO use a char iterator?\n\n      mapped += map[c] || c;\n    }\n  } else {\n    mapped = str;\n  }\n\n  return mapped;\n};\n/**\n * Check if an object is a member of the given array. If this javascript engine\n * support indexOf, it is used directly. Otherwise, this function implements it\n * itself. The idea is to make sure that you can use the quick indexOf if it is\n * available, but use a slower implementation in older engines as well.\n * \n * @static\n * @param {Array.<Object>} array array to search\n * @param {Object} obj object being sought. This should be of the same type as the\n * members of the array being searched. If not, this function will not return\n * any results.\n * @return {number} index of the object in the array, or -1 if it is not in the array.\n */\n\n\nJSUtils.indexOf = function (array, obj) {\n  if (!array || !obj) {\n    return -1;\n  }\n\n  if (typeof array.indexOf === 'function') {\n    return array.indexOf(obj);\n  } else {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === obj) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n};\n/**\n * Pad the str with zeros to the given length of digits.\n * \n * @static\n * @param {string|number} str the string or number to pad\n * @param {number} length the desired total length of the output string, padded\n * @param {boolean=} right if true, pad on the right side of the number rather than the left.\n * Default is false.\n */\n\n\nJSUtils.pad = function (str, length, right) {\n  if (typeof str !== 'string') {\n    str = \"\" + str;\n  }\n\n  var start = 0; // take care of negative numbers\n\n  if (str.charAt(0) === '-') {\n    start++;\n  }\n\n  return str.length >= length + start ? str : right ? str + JSUtils.pad.zeros.substring(0, length - str.length + start) : str.substring(0, start) + JSUtils.pad.zeros.substring(0, length - str.length + start) + str.substring(start);\n};\n/** @private */\n\n\nJSUtils.pad.zeros = \"00000000000000000000000000000000\";\n/**\n * Convert a string into the hexadecimal representation\n * of the Unicode characters in that string.\n * \n * @static\n * @param {string} string The string to convert\n * @param {number=} limit the number of digits to use to represent the character (1 to 8)\n * @return {string} a hexadecimal representation of the\n * Unicode characters in the input string\n */\n\nJSUtils.toHexString = function (string, limit) {\n  var i,\n      result = \"\",\n      lim = limit && limit < 9 ? limit : 4;\n\n  if (!string) {\n    return \"\";\n  }\n\n  for (i = 0; i < string.length; i++) {\n    var ch = string.charCodeAt(i).toString(16);\n    result += JSUtils.pad(ch, lim);\n  }\n\n  return result.toUpperCase();\n};\n/**\n * Test whether an object in a Javascript Date. \n * \n * @static\n * @param {Object|null|undefined} object The object to test\n * @return {boolean} return true if the object is a Date\n * and false otherwise\n */\n\n\nJSUtils.isDate = function (object) {\n  if (_typeof(object) === 'object') {\n    return Object.prototype.toString.call(object) === '[object Date]';\n  }\n\n  return false;\n};\n/**\n * Merge the properties of object2 into object1 in a deep manner and return a merged\n * object. If the property exists in both objects, the value in object2 will overwrite \n * the value in object1. If a property exists in object1, but not in object2, its value\n * will not be touched. If a property exists in object2, but not in object1, it will be \n * added to the merged result.<p>\n * \n * Name1 and name2 are for creating debug output only. They are not necessary.<p>\n * \n * \n * @static\n * @param {*} object1 the object to merge into\n * @param {*} object2 the object to merge\n * @param {boolean=} replace if true, replace the array elements in object1 with those in object2.\n * If false, concatenate array elements in object1 with items in object2.\n * @param {string=} name1 name of the object being merged into\n * @param {string=} name2 name of the object being merged in\n * @return {Object} the merged object\n */\n\n\nJSUtils.merge = function (object1, object2, replace, name1, name2) {\n  var prop = undefined,\n      newObj = {};\n\n  for (prop in object1) {\n    if (prop && typeof object1[prop] !== 'undefined') {\n      newObj[prop] = object1[prop];\n    }\n  }\n\n  for (prop in object2) {\n    if (prop && typeof object2[prop] !== 'undefined') {\n      if (ilib.isArray(object1[prop]) && ilib.isArray(object2[prop])) {\n        if (typeof replace !== 'boolean' || !replace) {\n          newObj[prop] = [].concat(object1[prop]);\n          newObj[prop] = newObj[prop].concat(object2[prop]);\n        } else {\n          newObj[prop] = object2[prop];\n        }\n      } else if (_typeof(object1[prop]) === 'object' && _typeof(object2[prop]) === 'object') {\n        newObj[prop] = JSUtils.merge(object1[prop], object2[prop], replace);\n      } else {\n        // for debugging. Used to determine whether or not json files are overriding their parents unnecessarily\n        if (name1 && name2 && newObj[prop] == object2[prop]) {\n          console.log(\"Property \" + prop + \" in \" + name1 + \" is being overridden by the same value in \" + name2);\n        }\n\n        newObj[prop] = object2[prop];\n      }\n    }\n  }\n\n  return newObj;\n};\n/**\n * Return true if the given object has no properties.<p>\n * \n * \n * @static\n * @param {Object} obj the object to check\n * @return {boolean} true if the given object has no properties, false otherwise\n */\n\n\nJSUtils.isEmpty = function (obj) {\n  var prop = undefined;\n\n  if (!obj) {\n    return true;\n  }\n\n  for (prop in obj) {\n    if (prop && typeof obj[prop] !== 'undefined') {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * @static\n */\n\n\nJSUtils.hashCode = function (obj) {\n  var hash = 0;\n\n  function addHash(hash, newValue) {\n    // co-prime numbers creates a nicely distributed hash\n    hash *= 65543;\n    hash += newValue;\n    hash %= 2147483647;\n    return hash;\n  }\n\n  function stringHash(str) {\n    var hash = 0;\n\n    for (var i = 0; i < str.length; i++) {\n      hash = addHash(hash, str.charCodeAt(i));\n    }\n\n    return hash;\n  }\n\n  switch (_typeof(obj)) {\n    case 'undefined':\n      hash = 0;\n      break;\n\n    case 'string':\n      hash = stringHash(obj);\n      break;\n\n    case 'function':\n    case 'number':\n    case 'xml':\n      hash = stringHash(String(obj));\n      break;\n\n    case 'boolean':\n      hash = obj ? 1 : 0;\n      break;\n\n    case 'object':\n      var props = [];\n\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p)) {\n          props.push(p);\n        }\n      } // make sure the order of the properties doesn't matter\n\n\n      props.sort();\n\n      for (var i = 0; i < props.length; i++) {\n        hash = addHash(hash, stringHash(props[i]));\n        hash = addHash(hash, JSUtils.hashCode(obj[props[i]]));\n      }\n\n      break;\n  }\n\n  return hash;\n};\n\nmodule.exports = JSUtils;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteAPp\\node_modules\\@enact\\i18n\\ilib\\lib\\JSUtils.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","ilib","require","JSUtils","shallowCopy","source","target","prop","undefined","deepCopy","from","to","mapString","str","map","mapped","i","length","c","charAt","indexOf","array","pad","right","start","zeros","substring","toHexString","string","limit","result","lim","ch","charCodeAt","toString","toUpperCase","isDate","object","Object","call","merge","object1","object2","replace","name1","name2","newObj","isArray","concat","console","log","isEmpty","hashCode","hash","addHash","newValue","stringHash","String","props","p","hasOwnProperty","push","sort","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * JSUtils.js - Misc utilities to work around Javascript engine differences\n * \n * Copyright © 2013-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js\nvar ilib = require(\"./ilib.js\");\n\nvar JSUtils = {};\n/**\n * Perform a shallow copy of the source object to the target object. This only \n * copies the assignments of the source properties to the target properties, \n * but not recursively from there.<p>\n * \n * \n * @static\n * @param {Object} source the source object to copy properties from\n * @param {Object} target the target object to copy properties into\n */\n\nJSUtils.shallowCopy = function (source, target) {\n  var prop = undefined;\n\n  if (source && target) {\n    for (prop in source) {\n      if (prop !== undefined && typeof source[prop] !== 'undefined') {\n        target[prop] = source[prop];\n      }\n    }\n  }\n};\n/**\n * Perform a recursive deep copy from the \"from\" object to the \"deep\" object.\n * \n * @static\n * @param {Object} from the object to copy from\n * @param {Object} to the object to copy to\n * @return {Object} a reference to the the \"to\" object\n */\n\n\nJSUtils.deepCopy = function (from, to) {\n  var prop;\n\n  for (prop in from) {\n    if (prop) {\n      if (_typeof(from[prop]) === 'object') {\n        to[prop] = {};\n        JSUtils.deepCopy(from[prop], to[prop]);\n      } else {\n        to[prop] = from[prop];\n      }\n    }\n  }\n\n  return to;\n};\n/**\n * Map a string to the given set of alternate characters. If the target set\n * does not contain a particular character in the input string, then that\n * character will be copied to the output unmapped.\n * \n * @static\n * @param {string} str a string to map to an alternate set of characters\n * @param {Array.<string>|Object} map a mapping to alternate characters\n * @return {string} the source string where each character is mapped to alternate characters\n */\n\n\nJSUtils.mapString = function (str, map) {\n  var mapped = \"\";\n\n  if (map && str) {\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i); // TODO use a char iterator?\n\n      mapped += map[c] || c;\n    }\n  } else {\n    mapped = str;\n  }\n\n  return mapped;\n};\n/**\n * Check if an object is a member of the given array. If this javascript engine\n * support indexOf, it is used directly. Otherwise, this function implements it\n * itself. The idea is to make sure that you can use the quick indexOf if it is\n * available, but use a slower implementation in older engines as well.\n * \n * @static\n * @param {Array.<Object>} array array to search\n * @param {Object} obj object being sought. This should be of the same type as the\n * members of the array being searched. If not, this function will not return\n * any results.\n * @return {number} index of the object in the array, or -1 if it is not in the array.\n */\n\n\nJSUtils.indexOf = function (array, obj) {\n  if (!array || !obj) {\n    return -1;\n  }\n\n  if (typeof array.indexOf === 'function') {\n    return array.indexOf(obj);\n  } else {\n    for (var i = 0; i < array.length; i++) {\n      if (array[i] === obj) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n};\n/**\n * Pad the str with zeros to the given length of digits.\n * \n * @static\n * @param {string|number} str the string or number to pad\n * @param {number} length the desired total length of the output string, padded\n * @param {boolean=} right if true, pad on the right side of the number rather than the left.\n * Default is false.\n */\n\n\nJSUtils.pad = function (str, length, right) {\n  if (typeof str !== 'string') {\n    str = \"\" + str;\n  }\n\n  var start = 0; // take care of negative numbers\n\n  if (str.charAt(0) === '-') {\n    start++;\n  }\n\n  return str.length >= length + start ? str : right ? str + JSUtils.pad.zeros.substring(0, length - str.length + start) : str.substring(0, start) + JSUtils.pad.zeros.substring(0, length - str.length + start) + str.substring(start);\n};\n/** @private */\n\n\nJSUtils.pad.zeros = \"00000000000000000000000000000000\";\n/**\n * Convert a string into the hexadecimal representation\n * of the Unicode characters in that string.\n * \n * @static\n * @param {string} string The string to convert\n * @param {number=} limit the number of digits to use to represent the character (1 to 8)\n * @return {string} a hexadecimal representation of the\n * Unicode characters in the input string\n */\n\nJSUtils.toHexString = function (string, limit) {\n  var i,\n      result = \"\",\n      lim = limit && limit < 9 ? limit : 4;\n\n  if (!string) {\n    return \"\";\n  }\n\n  for (i = 0; i < string.length; i++) {\n    var ch = string.charCodeAt(i).toString(16);\n    result += JSUtils.pad(ch, lim);\n  }\n\n  return result.toUpperCase();\n};\n/**\n * Test whether an object in a Javascript Date. \n * \n * @static\n * @param {Object|null|undefined} object The object to test\n * @return {boolean} return true if the object is a Date\n * and false otherwise\n */\n\n\nJSUtils.isDate = function (object) {\n  if (_typeof(object) === 'object') {\n    return Object.prototype.toString.call(object) === '[object Date]';\n  }\n\n  return false;\n};\n/**\n * Merge the properties of object2 into object1 in a deep manner and return a merged\n * object. If the property exists in both objects, the value in object2 will overwrite \n * the value in object1. If a property exists in object1, but not in object2, its value\n * will not be touched. If a property exists in object2, but not in object1, it will be \n * added to the merged result.<p>\n * \n * Name1 and name2 are for creating debug output only. They are not necessary.<p>\n * \n * \n * @static\n * @param {*} object1 the object to merge into\n * @param {*} object2 the object to merge\n * @param {boolean=} replace if true, replace the array elements in object1 with those in object2.\n * If false, concatenate array elements in object1 with items in object2.\n * @param {string=} name1 name of the object being merged into\n * @param {string=} name2 name of the object being merged in\n * @return {Object} the merged object\n */\n\n\nJSUtils.merge = function (object1, object2, replace, name1, name2) {\n  var prop = undefined,\n      newObj = {};\n\n  for (prop in object1) {\n    if (prop && typeof object1[prop] !== 'undefined') {\n      newObj[prop] = object1[prop];\n    }\n  }\n\n  for (prop in object2) {\n    if (prop && typeof object2[prop] !== 'undefined') {\n      if (ilib.isArray(object1[prop]) && ilib.isArray(object2[prop])) {\n        if (typeof replace !== 'boolean' || !replace) {\n          newObj[prop] = [].concat(object1[prop]);\n          newObj[prop] = newObj[prop].concat(object2[prop]);\n        } else {\n          newObj[prop] = object2[prop];\n        }\n      } else if (_typeof(object1[prop]) === 'object' && _typeof(object2[prop]) === 'object') {\n        newObj[prop] = JSUtils.merge(object1[prop], object2[prop], replace);\n      } else {\n        // for debugging. Used to determine whether or not json files are overriding their parents unnecessarily\n        if (name1 && name2 && newObj[prop] == object2[prop]) {\n          console.log(\"Property \" + prop + \" in \" + name1 + \" is being overridden by the same value in \" + name2);\n        }\n\n        newObj[prop] = object2[prop];\n      }\n    }\n  }\n\n  return newObj;\n};\n/**\n * Return true if the given object has no properties.<p>\n * \n * \n * @static\n * @param {Object} obj the object to check\n * @return {boolean} true if the given object has no properties, false otherwise\n */\n\n\nJSUtils.isEmpty = function (obj) {\n  var prop = undefined;\n\n  if (!obj) {\n    return true;\n  }\n\n  for (prop in obj) {\n    if (prop && typeof obj[prop] !== 'undefined') {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * @static\n */\n\n\nJSUtils.hashCode = function (obj) {\n  var hash = 0;\n\n  function addHash(hash, newValue) {\n    // co-prime numbers creates a nicely distributed hash\n    hash *= 65543;\n    hash += newValue;\n    hash %= 2147483647;\n    return hash;\n  }\n\n  function stringHash(str) {\n    var hash = 0;\n\n    for (var i = 0; i < str.length; i++) {\n      hash = addHash(hash, str.charCodeAt(i));\n    }\n\n    return hash;\n  }\n\n  switch (_typeof(obj)) {\n    case 'undefined':\n      hash = 0;\n      break;\n\n    case 'string':\n      hash = stringHash(obj);\n      break;\n\n    case 'function':\n    case 'number':\n    case 'xml':\n      hash = stringHash(String(obj));\n      break;\n\n    case 'boolean':\n      hash = obj ? 1 : 0;\n      break;\n\n    case 'object':\n      var props = [];\n\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p)) {\n          props.push(p);\n        }\n      } // make sure the order of the properties doesn't matter\n\n\n      props.sort();\n\n      for (var i = 0; i < props.length; i++) {\n        hash = addHash(hash, stringHash(props[i]));\n        hash = addHash(hash, JSUtils.hashCode(obj[props[i]]));\n      }\n\n      break;\n  }\n\n  return hash;\n};\n\nmodule.exports = JSUtils;"]},"metadata":{},"sourceType":"module"}