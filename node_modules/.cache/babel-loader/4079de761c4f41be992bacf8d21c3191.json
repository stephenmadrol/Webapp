{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.log = exports.handle = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports.forwardWithPrevent = exports.forward = exports.callOnEvent = exports.call = exports.adaptEvent = exports[\"default\"] = void 0;\n\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\n\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\n\nvar _keymap = require(\"../keymap\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import React from 'react';\n *\n * class MyComponent extends React.Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\n\n\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n}; // Loose check to determine if obj is component-ish if it has both props and context members\n\n\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && obj.hasOwnProperty && obj.hasOwnProperty('props') && obj.hasOwnProperty('context');\n};\n\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {// unable to set name of function\n    }\n  }\n\n  return fn;\n};\n\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n\n  if (name) {\n    obj[name] = bound;\n  }\n\n  return bound;\n};\n\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n\n  return fn;\n};\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...Function}  handlers List of handlers to process the event.\n *\n * @returns  {Function}\t    A function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\n\n\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n\n  var h = makeHandler(handlers); // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n\n  var _outer = this;\n\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null; // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n\n    return h.call(caller, ev, props, context);\n  };\n\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n\n      return result;\n    });\n  };\n\n  return decorateHandleFunction(fn);\n};\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...Function[]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {Function}\t    A function that accepts an event which is dispatched to each of the\n *                          conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\n\n\nexports.handle = handle;\n\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler change\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {Function}\t   A function that returns true\n * @memberof core/handle\n * @public\n */\n\n\nexports.oneOf = oneOf;\n\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler) {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n\n  return true;\n};\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called')\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {Boolean}                Always returns `true`\n * @memberof core/handle\n * @private\n */\n\n\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n\n  return true;\n});\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero')\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props')\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n\n  return true;\n}, 'forward'));\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called')\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {Boolean}           Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forward = forward;\n\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action')\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if default action is prevented\n * @memberof core/handle\n * @private\n */\n\n\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called')\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {Boolean}      Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called')\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {Boolean}          Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down')\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down')\n * );\n * ```\n *\n * @see      core/keymap\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @memberof core/handle\n * @public\n */\n\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true')\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          `true` if the value of `props[prop]` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {Boolean}             Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    } // eslint-disable-next-line no-console\n\n\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n\n  return true;\n});\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {Boolean}            Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\n\nexports.log = log;\n\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n\n    return false;\n  }, 'call');\n};\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {Function}  adapter  Function to adapt the event payload\n * @param    {Function}  handler  Handler to call with the new event payload\n * @param    {...*}      [args]   Additional args passed to both `adapter` and `handler`\n *\n * @returns  {Object}             New event payload\n * @memberof core/handle\n * @public\n */\n\n\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\nexports.adaptEvent = adaptEvent;\nvar _default = handle;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/cdi/SteApp/node_modules/@enact/core/handle/handle.js"],"names":["Object","defineProperty","exports","value","stopImmediate","stop","returnsTrue","preventDefault","oneOf","log","handle","forProp","forKeyCode","forKey","forEventProp","forwardWithPrevent","forward","callOnEvent","call","adaptEvent","_cond","_interopRequireDefault","require","_curry","_keymap","obj","__esModule","makeHandler","handlers","_len","arguments","length","args","Array","_key","i","fn","apply","hasPropsAndContext","hasOwnProperty","named","name","process","env","NODE_ENV","writeable","enumerable","err","bindAs","namedFunction","bound","bind","decorateHandleFunction","_len2","_key2","h","_outer","prepareHandleArgs","ev","props","context","caller","cleanup","handleWithFinally","result","_len3","_key3","handler","_len4","_key4","methodName","nativeEvent","prop","_preventDefault","prevented","wrappedEvent","assign","is","keyCode","message","_console","_len5","_key5","console","concat","method","adapter","_len6","_key6","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.log = exports.handle = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports.forwardWithPrevent = exports.forward = exports.callOnEvent = exports.call = exports.adaptEvent = exports[\"default\"] = void 0;\n\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\n\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\n\nvar _keymap = require(\"../keymap\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import React from 'react';\n *\n * class MyComponent extends React.Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  };\n}; // Loose check to determine if obj is component-ish if it has both props and context members\n\n\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && obj.hasOwnProperty && obj.hasOwnProperty('props') && obj.hasOwnProperty('context');\n};\n\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {// unable to set name of function\n    }\n  }\n\n  return fn;\n};\n\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n\n  if (name) {\n    obj[name] = bound;\n  }\n\n  return bound;\n};\n\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n\n  return fn;\n};\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...Function}  handlers List of handlers to process the event.\n *\n * @returns  {Function}\t    A function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\n\n\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n\n  var h = makeHandler(handlers); // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n\n  var _outer = this;\n\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null; // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n\n    return h.call(caller, ev, props, context);\n  };\n\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n\n      return result;\n    });\n  };\n\n  return decorateHandleFunction(fn);\n};\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...Function[]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {Function}\t    A function that accepts an event which is dispatched to each of the\n *                          conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\n\n\nexports.handle = handle;\n\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler change\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {Function}\t   A function that returns true\n * @memberof core/handle\n * @public\n */\n\n\nexports.oneOf = oneOf;\n\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler) {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n\n  return true;\n};\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called')\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {Boolean}                Always returns `true`\n * @memberof core/handle\n * @private\n */\n\n\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n\n  return true;\n});\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero')\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props')\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n\n  return true;\n}, 'forward'));\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called')\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {Boolean}           Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forward = forward;\n\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action')\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if default action is prevented\n * @memberof core/handle\n * @private\n */\n\n\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called')\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {Boolean}      Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called')\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {Boolean}          Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down')\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down')\n * );\n * ```\n *\n * @see      core/keymap\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @memberof core/handle\n * @public\n */\n\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true')\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          `true` if the value of `props[prop]` strictly equals `value`\n * @memberof core/handle\n * @public\n */\n\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {Boolean}             Always returns `true`\n * @memberof core/handle\n * @public\n */\n\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n\n    // eslint-disable-next-line no-console\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n\n  return true;\n});\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {Boolean}            Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\n\nexports.log = log;\n\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n\n    return false;\n  }, 'call');\n};\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {Function}  adapter  Function to adapt the event payload\n * @param    {Function}  handler  Handler to call with the new event payload\n * @param    {...*}      [args]   Additional args passed to both `adapter` and `handler`\n *\n * @returns  {Object}             New event payload\n * @memberof core/handle\n * @public\n */\n\n\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\nexports.adaptEvent = adaptEvent;\nvar _default = handle;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}