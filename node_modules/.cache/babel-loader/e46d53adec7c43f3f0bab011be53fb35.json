{"ast":null,"code":"\"use strict\";\n/*\n * ResBundle.js - Resource bundle definition\n * \n * Copyright © 2012-2016, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js Locale.js LocaleInfo.js IString.js Utils.js JSUtils.js\n// !data pseudomap\n\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IString = require(\"./IString.js\");\n/**\n * @class\n * Create a new resource bundle instance. The resource bundle loads strings\n * appropriate for a particular locale and provides them via the getString \n * method.<p>\n * \n * The options object may contain any (or none) of the following properties:\n * \n * <ul>\n * <li><i>locale</i> - The locale of the strings to load. If not specified, the default\n * locale is the the default for the web page or app in which the bundle is \n * being loaded.\n * \n * <li><i>name</i> - Base name of the resource bundle to load. If not specified the default\n * base name is \"resources\".\n * \n * <li><i>type</i> - Name the type of strings this bundle contains. Valid values are \n * \"xml\", \"html\", \"text\", \"c\", or \"raw\". The default is \"text\". If the type is \"xml\" or \"html\",\n * then XML/HTML entities and tags are not pseudo-translated. During a real translation, \n * HTML character entities are translated to their corresponding characters in a source\n * string before looking that string up in the translations. Also, the characters \"<\", \">\",\n * and \"&\" are converted to entities again in the output, but characters are left as they\n * are. If the type is \"xml\", \"html\", or \"text\" types, then the replacement parameter names\n * are not pseudo-translated as well so that the output can be used for formatting with \n * the IString class. If the type is \"c\" then all C language style printf replacement\n * parameters (eg. \"%s\" and \"%d\") are skipped automatically. If the type is raw, all characters \n * are pseudo-translated, including replacement parameters as well as XML/HTML tags and entities.\n * \n * <li><i>lengthen</i> - when pseudo-translating the string, tell whether or not to \n * automatically lengthen the string to simulate \"long\" languages such as German\n * or French. This is a boolean value. Default is false.\n * \n * <li><i>missing</i> - what to do when a resource is missing. The choices are:\n * <ul>\n *   <li><i>source</i> - return the source string unchanged\n *   <li><i>pseudo</i> - return the pseudo-translated source string, translated to the\n *   script of the locale if the mapping is available, or just the default Latin \n *   pseudo-translation if not\n *   <li><i>empty</i> - return the empty string \n * </ul>\n * The default behaviour is the same as before, which is to return the source string\n * unchanged.\n * \n * <li><i>onLoad</i> - a callback function to call when the resources are fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two. \n * \n * <li>sync - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while. \n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * The locale option may be given as a locale spec string or as an \n * Locale object. If the locale option is not specified, then strings for\n * the default locale will be loaded.<p> \n * \n * The name option can be used to put groups of strings together in a\n * single bundle. The strings will then appear together in a JS object in\n * a JS file that can be included before the ilib.<p>\n * \n * A resource bundle with a particular name is actually a set of bundles\n * that are each specific to a language, a language plus a region, etc. \n * All bundles with the same base name should\n * contain the same set of source strings, but with different translations for \n * the given locale. The user of the bundle does not need to be aware of \n * the locale of the bundle, as long as it contains values for the strings \n * it needs.<p>\n * \n * Strings in bundles for a particular locale are inherited from parent bundles\n * that are more generic. In general, the hierarchy is as follows (from \n * least locale-specific to most locale-specific):\n * \n * <ol>\n * <li> language\n * <li> region\n * <li> language_script\n * <li> language_region\n * <li> region_variant\n * <li> language_script_region\n * <li> language_region_variant\n * <li> language_script_region_variant\n * </ol>\n * \n * That is, if the translation for a string does not exist in the current\n * locale, the more-generic parent locale is searched for the string. In the\n * worst case scenario, the string is not found in the base locale's strings. \n * In this case, the missing option guides this class on what to do. If\n * the missing option is \"source\", then the original source is returned as \n * the translation. If it is \"empty\", the empty string is returned. If it\n * is \"pseudo\", then the pseudo-translated string that is appropriate for\n * the default script of the locale is returned.<p> \n * \n * This allows developers to create code with new or changed strings in it and check in that\n * code without waiting for the translations to be done first. The translated\n * version of the app or web site will still function properly, but will show \n * a spurious untranslated string here and there until the translations are \n * done and also checked in.<p>   \n *  \n * The base is whatever language your developers use to code in. For\n * a German web site, strings in the source code may be written in German \n * for example. Often this base is English, as many web sites are coded in\n * English, but that is not required.<p>\n * \n * The strings can be extracted with the ilib localization tool (which will be\n * shipped at some future time.) Once the strings\n * have been translated, the set of translated files can be generated with the\n * same tool. The output from the tool can be used as input to the ResBundle\n * object. It is up to the web page or app to make sure the JS file that defines\n * the bundle is included before creating the ResBundle instance.<p>\n * \n * A special locale \"zxx-XX\" is used as the pseudo-translation locale because\n * zxx means \"no linguistic information\" in the ISO 639 standard, and the region \n * code XX is defined to be user-defined in the ISO 3166 standard. \n * Pseudo-translation is a locale where the translations are generated on\n * the fly based on the contents of the source string. Characters in the source \n * string are replaced with other characters and returned. \n * \n * Example. If the source string is:\n * \n * <pre>\n * \"This is a string\"\n * </pre>\n * \n * then the pseudo-translated version might look something like this: \n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ\"\n * </pre>\n * <p>\n * \n * Pseudo-translation can be used to test that your app or web site is translatable\n * before an actual translation has happened. These bugs can then be fixed \n * before the translation starts, avoiding an explosion of bugs later when\n * each language's tester registers the same bug complaining that the same \n * string is not translated. When pseudo-localizing with\n * the Latin script, this allows the strings to be readable in the UI in the \n * source language (if somewhat funky-looking), \n * so that a tester can easily verify that the string is properly externalized \n * and loaded from a resource bundle without the need to be able to read a\n * foreign language.<p> \n * \n * If one of a list of script tags is given in the pseudo-locale specifier, then the\n * pseudo-localization can map characters to very rough transliterations of\n * characters in the given script. For example, zxx-Hebr-XX maps strings to\n * Hebrew characters, which can be used to test your UI in a right-to-left\n * language to catch bidi bugs before a translation is done. Currently, the\n * list of target scripts includes Hebrew (Hebr), Chinese Simplified Han (Hans),\n * and Cyrillic (Cyrl) with more to be added later. If no script is explicitly\n * specified in the locale spec, or if the script is not supported,\n * then the default mapping maps Latin base characters to accented versions of\n * those Latin characters as in the example above.\n *  \n * When the \"lengthen\" property is set to true in the options, the \n * pseudotranslation code will add digits to the end of the string to simulate\n * the lengthening that occurs when translating to other languages. The above \n * example will come out like this:\n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ76543210\"\n * </pre>\n * \n * The string is lengthened according to the length of the source string. If\n * the source string is less than 20 characters long, the string is lengthened \n * by 50%. If the source string is 20-40 \n * characters long, the string is lengthened by 33%. If te string is greater\n * than 40 characters long, the string is lengthened by 20%.<p>\n * \n * The pseudotranslation always ends a string with the digit \"0\". If you do\n * not see the digit \"0\" in the UI for your app, you know that truncation\n * has occurred, and the number you see at the end of the string tells you \n * how many characters were truncated.<p>\n * \n * \n * @constructor\n * @param {?Object} options Options controlling how the bundle is created\n */\n\n\nvar ResBundle = function ResBundle(options) {\n  var lookupLocale, spec;\n  this.locale = new Locale(); // use the default locale\n\n  this.baseName = \"strings\";\n  this.type = \"text\";\n  this.loadParams = {};\n  this.missing = \"source\";\n  this.sync = true;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.name) {\n      this.baseName = options.name;\n    }\n\n    if (options.type) {\n      this.type = options.type;\n    }\n\n    this.lengthen = options.lengthen || false;\n\n    if (typeof options.sync !== 'undefined') {\n      this.sync = options.sync == true;\n    }\n\n    if (typeof options.loadParams !== 'undefined') {\n      this.loadParams = options.loadParams;\n    }\n\n    if (typeof options.missing !== 'undefined') {\n      if (options.missing === \"pseudo\" || options.missing === \"empty\") {\n        this.missing = options.missing;\n      }\n    }\n  } else {\n    options = {\n      sync: true\n    };\n  }\n\n  this.map = {};\n\n  if (!ilib.data.cache.ResBundle) {\n    ilib.data.cache.ResBundle = {};\n  }\n\n  lookupLocale = this.locale.isPseudo() ? new Locale(\"en-US\") : this.locale;\n  var object = \"ResBundle-\" + this.baseName;\n  Utils.loadData({\n    object: object,\n    locale: lookupLocale,\n    name: this.baseName + \".json\",\n    sync: this.sync,\n    loadParams: this.loadParams,\n    callback: ilib.bind(this, function (map) {\n      if (!map) {\n        map = ilib.data[this.baseName] || {};\n        spec = lookupLocale.getSpec().replace(/-/g, '_');\n        ilib.data.cache[object][spec] = map;\n      }\n\n      this.map = map;\n\n      if (this.locale.isPseudo()) {\n        if (!ilib.data.cache.ResBundle.pseudomap) {\n          ilib.data.cache.ResBundle.pseudomap = {};\n        }\n\n        this._loadPseudo(this.locale, options.onLoad);\n      } else if (this.missing === \"pseudo\") {\n        if (!ilib.data.cache.ResBundle.pseudomap) {\n          ilib.data.cache.ResBundle.pseudomap = {};\n        }\n\n        new LocaleInfo(this.locale, {\n          sync: this.sync,\n          loadParams: this.loadParams,\n          onLoad: ilib.bind(this, function (li) {\n            var pseudoLocale = new Locale(\"zxx\", \"XX\", undefined, li.getDefaultScript());\n\n            this._loadPseudo(pseudoLocale, options.onLoad);\n          })\n        });\n      } else {\n        if (typeof options.onLoad === 'function') {\n          options.onLoad(this);\n        }\n      }\n    })\n  }); // console.log(\"Merged resources \" + this.locale.toString() + \" are: \" + JSON.stringify(this.map));\n  //if (!this.locale.isPseudo() && JSUtils.isEmpty(this.map)) {\n  //\tconsole.log(\"Resources for bundle \" + this.baseName + \" locale \" + this.locale.toString() + \" are not available.\");\n  //}\n};\n\nResBundle.defaultPseudo = ilib.data.pseudomap || {\n  \"a\": \"à\",\n  \"e\": \"ë\",\n  \"i\": \"í\",\n  \"o\": \"õ\",\n  \"u\": \"ü\",\n  \"y\": \"ÿ\",\n  \"A\": \"Ã\",\n  \"E\": \"Ë\",\n  \"I\": \"Ï\",\n  \"O\": \"Ø\",\n  \"U\": \"Ú\",\n  \"Y\": \"Ŷ\"\n};\nResBundle.prototype = {\n  /**\n   * @protected\n   */\n  _loadPseudo: function _loadPseudo(pseudoLocale, onLoad) {\n    Utils.loadData({\n      object: \"ResBundle\",\n      locale: pseudoLocale,\n      name: \"pseudomap.json\",\n      sync: this.sync,\n      loadParams: this.loadParams,\n      callback: ilib.bind(this, function (map) {\n        if (!map || JSUtils.isEmpty(map)) {\n          map = ResBundle.defaultPseudo;\n          var spec = pseudoLocale.getSpec().replace(/-/g, '_');\n          ilib.data.cache.ResBundle.pseudomap[spec] = map;\n        }\n\n        this.pseudomap = map;\n\n        if (typeof onLoad === 'function') {\n          onLoad(this);\n        }\n      })\n    });\n  },\n\n  /**\n   * Return the locale of this resource bundle.\n   * @return {Locale} the locale of this resource bundle object \n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Return the name of this resource bundle. This corresponds to the name option\n   * given to the constructor.\n   * @return {string} name of the the current instance\n   */\n  getName: function getName() {\n    return this.baseName;\n  },\n\n  /**\n   * Return the type of this resource bundle. This corresponds to the type option\n   * given to the constructor.\n   * @return {string} type of the the current instance\n   */\n  getType: function getType() {\n    return this.type;\n  },\n  percentRE: new RegExp(\"%(\\\\d+\\\\$)?([\\\\-#\\\\+ 0,\\\\(])?(\\\\d+)?(\\\\.\\\\d+)?[bBhHsScCdoxXeEfgGaAtT%n]\"),\n\n  /**\n   * @private\n   * Pseudo-translate a string\n   */\n  _pseudo: function _pseudo(str) {\n    if (!str) {\n      return undefined;\n    }\n\n    var ret = \"\",\n        i;\n\n    for (i = 0; i < str.length; i++) {\n      if (this.type !== \"raw\") {\n        if (this.type === \"html\" || this.type === \"xml\") {\n          if (str.charAt(i) === '<') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== '>') {\n              ret += str.charAt(i++);\n            }\n          } else if (str.charAt(i) === '&') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== ';' && str.charAt(i) !== ' ') {\n              ret += str.charAt(i++);\n            }\n          } else if (str.charAt(i) === '\\\\' && str.charAt(i + 1) === \"u\") {\n            ret += str.substring(i, i + 6);\n            i += 6;\n          }\n        } else if (this.type === \"c\") {\n          if (str.charAt(i) === \"%\") {\n            var m = this.percentRE.exec(str.substring(i));\n\n            if (m && m.length) {\n              // console.log(\"Match found: \" + JSON.stringify(m[0].replace(\"%\", \"%%\")));\n              ret += m[0];\n              i += m[0].length;\n            }\n          }\n        }\n\n        if (i < str.length) {\n          if (str.charAt(i) === '{') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== '}') {\n              ret += str.charAt(i++);\n            }\n\n            if (i < str.length) {\n              ret += str.charAt(i);\n            }\n          } else {\n            ret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n          }\n        }\n      } else {\n        ret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n      }\n    }\n\n    if (this.lengthen) {\n      var add;\n\n      if (ret.length <= 20) {\n        add = Math.round(ret.length / 2);\n      } else if (ret.length > 20 && ret.length <= 40) {\n        add = Math.round(ret.length / 3);\n      } else {\n        add = Math.round(ret.length / 5);\n      }\n\n      for (i = add - 1; i >= 0; i--) {\n        ret += i % 10;\n      }\n    }\n\n    if (this.locale.getScript() === \"Hans\" || this.locale.getScript() === \"Hant\" || this.locale.getScript() === \"Hani\" || this.locale.getScript() === \"Hrkt\" || this.locale.getScript() === \"Jpan\" || this.locale.getScript() === \"Hira\" || this.locale.getScript() === \"Kana\") {\n      // simulate Asian languages by getting rid of all the spaces\n      ret = ret.replace(/ /g, \"\");\n    }\n\n    return ret;\n  },\n\n  /**\n   * @private\n   * Escape html characters in the output.\n   */\n  _escapeXml: function _escapeXml(str) {\n    str = str.replace(/&/g, '&amp;');\n    str = str.replace(/</g, '&lt;');\n    str = str.replace(/>/g, '&gt;');\n    return str;\n  },\n\n  /**\n   * @private\n   * @param {string} str the string to unescape\n   */\n  _unescapeXml: function _unescapeXml(str) {\n    str = str.replace(/&amp;/g, '&');\n    str = str.replace(/&lt;/g, '<');\n    str = str.replace(/&gt;/g, '>');\n    return str;\n  },\n\n  /**\n   * @private\n   * Create a key name out of a source string. All this does so far is \n   * compress sequences of white space into a single space on the assumption\n   * that this doesn't really change the meaning of the string, and therefore\n   * all such strings that compress to the same thing should share the same\n   * translation.\n   * @param {null|string=} source the source string to make a key out of\n   */\n  _makeKey: function _makeKey(source) {\n    if (!source) return undefined;\n    var key = source.replace(/\\s+/gm, ' ');\n    return this.type === \"xml\" || this.type === \"html\" ? this._unescapeXml(key) : key;\n  },\n\n  /**\n   * @private\n   */\n  _getStringSingle: function _getStringSingle(source, key, escapeMode) {\n    if (!source && !key) return new IString(\"\");\n    var trans;\n\n    if (this.locale.isPseudo()) {\n      var str = source ? source : this.map[key];\n      trans = this._pseudo(str || key);\n    } else {\n      var keyName = key || this._makeKey(source);\n\n      if (typeof this.map[keyName] !== 'undefined') {\n        trans = this.map[keyName];\n      } else if (this.missing === \"pseudo\") {\n        trans = this._pseudo(source || key);\n      } else if (this.missing === \"empty\") {\n        trans = \"\";\n      } else {\n        trans = source;\n      }\n    }\n\n    if (escapeMode && escapeMode !== \"none\") {\n      if (escapeMode == \"default\") {\n        escapeMode = this.type;\n      }\n\n      if (escapeMode === \"xml\" || escapeMode === \"html\") {\n        trans = this._escapeXml(trans);\n      } else if (escapeMode == \"js\" || escapeMode === \"attribute\") {\n        trans = trans.replace(/'/g, \"\\\\\\'\").replace(/\"/g, \"\\\\\\\"\");\n      }\n    }\n\n    if (trans === undefined) {\n      return undefined;\n    } else {\n      var ret = new IString(trans);\n      ret.setLocale(this.locale.getSpec(), true, this.loadParams); // no callback\n\n      return ret;\n    }\n  },\n\n  /**\n   * Return a localized string, array, or object. This method can localize individual\n   * strings or arrays of strings.<p>\n   * \n   * If the source parameter is a string, the translation of that string is looked\n   * up and returned. If the source parameter is an array of strings, then the translation \n   * of each of the elements of that array is looked up, and an array of translated strings\n   * is returned. <p>\n   * \n   * If any string is not found in the loaded set of\n   * resources, the original source string is returned. If the key is not given,\n   * then the source string itself is used as the key. In the case where the \n   * source string is used as the key, the whitespace is compressed down to 1 space\n   * each, and the whitespace at the beginning and end of the string is trimmed.<p>\n   * \n   * The escape mode specifies what type of output you are escaping the returned\n   * string for. Modes are similar to the types: \n   * \n   * <ul>\n   * <li>\"html\" -- prevents HTML injection by escaping the characters &lt &gt; and &amp;\n   * <li>\"xml\" -- currently same as \"html\" mode\n   * <li>\"js\" -- prevents breaking Javascript syntax by backslash escaping all quote and \n   * double-quote characters\n   * <li>\"attribute\" -- meant for HTML attribute values. Currently this is the same as\n   * \"js\" escape mode.\n   * <li>\"default\" -- use the type parameter from the constructor as the escape mode as well\n   * <li>\"none\" or undefined -- no escaping at all.\n   * </ul>\n   * \n   * The type parameter of the constructor specifies what type of strings this bundle\n   * is operating upon. This allows pseudo-translation and automatic key generation\n   * to happen properly by telling this class how to parse the string. The escape mode \n   * for this method is different in that it specifies how this string will be used in \n   * the calling code and therefore how to escape it properly.<p> \n   * \n   * For example, a section of Javascript code may be constructing an HTML snippet in a \n   * string to add to the web page. In this case, the type parameter in the constructor should\n   * be \"html\" so that the source string can be parsed properly, but the escape mode should\n   * be \"js\" so that the output string can be used in Javascript without causing syntax\n   * errors.\n   * \n   * @param {?string|Array.<string>=} source the source string or strings to translate\n   * @param {?string|Array.<string>=} key optional name of the key, if any\n   * @param {?string=} escapeMode escape mode, if any\n   * @return {IString|Array.<IString>|undefined} the translation of the given source/key or undefined \n   * if the translation is not found and the source is undefined \n   */\n  getString: function getString(source, key, escapeMode) {\n    if (!source && !key) return new IString(\"\"); //if (typeof(source) === \"object\") {\n    // TODO localize objects\n    //} else\n\n    if (ilib.isArray(source)) {\n      return source.map(ilib.bind(this, function (str) {\n        return typeof str === \"string\" ? this._getStringSingle(str, key, escapeMode) : str;\n      }));\n    } else {\n      return this._getStringSingle(source, key, escapeMode);\n    }\n  },\n\n  /**\n   * Return a localized string as an intrinsic Javascript String object. This does the same thing as\n   * the getString() method, but it returns a regular Javascript string instead of\n   * and IString instance. This means it cannot be formatted with the format()\n   * method without being wrapped in an IString instance first.\n   * \n   * @param {?string=} source the source string to translate\n   * @param {?string=} key optional name of the key, if any\n   * @param {?string=} escapeMode escape mode, if any\n   * @return {string|undefined} the translation of the given source/key or undefined \n   * if the translation is not found and the source is undefined\n   */\n  getStringJS: function getStringJS(source, key, escapeMode) {\n    if (typeof source === 'undefined' && typeof key === 'undefined') {\n      return undefined;\n    } //if (typeof(source) === \"object\") {\n    // TODO localize objects\n    //} else \n\n\n    if (ilib.isArray(source)) {\n      return this.getString(source, key, escapeMode).map(function (str) {\n        return str && str instanceof IString ? str.toString() : str;\n      });\n    } else {\n      var s = this.getString(source, key, escapeMode);\n      return s ? s.toString() : undefined;\n    }\n  },\n\n  /**\n   * Return true if the current bundle contains a translation for the given key and\n   * source. The\n   * getString method will always return a string for any given key and source \n   * combination, so it cannot be used to tell if a translation exists. Either one\n   * or both of the source and key must be specified. If both are not specified,\n   * this method will return false.\n   * \n   * @param {?string=} source source string to look up\n   * @param {?string=} key key to look up\n   * @return {boolean} true if this bundle contains a translation for the key, and \n   * false otherwise\n   */\n  containsKey: function containsKey(source, key) {\n    if (typeof source === 'undefined' && typeof key === 'undefined') {\n      return false;\n    }\n\n    var keyName = key || this._makeKey(source);\n\n    return typeof this.map[keyName] !== 'undefined';\n  },\n\n  /**\n   * Return the merged resources as an entire object. When loading resources for a\n   * locale that are not just a set of translated strings, but instead an entire \n   * structured javascript object, you can gain access to that object via this call. This method\n   * will ensure that all the of the parts of the object are correct for the locale.<p>\n   * \n   * For pre-assembled data, it starts by loading <i>ilib.data[name]</i>, where \n   * <i>name</i> is the base name for this set of resources. Then, it successively \n   * merges objects in the base data using progressively more locale-specific data. \n   * It loads it in this order from <i>ilib.data</i>:\n   * \n   * <ol>\n   * <li> language\n   * <li> region\n   * <li> language_script\n   * <li> language_region\n   * <li> region_variant\n   * <li> language_script_region\n   * <li> language_region_variant\n   * <li> language_script_region_variant\n   * </ol>\n   * \n   * For dynamically loaded data, the code attempts to load the same sequence as\n   * above, but with slash path separators instead of underscores.<p>\n   *  \n   * Loading the resources this way allows the program to share resources between all\n   * locales that share a common language, region, or script. As a \n   * general rule-of-thumb, resources should be as generic as possible in order to\n   * cover as many locales as possible.\n   * \n   * @return {Object} returns the object that is the basis for this resources instance\n   */\n  getResObj: function getResObj() {\n    return this.map;\n  }\n};\nmodule.exports = ResBundle;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteApp\\node_modules\\@enact\\i18n\\ilib\\lib\\ResBundle.js"],"names":["ilib","require","Utils","JSUtils","Locale","LocaleInfo","IString","ResBundle","options","lookupLocale","spec","locale","baseName","type","loadParams","missing","sync","name","lengthen","map","data","cache","isPseudo","object","loadData","callback","bind","getSpec","replace","pseudomap","_loadPseudo","onLoad","li","pseudoLocale","undefined","getDefaultScript","defaultPseudo","prototype","isEmpty","getLocale","getName","getType","percentRE","RegExp","_pseudo","str","ret","i","length","charAt","substring","m","exec","add","Math","round","getScript","_escapeXml","_unescapeXml","_makeKey","source","key","_getStringSingle","escapeMode","trans","keyName","setLocale","getString","isArray","getStringJS","toString","s","containsKey","getResObj","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * ResBundle.js - Resource bundle definition\n * \n * Copyright © 2012-2016, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// !depends ilib.js Locale.js LocaleInfo.js IString.js Utils.js JSUtils.js\n// !data pseudomap\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IString = require(\"./IString.js\");\n/**\n * @class\n * Create a new resource bundle instance. The resource bundle loads strings\n * appropriate for a particular locale and provides them via the getString \n * method.<p>\n * \n * The options object may contain any (or none) of the following properties:\n * \n * <ul>\n * <li><i>locale</i> - The locale of the strings to load. If not specified, the default\n * locale is the the default for the web page or app in which the bundle is \n * being loaded.\n * \n * <li><i>name</i> - Base name of the resource bundle to load. If not specified the default\n * base name is \"resources\".\n * \n * <li><i>type</i> - Name the type of strings this bundle contains. Valid values are \n * \"xml\", \"html\", \"text\", \"c\", or \"raw\". The default is \"text\". If the type is \"xml\" or \"html\",\n * then XML/HTML entities and tags are not pseudo-translated. During a real translation, \n * HTML character entities are translated to their corresponding characters in a source\n * string before looking that string up in the translations. Also, the characters \"<\", \">\",\n * and \"&\" are converted to entities again in the output, but characters are left as they\n * are. If the type is \"xml\", \"html\", or \"text\" types, then the replacement parameter names\n * are not pseudo-translated as well so that the output can be used for formatting with \n * the IString class. If the type is \"c\" then all C language style printf replacement\n * parameters (eg. \"%s\" and \"%d\") are skipped automatically. If the type is raw, all characters \n * are pseudo-translated, including replacement parameters as well as XML/HTML tags and entities.\n * \n * <li><i>lengthen</i> - when pseudo-translating the string, tell whether or not to \n * automatically lengthen the string to simulate \"long\" languages such as German\n * or French. This is a boolean value. Default is false.\n * \n * <li><i>missing</i> - what to do when a resource is missing. The choices are:\n * <ul>\n *   <li><i>source</i> - return the source string unchanged\n *   <li><i>pseudo</i> - return the pseudo-translated source string, translated to the\n *   script of the locale if the mapping is available, or just the default Latin \n *   pseudo-translation if not\n *   <li><i>empty</i> - return the empty string \n * </ul>\n * The default behaviour is the same as before, which is to return the source string\n * unchanged.\n * \n * <li><i>onLoad</i> - a callback function to call when the resources are fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the constructor is done (even if the data is already preassembled), the \n * onLoad function is called with the current instance as a parameter, so this\n * callback can be used with preassembled or dynamic loading or a mix of the two. \n * \n * <li>sync - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while. \n *\n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * The locale option may be given as a locale spec string or as an \n * Locale object. If the locale option is not specified, then strings for\n * the default locale will be loaded.<p> \n * \n * The name option can be used to put groups of strings together in a\n * single bundle. The strings will then appear together in a JS object in\n * a JS file that can be included before the ilib.<p>\n * \n * A resource bundle with a particular name is actually a set of bundles\n * that are each specific to a language, a language plus a region, etc. \n * All bundles with the same base name should\n * contain the same set of source strings, but with different translations for \n * the given locale. The user of the bundle does not need to be aware of \n * the locale of the bundle, as long as it contains values for the strings \n * it needs.<p>\n * \n * Strings in bundles for a particular locale are inherited from parent bundles\n * that are more generic. In general, the hierarchy is as follows (from \n * least locale-specific to most locale-specific):\n * \n * <ol>\n * <li> language\n * <li> region\n * <li> language_script\n * <li> language_region\n * <li> region_variant\n * <li> language_script_region\n * <li> language_region_variant\n * <li> language_script_region_variant\n * </ol>\n * \n * That is, if the translation for a string does not exist in the current\n * locale, the more-generic parent locale is searched for the string. In the\n * worst case scenario, the string is not found in the base locale's strings. \n * In this case, the missing option guides this class on what to do. If\n * the missing option is \"source\", then the original source is returned as \n * the translation. If it is \"empty\", the empty string is returned. If it\n * is \"pseudo\", then the pseudo-translated string that is appropriate for\n * the default script of the locale is returned.<p> \n * \n * This allows developers to create code with new or changed strings in it and check in that\n * code without waiting for the translations to be done first. The translated\n * version of the app or web site will still function properly, but will show \n * a spurious untranslated string here and there until the translations are \n * done and also checked in.<p>   \n *  \n * The base is whatever language your developers use to code in. For\n * a German web site, strings in the source code may be written in German \n * for example. Often this base is English, as many web sites are coded in\n * English, but that is not required.<p>\n * \n * The strings can be extracted with the ilib localization tool (which will be\n * shipped at some future time.) Once the strings\n * have been translated, the set of translated files can be generated with the\n * same tool. The output from the tool can be used as input to the ResBundle\n * object. It is up to the web page or app to make sure the JS file that defines\n * the bundle is included before creating the ResBundle instance.<p>\n * \n * A special locale \"zxx-XX\" is used as the pseudo-translation locale because\n * zxx means \"no linguistic information\" in the ISO 639 standard, and the region \n * code XX is defined to be user-defined in the ISO 3166 standard. \n * Pseudo-translation is a locale where the translations are generated on\n * the fly based on the contents of the source string. Characters in the source \n * string are replaced with other characters and returned. \n * \n * Example. If the source string is:\n * \n * <pre>\n * \"This is a string\"\n * </pre>\n * \n * then the pseudo-translated version might look something like this: \n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ\"\n * </pre>\n * <p>\n * \n * Pseudo-translation can be used to test that your app or web site is translatable\n * before an actual translation has happened. These bugs can then be fixed \n * before the translation starts, avoiding an explosion of bugs later when\n * each language's tester registers the same bug complaining that the same \n * string is not translated. When pseudo-localizing with\n * the Latin script, this allows the strings to be readable in the UI in the \n * source language (if somewhat funky-looking), \n * so that a tester can easily verify that the string is properly externalized \n * and loaded from a resource bundle without the need to be able to read a\n * foreign language.<p> \n * \n * If one of a list of script tags is given in the pseudo-locale specifier, then the\n * pseudo-localization can map characters to very rough transliterations of\n * characters in the given script. For example, zxx-Hebr-XX maps strings to\n * Hebrew characters, which can be used to test your UI in a right-to-left\n * language to catch bidi bugs before a translation is done. Currently, the\n * list of target scripts includes Hebrew (Hebr), Chinese Simplified Han (Hans),\n * and Cyrillic (Cyrl) with more to be added later. If no script is explicitly\n * specified in the locale spec, or if the script is not supported,\n * then the default mapping maps Latin base characters to accented versions of\n * those Latin characters as in the example above.\n *  \n * When the \"lengthen\" property is set to true in the options, the \n * pseudotranslation code will add digits to the end of the string to simulate\n * the lengthening that occurs when translating to other languages. The above \n * example will come out like this:\n * \n * <pre>\n * \"Ţħïş ïş á şţřïñĝ76543210\"\n * </pre>\n * \n * The string is lengthened according to the length of the source string. If\n * the source string is less than 20 characters long, the string is lengthened \n * by 50%. If the source string is 20-40 \n * characters long, the string is lengthened by 33%. If te string is greater\n * than 40 characters long, the string is lengthened by 20%.<p>\n * \n * The pseudotranslation always ends a string with the digit \"0\". If you do\n * not see the digit \"0\" in the UI for your app, you know that truncation\n * has occurred, and the number you see at the end of the string tells you \n * how many characters were truncated.<p>\n * \n * \n * @constructor\n * @param {?Object} options Options controlling how the bundle is created\n */\n\n\nvar ResBundle = function ResBundle(options) {\n  var lookupLocale, spec;\n  this.locale = new Locale(); // use the default locale\n\n  this.baseName = \"strings\";\n  this.type = \"text\";\n  this.loadParams = {};\n  this.missing = \"source\";\n  this.sync = true;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.name) {\n      this.baseName = options.name;\n    }\n\n    if (options.type) {\n      this.type = options.type;\n    }\n\n    this.lengthen = options.lengthen || false;\n\n    if (typeof options.sync !== 'undefined') {\n      this.sync = options.sync == true;\n    }\n\n    if (typeof options.loadParams !== 'undefined') {\n      this.loadParams = options.loadParams;\n    }\n\n    if (typeof options.missing !== 'undefined') {\n      if (options.missing === \"pseudo\" || options.missing === \"empty\") {\n        this.missing = options.missing;\n      }\n    }\n  } else {\n    options = {\n      sync: true\n    };\n  }\n\n  this.map = {};\n\n  if (!ilib.data.cache.ResBundle) {\n    ilib.data.cache.ResBundle = {};\n  }\n\n  lookupLocale = this.locale.isPseudo() ? new Locale(\"en-US\") : this.locale;\n  var object = \"ResBundle-\" + this.baseName;\n  Utils.loadData({\n    object: object,\n    locale: lookupLocale,\n    name: this.baseName + \".json\",\n    sync: this.sync,\n    loadParams: this.loadParams,\n    callback: ilib.bind(this, function (map) {\n      if (!map) {\n        map = ilib.data[this.baseName] || {};\n        spec = lookupLocale.getSpec().replace(/-/g, '_');\n        ilib.data.cache[object][spec] = map;\n      }\n\n      this.map = map;\n\n      if (this.locale.isPseudo()) {\n        if (!ilib.data.cache.ResBundle.pseudomap) {\n          ilib.data.cache.ResBundle.pseudomap = {};\n        }\n\n        this._loadPseudo(this.locale, options.onLoad);\n      } else if (this.missing === \"pseudo\") {\n        if (!ilib.data.cache.ResBundle.pseudomap) {\n          ilib.data.cache.ResBundle.pseudomap = {};\n        }\n\n        new LocaleInfo(this.locale, {\n          sync: this.sync,\n          loadParams: this.loadParams,\n          onLoad: ilib.bind(this, function (li) {\n            var pseudoLocale = new Locale(\"zxx\", \"XX\", undefined, li.getDefaultScript());\n\n            this._loadPseudo(pseudoLocale, options.onLoad);\n          })\n        });\n      } else {\n        if (typeof options.onLoad === 'function') {\n          options.onLoad(this);\n        }\n      }\n    })\n  }); // console.log(\"Merged resources \" + this.locale.toString() + \" are: \" + JSON.stringify(this.map));\n  //if (!this.locale.isPseudo() && JSUtils.isEmpty(this.map)) {\n  //\tconsole.log(\"Resources for bundle \" + this.baseName + \" locale \" + this.locale.toString() + \" are not available.\");\n  //}\n};\n\nResBundle.defaultPseudo = ilib.data.pseudomap || {\n  \"a\": \"à\",\n  \"e\": \"ë\",\n  \"i\": \"í\",\n  \"o\": \"õ\",\n  \"u\": \"ü\",\n  \"y\": \"ÿ\",\n  \"A\": \"Ã\",\n  \"E\": \"Ë\",\n  \"I\": \"Ï\",\n  \"O\": \"Ø\",\n  \"U\": \"Ú\",\n  \"Y\": \"Ŷ\"\n};\nResBundle.prototype = {\n  /**\n   * @protected\n   */\n  _loadPseudo: function _loadPseudo(pseudoLocale, onLoad) {\n    Utils.loadData({\n      object: \"ResBundle\",\n      locale: pseudoLocale,\n      name: \"pseudomap.json\",\n      sync: this.sync,\n      loadParams: this.loadParams,\n      callback: ilib.bind(this, function (map) {\n        if (!map || JSUtils.isEmpty(map)) {\n          map = ResBundle.defaultPseudo;\n          var spec = pseudoLocale.getSpec().replace(/-/g, '_');\n          ilib.data.cache.ResBundle.pseudomap[spec] = map;\n        }\n\n        this.pseudomap = map;\n\n        if (typeof onLoad === 'function') {\n          onLoad(this);\n        }\n      })\n    });\n  },\n\n  /**\n   * Return the locale of this resource bundle.\n   * @return {Locale} the locale of this resource bundle object \n   */\n  getLocale: function getLocale() {\n    return this.locale;\n  },\n\n  /**\n   * Return the name of this resource bundle. This corresponds to the name option\n   * given to the constructor.\n   * @return {string} name of the the current instance\n   */\n  getName: function getName() {\n    return this.baseName;\n  },\n\n  /**\n   * Return the type of this resource bundle. This corresponds to the type option\n   * given to the constructor.\n   * @return {string} type of the the current instance\n   */\n  getType: function getType() {\n    return this.type;\n  },\n  percentRE: new RegExp(\"%(\\\\d+\\\\$)?([\\\\-#\\\\+ 0,\\\\(])?(\\\\d+)?(\\\\.\\\\d+)?[bBhHsScCdoxXeEfgGaAtT%n]\"),\n\n  /**\n   * @private\n   * Pseudo-translate a string\n   */\n  _pseudo: function _pseudo(str) {\n    if (!str) {\n      return undefined;\n    }\n\n    var ret = \"\",\n        i;\n\n    for (i = 0; i < str.length; i++) {\n      if (this.type !== \"raw\") {\n        if (this.type === \"html\" || this.type === \"xml\") {\n          if (str.charAt(i) === '<') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== '>') {\n              ret += str.charAt(i++);\n            }\n          } else if (str.charAt(i) === '&') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== ';' && str.charAt(i) !== ' ') {\n              ret += str.charAt(i++);\n            }\n          } else if (str.charAt(i) === '\\\\' && str.charAt(i + 1) === \"u\") {\n            ret += str.substring(i, i + 6);\n            i += 6;\n          }\n        } else if (this.type === \"c\") {\n          if (str.charAt(i) === \"%\") {\n            var m = this.percentRE.exec(str.substring(i));\n\n            if (m && m.length) {\n              // console.log(\"Match found: \" + JSON.stringify(m[0].replace(\"%\", \"%%\")));\n              ret += m[0];\n              i += m[0].length;\n            }\n          }\n        }\n\n        if (i < str.length) {\n          if (str.charAt(i) === '{') {\n            ret += str.charAt(i++);\n\n            while (i < str.length && str.charAt(i) !== '}') {\n              ret += str.charAt(i++);\n            }\n\n            if (i < str.length) {\n              ret += str.charAt(i);\n            }\n          } else {\n            ret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n          }\n        }\n      } else {\n        ret += this.pseudomap[str.charAt(i)] || str.charAt(i);\n      }\n    }\n\n    if (this.lengthen) {\n      var add;\n\n      if (ret.length <= 20) {\n        add = Math.round(ret.length / 2);\n      } else if (ret.length > 20 && ret.length <= 40) {\n        add = Math.round(ret.length / 3);\n      } else {\n        add = Math.round(ret.length / 5);\n      }\n\n      for (i = add - 1; i >= 0; i--) {\n        ret += i % 10;\n      }\n    }\n\n    if (this.locale.getScript() === \"Hans\" || this.locale.getScript() === \"Hant\" || this.locale.getScript() === \"Hani\" || this.locale.getScript() === \"Hrkt\" || this.locale.getScript() === \"Jpan\" || this.locale.getScript() === \"Hira\" || this.locale.getScript() === \"Kana\") {\n      // simulate Asian languages by getting rid of all the spaces\n      ret = ret.replace(/ /g, \"\");\n    }\n\n    return ret;\n  },\n\n  /**\n   * @private\n   * Escape html characters in the output.\n   */\n  _escapeXml: function _escapeXml(str) {\n    str = str.replace(/&/g, '&amp;');\n    str = str.replace(/</g, '&lt;');\n    str = str.replace(/>/g, '&gt;');\n    return str;\n  },\n\n  /**\n   * @private\n   * @param {string} str the string to unescape\n   */\n  _unescapeXml: function _unescapeXml(str) {\n    str = str.replace(/&amp;/g, '&');\n    str = str.replace(/&lt;/g, '<');\n    str = str.replace(/&gt;/g, '>');\n    return str;\n  },\n\n  /**\n   * @private\n   * Create a key name out of a source string. All this does so far is \n   * compress sequences of white space into a single space on the assumption\n   * that this doesn't really change the meaning of the string, and therefore\n   * all such strings that compress to the same thing should share the same\n   * translation.\n   * @param {null|string=} source the source string to make a key out of\n   */\n  _makeKey: function _makeKey(source) {\n    if (!source) return undefined;\n    var key = source.replace(/\\s+/gm, ' ');\n    return this.type === \"xml\" || this.type === \"html\" ? this._unescapeXml(key) : key;\n  },\n\n  /**\n   * @private\n   */\n  _getStringSingle: function _getStringSingle(source, key, escapeMode) {\n    if (!source && !key) return new IString(\"\");\n    var trans;\n\n    if (this.locale.isPseudo()) {\n      var str = source ? source : this.map[key];\n      trans = this._pseudo(str || key);\n    } else {\n      var keyName = key || this._makeKey(source);\n\n      if (typeof this.map[keyName] !== 'undefined') {\n        trans = this.map[keyName];\n      } else if (this.missing === \"pseudo\") {\n        trans = this._pseudo(source || key);\n      } else if (this.missing === \"empty\") {\n        trans = \"\";\n      } else {\n        trans = source;\n      }\n    }\n\n    if (escapeMode && escapeMode !== \"none\") {\n      if (escapeMode == \"default\") {\n        escapeMode = this.type;\n      }\n\n      if (escapeMode === \"xml\" || escapeMode === \"html\") {\n        trans = this._escapeXml(trans);\n      } else if (escapeMode == \"js\" || escapeMode === \"attribute\") {\n        trans = trans.replace(/'/g, \"\\\\\\'\").replace(/\"/g, \"\\\\\\\"\");\n      }\n    }\n\n    if (trans === undefined) {\n      return undefined;\n    } else {\n      var ret = new IString(trans);\n      ret.setLocale(this.locale.getSpec(), true, this.loadParams); // no callback\n\n      return ret;\n    }\n  },\n\n  /**\n   * Return a localized string, array, or object. This method can localize individual\n   * strings or arrays of strings.<p>\n   * \n   * If the source parameter is a string, the translation of that string is looked\n   * up and returned. If the source parameter is an array of strings, then the translation \n   * of each of the elements of that array is looked up, and an array of translated strings\n   * is returned. <p>\n   * \n   * If any string is not found in the loaded set of\n   * resources, the original source string is returned. If the key is not given,\n   * then the source string itself is used as the key. In the case where the \n   * source string is used as the key, the whitespace is compressed down to 1 space\n   * each, and the whitespace at the beginning and end of the string is trimmed.<p>\n   * \n   * The escape mode specifies what type of output you are escaping the returned\n   * string for. Modes are similar to the types: \n   * \n   * <ul>\n   * <li>\"html\" -- prevents HTML injection by escaping the characters &lt &gt; and &amp;\n   * <li>\"xml\" -- currently same as \"html\" mode\n   * <li>\"js\" -- prevents breaking Javascript syntax by backslash escaping all quote and \n   * double-quote characters\n   * <li>\"attribute\" -- meant for HTML attribute values. Currently this is the same as\n   * \"js\" escape mode.\n   * <li>\"default\" -- use the type parameter from the constructor as the escape mode as well\n   * <li>\"none\" or undefined -- no escaping at all.\n   * </ul>\n   * \n   * The type parameter of the constructor specifies what type of strings this bundle\n   * is operating upon. This allows pseudo-translation and automatic key generation\n   * to happen properly by telling this class how to parse the string. The escape mode \n   * for this method is different in that it specifies how this string will be used in \n   * the calling code and therefore how to escape it properly.<p> \n   * \n   * For example, a section of Javascript code may be constructing an HTML snippet in a \n   * string to add to the web page. In this case, the type parameter in the constructor should\n   * be \"html\" so that the source string can be parsed properly, but the escape mode should\n   * be \"js\" so that the output string can be used in Javascript without causing syntax\n   * errors.\n   * \n   * @param {?string|Array.<string>=} source the source string or strings to translate\n   * @param {?string|Array.<string>=} key optional name of the key, if any\n   * @param {?string=} escapeMode escape mode, if any\n   * @return {IString|Array.<IString>|undefined} the translation of the given source/key or undefined \n   * if the translation is not found and the source is undefined \n   */\n  getString: function getString(source, key, escapeMode) {\n    if (!source && !key) return new IString(\"\"); //if (typeof(source) === \"object\") {\n    // TODO localize objects\n    //} else\n\n    if (ilib.isArray(source)) {\n      return source.map(ilib.bind(this, function (str) {\n        return typeof str === \"string\" ? this._getStringSingle(str, key, escapeMode) : str;\n      }));\n    } else {\n      return this._getStringSingle(source, key, escapeMode);\n    }\n  },\n\n  /**\n   * Return a localized string as an intrinsic Javascript String object. This does the same thing as\n   * the getString() method, but it returns a regular Javascript string instead of\n   * and IString instance. This means it cannot be formatted with the format()\n   * method without being wrapped in an IString instance first.\n   * \n   * @param {?string=} source the source string to translate\n   * @param {?string=} key optional name of the key, if any\n   * @param {?string=} escapeMode escape mode, if any\n   * @return {string|undefined} the translation of the given source/key or undefined \n   * if the translation is not found and the source is undefined\n   */\n  getStringJS: function getStringJS(source, key, escapeMode) {\n    if (typeof source === 'undefined' && typeof key === 'undefined') {\n      return undefined;\n    } //if (typeof(source) === \"object\") {\n    // TODO localize objects\n    //} else \n\n\n    if (ilib.isArray(source)) {\n      return this.getString(source, key, escapeMode).map(function (str) {\n        return str && str instanceof IString ? str.toString() : str;\n      });\n    } else {\n      var s = this.getString(source, key, escapeMode);\n      return s ? s.toString() : undefined;\n    }\n  },\n\n  /**\n   * Return true if the current bundle contains a translation for the given key and\n   * source. The\n   * getString method will always return a string for any given key and source \n   * combination, so it cannot be used to tell if a translation exists. Either one\n   * or both of the source and key must be specified. If both are not specified,\n   * this method will return false.\n   * \n   * @param {?string=} source source string to look up\n   * @param {?string=} key key to look up\n   * @return {boolean} true if this bundle contains a translation for the key, and \n   * false otherwise\n   */\n  containsKey: function containsKey(source, key) {\n    if (typeof source === 'undefined' && typeof key === 'undefined') {\n      return false;\n    }\n\n    var keyName = key || this._makeKey(source);\n\n    return typeof this.map[keyName] !== 'undefined';\n  },\n\n  /**\n   * Return the merged resources as an entire object. When loading resources for a\n   * locale that are not just a set of translated strings, but instead an entire \n   * structured javascript object, you can gain access to that object via this call. This method\n   * will ensure that all the of the parts of the object are correct for the locale.<p>\n   * \n   * For pre-assembled data, it starts by loading <i>ilib.data[name]</i>, where \n   * <i>name</i> is the base name for this set of resources. Then, it successively \n   * merges objects in the base data using progressively more locale-specific data. \n   * It loads it in this order from <i>ilib.data</i>:\n   * \n   * <ol>\n   * <li> language\n   * <li> region\n   * <li> language_script\n   * <li> language_region\n   * <li> region_variant\n   * <li> language_script_region\n   * <li> language_region_variant\n   * <li> language_script_region_variant\n   * </ol>\n   * \n   * For dynamically loaded data, the code attempts to load the same sequence as\n   * above, but with slash path separators instead of underscores.<p>\n   *  \n   * Loading the resources this way allows the program to share resources between all\n   * locales that share a common language, region, or script. As a \n   * general rule-of-thumb, resources should be as generic as possible in order to\n   * cover as many locales as possible.\n   * \n   * @return {Object} returns the object that is the basis for this resources instance\n   */\n  getResObj: function getResObj() {\n    return this.map;\n  }\n};\nmodule.exports = ResBundle;"]},"metadata":{},"sourceType":"module"}