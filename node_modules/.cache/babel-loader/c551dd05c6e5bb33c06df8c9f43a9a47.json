{"ast":null,"code":"\"use strict\";\n\nfunction _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScrollableBase = exports.Scrollable = exports.constants = exports[\"default\"] = void 0;\n\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _handle = require(\"@enact/core/handle\");\n\nvar _keymap = require(\"@enact/core/keymap\");\n\nvar _Registry = _interopRequireDefault(require(\"@enact/core/internal/Registry\"));\n\nvar _util = require(\"@enact/core/util\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _ForwardRef = _interopRequireDefault(require(\"../ForwardRef\"));\n\nvar _Resizable = require(\"../Resizable\");\n\nvar _resolution = _interopRequireDefault(require(\"../resolution\"));\n\nvar _Touchable = _interopRequireDefault(require(\"../Touchable\"));\n\nvar _ScrollAnimator = _interopRequireDefault(require(\"./ScrollAnimator\"));\n\nvar _Scrollbar = _interopRequireDefault(require(\"./Scrollbar\"));\n\nvar _ScrollableModule = _interopRequireDefault(require(\"./Scrollable.module.css\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj[\"default\"] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar constants = {\n  animationDuration: 1000,\n  epsilon: 1,\n  isPageDown: (0, _keymap.is)('pageDown'),\n  isPageUp: (0, _keymap.is)('pageUp'),\n  nop: function nop() {},\n  overscrollTypeNone: 0,\n  overscrollTypeHold: 1,\n  overscrollTypeOnce: 2,\n  overscrollTypeDone: 9,\n  paginationPageMultiplier: 0.8,\n  scrollStopWaiting: 200,\n  scrollWheelPageMultiplierForMaxPixel: 0.2 // The ratio of the maximum distance scrolled by wheel to the size of the viewport.\n\n},\n    animationDuration = constants.animationDuration,\n    epsilon = constants.epsilon,\n    isPageDown = constants.isPageDown,\n    isPageUp = constants.isPageUp,\n    nop = constants.nop,\n    overscrollTypeDone = constants.overscrollTypeDone,\n    overscrollTypeHold = constants.overscrollTypeHold,\n    overscrollTypeNone = constants.overscrollTypeNone,\n    overscrollTypeOnce = constants.overscrollTypeOnce,\n    paginationPageMultiplier = constants.paginationPageMultiplier,\n    scrollStopWaiting = constants.scrollStopWaiting,\n    scrollWheelPageMultiplierForMaxPixel = constants.scrollWheelPageMultiplierForMaxPixel;\nexports.constants = constants;\nvar TouchableDiv = (0, _ForwardRef[\"default\"])({\n  prop: 'ref'\n}, (0, _Touchable[\"default\"])('div'));\n/**\n * An unstyled component that passes scrollable behavior information as its render prop's arguments.\n *\n * @class ScrollableBase\n * @memberof ui/Scrollable\n * @ui\n * @private\n */\n\nvar ScrollableBase =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ScrollableBase, _Component);\n\n  function ScrollableBase(props) {\n    var _this;\n\n    _classCallCheck(this, ScrollableBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollableBase).call(this, props));\n    _this.pixelPerLine = 39;\n    _this.scrollWheelMultiplierForDeltaPixel = 1.5;\n    _this.deferScrollTo = true;\n    _this.isScrollAnimationTargetAccumulated = false;\n    _this.isUpdatedScrollThumb = false;\n    _this.lastInputType = null;\n    _this.overscrollEnabled = false;\n    _this.overscrollStatus = {\n      horizontal: {\n        before: {\n          type: overscrollTypeNone,\n          ratio: 0\n        },\n        after: {\n          type: overscrollTypeNone,\n          ratio: 0\n        }\n      },\n      vertical: {\n        before: {\n          type: overscrollTypeNone,\n          ratio: 0\n        },\n        after: {\n          type: overscrollTypeNone,\n          ratio: 0\n        } // bounds info\n\n      }\n    };\n    _this.bounds = {\n      clientWidth: 0,\n      clientHeight: 0,\n      scrollWidth: 0,\n      scrollHeight: 0,\n      maxTop: 0,\n      maxLeft: 0 // wheel/drag/flick info\n\n    };\n    _this.wheelDirection = 0;\n    _this.isDragging = false;\n    _this.scrolling = false;\n    _this.scrollLeft = 0;\n    _this.scrollTop = 0;\n    _this.scrollToInfo = null;\n    _this.childRefCurrent = null;\n    _this.animator = new _ScrollAnimator[\"default\"]();\n\n    _this.getRtlX = function (x) {\n      return _this.props.rtl ? -x : x;\n    };\n\n    _this.onMouseDown = function (ev) {\n      _this.stop();\n\n      (0, _handle.forward)('onMouseDown', ev, _this.props);\n    };\n\n    _this.onDragStart = function (ev) {\n      if (ev.type === 'dragstart') return;\n\n      _this.stop();\n\n      _this.isDragging = true;\n      _this.dragStartX = _this.scrollLeft + _this.getRtlX(ev.x);\n      _this.dragStartY = _this.scrollTop + ev.y;\n    };\n\n    _this.onDrag = function (ev) {\n      if (ev.type === 'drag') return;\n      var direction = _this.props.direction;\n      _this.lastInputType = 'drag';\n\n      _this.start({\n        targetX: direction === 'vertical' ? 0 : _this.dragStartX - _this.getRtlX(ev.x),\n        // 'horizontal' or 'both'\n        targetY: direction === 'horizontal' ? 0 : _this.dragStartY - ev.y,\n        // 'vertical' or 'both'\n        animate: false,\n        overscrollEffect: _this.props.overscrollEffectOn.drag\n      });\n    };\n\n    _this.onDragEnd = function (ev) {\n      if (ev.type === 'dragend') return;\n      _this.isDragging = false;\n\n      if (_this.flickTarget) {\n        var _this$flickTarget = _this.flickTarget,\n            targetX = _this$flickTarget.targetX,\n            targetY = _this$flickTarget.targetY,\n            duration = _this$flickTarget.duration;\n        _this.lastInputType = 'drag';\n        _this.isScrollAnimationTargetAccumulated = false;\n\n        _this.start({\n          targetX: targetX,\n          targetY: targetY,\n          duration: duration,\n          overscrollEffect: _this.props.overscrollEffectOn.drag\n        });\n      } else {\n        _this.stop();\n      }\n\n      if (_this.overscrollEnabled) {\n        // not check this.props.overscrollEffectOn.drag for safety\n        _this.clearAllOverscrollEffects();\n      }\n\n      _this.flickTarget = null;\n    };\n\n    _this.onFlick = function (ev) {\n      var direction = _this.props.direction;\n      _this.flickTarget = _this.animator.simulate(_this.scrollLeft, _this.scrollTop, direction !== 'vertical' ? _this.getRtlX(-ev.velocityX) : 0, direction !== 'horizontal' ? -ev.velocityY : 0);\n\n      if (_this.props.onFlick) {\n        (0, _handle.forward)('onFlick', ev, _this.props);\n      }\n    };\n\n    _this.onWheel = function (ev) {\n      ev.preventDefault();\n\n      if (!_this.isDragging) {\n        var _assertThisInitialize = _assertThisInitialized(_this),\n            verticalScrollbarRef = _assertThisInitialize.verticalScrollbarRef,\n            horizontalScrollbarRef = _assertThisInitialize.horizontalScrollbarRef,\n            bounds = _this.getScrollBounds(),\n            canScrollHorizontally = _this.canScrollHorizontally(bounds),\n            canScrollVertically = _this.canScrollVertically(bounds),\n            eventDeltaMode = ev.deltaMode,\n            eventDelta = -ev.wheelDeltaY || ev.deltaY;\n\n        var delta = 0,\n            direction;\n        _this.lastInputType = 'wheel';\n\n        if (canScrollVertically) {\n          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);\n        } else if (canScrollHorizontally) {\n          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);\n        }\n\n        direction = Math.sign(delta);\n\n        if (direction !== _this.wheelDirection) {\n          _this.isScrollAnimationTargetAccumulated = false;\n          _this.wheelDirection = direction;\n        }\n\n        (0, _handle.forward)('onWheel', {\n          delta: delta,\n          horizontalScrollbarRef: horizontalScrollbarRef,\n          verticalScrollbarRef: verticalScrollbarRef\n        }, _this.props);\n\n        if (delta !== 0) {\n          _this.scrollToAccumulatedTarget(delta, canScrollVertically, _this.props.overscrollEffectOn.wheel);\n        }\n      }\n    };\n\n    _this.scrollByPage = function (keyCode) {\n      // Only scroll by page when the vertical scrollbar is visible. Otherwise, treat the\n      // scroller as a plain container\n      if (!_this.state.isVerticalScrollbarVisible) return;\n\n      var bounds = _this.getScrollBounds(),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          pageDistance = (isPageUp(keyCode) ? -1 : 1) * (canScrollVertically ? bounds.clientHeight : bounds.clientWidth) * paginationPageMultiplier;\n\n      _this.lastInputType = 'pageKey';\n\n      _this.scrollToAccumulatedTarget(pageDistance, canScrollVertically, _this.props.overscrollEffectOn.pageKey);\n    };\n\n    _this.onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        (0, _handle.forward)('onKeyDown', ev, _this.props);\n      } else if (isPageUp(ev.keyCode) || isPageDown(ev.keyCode)) {\n        _this.scrollByPage(ev.keyCode);\n      }\n    };\n\n    _this.scrollToAccumulatedTarget = function (delta, vertical, overscrollEffect) {\n      if (!_this.isScrollAnimationTargetAccumulated) {\n        _this.accumulatedTargetX = _this.scrollLeft;\n        _this.accumulatedTargetY = _this.scrollTop;\n        _this.isScrollAnimationTargetAccumulated = true;\n      }\n\n      if (vertical) {\n        _this.accumulatedTargetY += delta;\n      } else {\n        _this.accumulatedTargetX += delta;\n      }\n\n      _this.start({\n        targetX: _this.accumulatedTargetX,\n        targetY: _this.accumulatedTargetY,\n        overscrollEffect: overscrollEffect\n      });\n    };\n\n    _this.getEdgeFromPosition = function (position, maxPosition) {\n      if (position <= 0) {\n        return 'before';\n      } else if (position >= maxPosition) {\n        return 'after';\n      } else {\n        return null;\n      }\n    };\n\n    _this.setOverscrollStatus = function (orientation, edge, type, ratio) {\n      var status = _this.overscrollStatus[orientation][edge];\n      status.type = type;\n      status.ratio = ratio;\n    };\n\n    _this.getOverscrollStatus = function (orientation, edge) {\n      return _this.overscrollStatus[orientation][edge];\n    };\n\n    _this.calculateOverscrollRatio = function (orientation, position) {\n      var bounds = _this.getScrollBounds(),\n          isVertical = orientation === 'vertical',\n          baseSize = isVertical ? bounds.clientHeight : bounds.clientWidth,\n          maxPos = bounds[isVertical ? 'maxTop' : 'maxLeft'];\n\n      var overDistance = 0;\n\n      if (position < 0) {\n        overDistance = -position;\n      } else if (position > maxPos) {\n        overDistance = position - maxPos;\n      } else {\n        return 0;\n      }\n\n      return Math.min(1, 2 * overDistance / baseSize);\n    };\n\n    _this.applyOverscrollEffect = function (orientation, edge, type, ratio) {\n      _this.props.applyOverscrollEffect(orientation, edge, type, ratio);\n\n      _this.setOverscrollStatus(orientation, edge, type === overscrollTypeOnce ? overscrollTypeDone : type, ratio);\n    };\n\n    _this.checkAndApplyOverscrollEffect = function (orientation, edge, type) {\n      var ratio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n      var isVertical = orientation === 'vertical',\n          curPos = isVertical ? _this.scrollTop : _this.scrollLeft,\n          maxPos = _this.getScrollBounds()[isVertical ? 'maxTop' : 'maxLeft'];\n\n      if (edge === 'before' && curPos <= 0 || edge === 'after' && curPos >= maxPos) {\n        // Already on the edge\n        _this.applyOverscrollEffect(orientation, edge, type, ratio);\n      } else {\n        _this.setOverscrollStatus(orientation, edge, type, ratio);\n      }\n    };\n\n    _this.clearOverscrollEffect = function (orientation, edge) {\n      if (_this.getOverscrollStatus(orientation, edge).type !== overscrollTypeNone) {\n        if (_this.props.clearOverscrollEffect) {\n          _this.props.clearOverscrollEffect(orientation, edge);\n        } else {\n          _this.applyOverscrollEffect(orientation, edge, overscrollTypeNone, 0);\n        }\n      }\n    };\n\n    _this.clearAllOverscrollEffects = function () {\n      ['horizontal', 'vertical'].forEach(function (orientation) {\n        ['before', 'after'].forEach(function (edge) {\n          _this.clearOverscrollEffect(orientation, edge);\n        });\n      });\n    };\n\n    _this.applyOverscrollEffectOnDrag = function (orientation, edge, targetPosition, type) {\n      if (edge) {\n        var oppositeEdge = edge === 'before' ? 'after' : 'before',\n            ratio = _this.calculateOverscrollRatio(orientation, targetPosition);\n\n        _this.applyOverscrollEffect(orientation, edge, type, ratio);\n\n        _this.clearOverscrollEffect(orientation, oppositeEdge);\n      } else {\n        _this.clearOverscrollEffect(orientation, 'before');\n\n        _this.clearOverscrollEffect(orientation, 'after');\n      }\n    };\n\n    _this.checkAndApplyOverscrollEffectOnScroll = function (orientation) {\n      ['before', 'after'].forEach(function (edge) {\n        var _this$getOverscrollSt = _this.getOverscrollStatus(orientation, edge),\n            ratio = _this$getOverscrollSt.ratio,\n            type = _this$getOverscrollSt.type;\n\n        if (type === overscrollTypeOnce) {\n          _this.checkAndApplyOverscrollEffect(orientation, edge, type, ratio);\n        }\n      });\n    };\n\n    _this.checkAndApplyOverscrollEffectOnStart = function (orientation, edge, targetPosition) {\n      if (_this.isDragging) {\n        _this.applyOverscrollEffectOnDrag(orientation, edge, targetPosition, overscrollTypeHold);\n      } else if (edge) {\n        _this.checkAndApplyOverscrollEffect(orientation, edge, overscrollTypeOnce);\n      }\n    };\n\n    _this.getReachedEdgeInfo = function () {\n      var bounds = _this.getScrollBounds(),\n          reachedEdgeInfo = {\n        bottom: false,\n        left: false,\n        right: false,\n        top: false\n      };\n\n      if (_this.canScrollHorizontally(bounds)) {\n        var rtl = _this.props.rtl,\n            edge = _this.getEdgeFromPosition(_this.scrollLeft, bounds.maxLeft);\n\n        if (edge) {\n          // if edge is null, no need to check which edge is reached.\n          if (edge === 'before' && !rtl || edge === 'after' && rtl) {\n            reachedEdgeInfo.left = true;\n          } else {\n            reachedEdgeInfo.right = true;\n          }\n        }\n      }\n\n      if (_this.canScrollVertically(bounds)) {\n        var _edge = _this.getEdgeFromPosition(_this.scrollTop, bounds.maxTop);\n\n        if (_edge === 'before') {\n          reachedEdgeInfo.top = true;\n        } else if (_edge === 'after') {\n          reachedEdgeInfo.bottom = true;\n        }\n      }\n\n      return reachedEdgeInfo;\n    };\n\n    _this.doScrollStop = function () {\n      _this.scrolling = false;\n\n      _this.forwardScrollEvent('onScrollStop', _this.getReachedEdgeInfo());\n    };\n\n    _this.scrollStopJob = new _util.Job(_this.doScrollStop, scrollStopWaiting);\n\n    _this.scrollAnimation = function (animationInfo) {\n      return function (curTime) {\n        var sourceX = animationInfo.sourceX,\n            sourceY = animationInfo.sourceY,\n            targetX = animationInfo.targetX,\n            targetY = animationInfo.targetY,\n            duration = animationInfo.duration,\n            bounds = _this.getScrollBounds();\n\n        if (curTime < duration) {\n          var toBeContinued = false,\n              curTargetX = sourceX,\n              curTargetY = sourceY;\n\n          if (_this.canScrollHorizontally(bounds)) {\n            curTargetX = _this.animator.timingFunction(sourceX, targetX, duration, curTime);\n\n            if (Math.abs(curTargetX - targetX) < epsilon) {\n              curTargetX = targetX;\n            } else {\n              toBeContinued = true;\n            }\n          }\n\n          if (_this.canScrollVertically(bounds)) {\n            curTargetY = _this.animator.timingFunction(sourceY, targetY, duration, curTime);\n\n            if (Math.abs(curTargetY - targetY) < epsilon) {\n              curTargetY = targetY;\n            } else {\n              toBeContinued = true;\n            }\n          }\n\n          _this.scroll(curTargetX, curTargetY);\n\n          if (!toBeContinued) {\n            _this.stop();\n          }\n        } else {\n          _this.scroll(targetX, targetY);\n\n          _this.stop();\n        }\n      };\n    };\n\n    _this.scroll = function (left, top) {\n      if (left !== _this.scrollLeft) {\n        _this.setScrollLeft(left);\n      }\n\n      if (top !== _this.scrollTop) {\n        _this.setScrollTop(top);\n      }\n\n      _this.childRefCurrent.setScrollPosition(_this.scrollLeft, _this.scrollTop);\n\n      _this.forwardScrollEvent('onScroll');\n    };\n\n    _this.getPositionForScrollTo = function (opt) {\n      var bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds);\n\n      var itemPos,\n          left = null,\n          top = null;\n\n      if (opt instanceof Object) {\n        if (opt.position instanceof Object) {\n          if (canScrollHorizontally) {\n            // We need '!=' to check if opt.potision.x is null or undefined\n            left = opt.position.x != null ? opt.position.x : _this.scrollLeft;\n          } else {\n            left = 0;\n          }\n\n          if (canScrollVertically) {\n            // We need '!=' to check if opt.potision.y is null or undefined\n            top = opt.position.y != null ? opt.position.y : _this.scrollTop;\n          } else {\n            top = 0;\n          }\n        } else if (typeof opt.align === 'string') {\n          if (canScrollHorizontally) {\n            if (opt.align.includes('left')) {\n              left = 0;\n            } else if (opt.align.includes('right')) {\n              left = bounds.maxLeft;\n            }\n          }\n\n          if (canScrollVertically) {\n            if (opt.align.includes('top')) {\n              top = 0;\n            } else if (opt.align.includes('bottom')) {\n              top = bounds.maxTop;\n            }\n          }\n        } else {\n          if (typeof opt.index === 'number' && typeof _this.childRefCurrent.getItemPosition === 'function') {\n            itemPos = _this.childRefCurrent.getItemPosition(opt.index, opt.stickTo);\n          } else if (opt.node instanceof Object) {\n            if (opt.node.nodeType === 1 && typeof _this.childRefCurrent.getNodePosition === 'function') {\n              itemPos = _this.childRefCurrent.getNodePosition(opt.node);\n            }\n          }\n\n          if (itemPos) {\n            if (canScrollHorizontally) {\n              left = itemPos.left;\n            }\n\n            if (canScrollVertically) {\n              top = itemPos.top;\n            }\n          }\n        }\n      }\n\n      return {\n        left: left,\n        top: top\n      };\n    };\n\n    _this.scrollTo = function (opt) {\n      if (!_this.deferScrollTo) {\n        var _this$getPositionForS = _this.getPositionForScrollTo(opt),\n            left = _this$getPositionForS.left,\n            top = _this$getPositionForS.top;\n\n        if (_this.props.scrollTo) {\n          _this.props.scrollTo(opt);\n        }\n\n        _this.scrollToInfo = null;\n\n        _this.start({\n          targetX: left !== null ? left : _this.scrollLeft,\n          targetY: top !== null ? top : _this.scrollTop,\n          animate: opt.animate\n        });\n      } else {\n        _this.scrollToInfo = opt;\n      }\n    };\n\n    _this.canScrollHorizontally = function (bounds) {\n      var direction = _this.props.direction;\n      return (direction === 'horizontal' || direction === 'both') && bounds.scrollWidth > bounds.clientWidth && !isNaN(bounds.scrollWidth);\n    };\n\n    _this.canScrollVertically = function (bounds) {\n      var direction = _this.props.direction;\n      return (direction === 'vertical' || direction === 'both') && bounds.scrollHeight > bounds.clientHeight && !isNaN(bounds.scrollHeight);\n    };\n\n    _this.startHidingThumb = function () {\n      if (_this.state.isHorizontalScrollbarVisible && _this.horizontalScrollbarRef.current) {\n        _this.horizontalScrollbarRef.current.startHidingThumb();\n      }\n\n      if (_this.state.isVerticalScrollbarVisible && _this.verticalScrollbarRef.current) {\n        _this.verticalScrollbarRef.current.startHidingThumb();\n      }\n    };\n\n    _this.updateScrollbars = function () {\n      var _this$props = _this.props,\n          horizontalScrollbar = _this$props.horizontalScrollbar,\n          verticalScrollbar = _this$props.verticalScrollbar,\n          _this$state = _this.state,\n          isHorizontalScrollbarVisible = _this$state.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state.isVerticalScrollbarVisible,\n          bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',\n          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible'; // determine if we should hide or show any scrollbars\n\n\n      var isVisibilityChanged = isHorizontalScrollbarVisible !== curHorizontalScrollbarVisible || isVerticalScrollbarVisible !== curVerticalScrollbarVisible;\n\n      if (isVisibilityChanged) {\n        // one or both scrollbars have changed visibility\n        _this.setState({\n          isHorizontalScrollbarVisible: curHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible: curVerticalScrollbarVisible\n        });\n      } else {\n        _this.deferScrollTo = false;\n        _this.isUpdatedScrollThumb = _this.updateScrollThumbSize();\n      }\n    };\n\n    _this.updateScrollThumbSize = function () {\n      var _this$props2 = _this.props,\n          horizontalScrollbar = _this$props2.horizontalScrollbar,\n          verticalScrollbar = _this$props2.verticalScrollbar,\n          bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',\n          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible';\n\n      if (curHorizontalScrollbarVisible || curVerticalScrollbarVisible) {\n        // no visibility change but need to notify whichever scrollbars are visible of the\n        // updated bounds and scroll position\n        var updatedBounds = _objectSpread({}, bounds, {\n          scrollLeft: _this.scrollLeft,\n          scrollTop: _this.scrollTop\n        });\n\n        if (curHorizontalScrollbarVisible && _this.horizontalScrollbarRef) {\n          _this.horizontalScrollbarRef.current.update(updatedBounds);\n        }\n\n        if (curVerticalScrollbarVisible && _this.verticalScrollbarRef) {\n          _this.verticalScrollbarRef.current.update(updatedBounds);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.initChildRef = function (ref) {\n      if (ref) {\n        _this.childRefCurrent = ref;\n      }\n    };\n\n    _this.handleScroll = function () {\n      var childRefCurrent = _this.childRefCurrent; // Prevent scroll by focus.\n      // VirtualList and VirtualGridList DO NOT receive `onscroll` event.\n      // Only Scroller could get `onscroll` event.\n\n      if (!_this.animator.isAnimating() && childRefCurrent && childRefCurrent.containerRef.current && childRefCurrent.getRtlPositionX) {\n        // For Scroller\n        childRefCurrent.containerRef.current.scrollTop = _this.scrollTop;\n        childRefCurrent.containerRef.current.scrollLeft = childRefCurrent.getRtlPositionX(_this.scrollLeft);\n      }\n    };\n\n    _this.state = {\n      remeasure: false,\n      isHorizontalScrollbarVisible: props.horizontalScrollbar === 'visible',\n      isVerticalScrollbarVisible: props.verticalScrollbar === 'visible'\n    };\n    _this.containerRef = _react[\"default\"].createRef();\n    _this.horizontalScrollbarRef = _react[\"default\"].createRef();\n    _this.verticalScrollbarRef = _react[\"default\"].createRef();\n    _this.horizontalScrollbarProps = {\n      ref: _this.horizontalScrollbarRef,\n      vertical: false,\n      clientSize: props.clientSize\n    };\n    _this.verticalScrollbarProps = {\n      ref: _this.verticalScrollbarRef,\n      vertical: true,\n      clientSize: props.clientSize\n    };\n    _this.overscrollEnabled = !!props.applyOverscrollEffect; // Enable the early bail out of repeated scrolling to the same position\n\n    _this.animationInfo = null;\n    _this.resizeRegistry = _Registry[\"default\"].create(_this.handleResize.bind(_assertThisInitialized(_this)));\n    props.cbScrollTo(_this.scrollTo);\n    return _this;\n  }\n\n  _createClass(ScrollableBase, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.resizeRegistry.parent = this.context;\n      this.addEventListeners();\n      this.updateScrollbars();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$state2 = this.state,\n          isHorizontalScrollbarVisible = _this$state2.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state2.isVerticalScrollbarVisible,\n          hasDataSizeChanged = this.childRefCurrent.hasDataSizeChanged; // Need to sync calculated client size if it is different from the real size\n\n      if (this.childRefCurrent.syncClientSize) {\n        // If we actually synced, we need to reset scroll position.\n        if (this.childRefCurrent.syncClientSize()) {\n          this.setScrollLeft(0);\n          this.setScrollTop(0);\n        }\n      }\n\n      this.clampScrollPosition();\n      this.addEventListeners();\n\n      if (hasDataSizeChanged === false && (isHorizontalScrollbarVisible && !prevState.isHorizontalScrollbarVisible || isVerticalScrollbarVisible && !prevState.isVerticalScrollbarVisible)) {\n        this.deferScrollTo = false;\n        this.isUpdatedScrollThumb = this.updateScrollThumbSize();\n      } else {\n        this.updateScrollbars();\n      }\n\n      if (this.scrollToInfo !== null) {\n        if (!this.deferScrollTo) {\n          this.scrollTo(this.scrollToInfo);\n        }\n      } // publish container resize changes\n\n\n      var horizontal = isHorizontalScrollbarVisible !== prevState.isHorizontalScrollbarVisible;\n      var vertical = isVerticalScrollbarVisible !== prevState.isVerticalScrollbarVisible;\n\n      if (horizontal || vertical) {\n        this.resizeRegistry.notify({});\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.resizeRegistry.parent = null; // Before call cancelAnimationFrame, you must send scrollStop Event.\n\n      if (this.scrolling) {\n        this.forwardScrollEvent('onScrollStop', this.getReachedEdgeInfo());\n      }\n\n      this.scrollStopJob.stop();\n\n      if (this.animator.isAnimating()) {\n        this.animator.stop();\n      }\n\n      this.removeEventListeners();\n    }\n  }, {\n    key: \"handleResize\",\n    value: function handleResize(ev) {\n      if (ev.action === 'invalidateBounds') {\n        this.enqueueForceUpdate();\n      }\n    } // TODO: consider replacing forceUpdate() by storing bounds in state rather than a non-\n    // state member.\n\n  }, {\n    key: \"enqueueForceUpdate\",\n    value: function enqueueForceUpdate() {\n      this.childRefCurrent.calculateMetrics();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"clampScrollPosition\",\n    value: function clampScrollPosition() {\n      var bounds = this.getScrollBounds();\n\n      if (this.scrollTop > bounds.maxTop) {\n        this.scrollTop = bounds.maxTop;\n      }\n\n      if (this.scrollLeft > bounds.maxLeft) {\n        this.scrollLeft = bounds.maxLeft;\n      }\n    } // constants\n\n  }, {\n    key: \"calculateDistanceByWheel\",\n    value: function calculateDistanceByWheel(deltaMode, delta, maxPixel) {\n      if (deltaMode === 0) {\n        delta = (0, _clamp[\"default\"])(-maxPixel, maxPixel, _resolution[\"default\"].scale(delta * this.scrollWheelMultiplierForDeltaPixel));\n      } else if (deltaMode === 1) {\n        // line; firefox\n        delta = (0, _clamp[\"default\"])(-maxPixel, maxPixel, _resolution[\"default\"].scale(delta * this.pixelPerLine * this.scrollWheelMultiplierForDeltaPixel));\n      } else if (deltaMode === 2) {\n        // page\n        delta = delta < 0 ? -maxPixel : maxPixel;\n      }\n\n      return delta;\n    }\n  }, {\n    key: \"forwardScrollEvent\",\n    // call scroll callbacks\n    value: function forwardScrollEvent(type, reachedEdgeInfo) {\n      (0, _handle.forward)(type, {\n        scrollLeft: this.scrollLeft,\n        scrollTop: this.scrollTop,\n        moreInfo: this.getMoreInfo(),\n        reachedEdgeInfo: reachedEdgeInfo\n      }, this.props);\n    } // update scroll position\n\n  }, {\n    key: \"setScrollLeft\",\n    value: function setScrollLeft(value) {\n      var bounds = this.getScrollBounds();\n      this.scrollLeft = (0, _clamp[\"default\"])(0, bounds.maxLeft, value);\n\n      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {\n        this.checkAndApplyOverscrollEffectOnScroll('horizontal');\n      }\n\n      if (this.state.isHorizontalScrollbarVisible) {\n        this.updateThumb(this.horizontalScrollbarRef, bounds);\n      }\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(value) {\n      var bounds = this.getScrollBounds();\n      this.scrollTop = (0, _clamp[\"default\"])(0, bounds.maxTop, value);\n\n      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {\n        this.checkAndApplyOverscrollEffectOnScroll('vertical');\n      }\n\n      if (this.state.isVerticalScrollbarVisible) {\n        this.updateThumb(this.verticalScrollbarRef, bounds);\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start(_ref) {\n      var targetX = _ref.targetX,\n          targetY = _ref.targetY,\n          _ref$animate = _ref.animate,\n          animate = _ref$animate === void 0 ? true : _ref$animate,\n          _ref$duration = _ref.duration,\n          duration = _ref$duration === void 0 ? animationDuration : _ref$duration,\n          _ref$overscrollEffect = _ref.overscrollEffect,\n          overscrollEffect = _ref$overscrollEffect === void 0 ? false : _ref$overscrollEffect;\n      var scrollLeft = this.scrollLeft,\n          scrollTop = this.scrollTop,\n          bounds = this.getScrollBounds(),\n          maxLeft = bounds.maxLeft,\n          maxTop = bounds.maxTop;\n      var updatedAnimationInfo = {\n        sourceX: scrollLeft,\n        sourceY: scrollTop,\n        targetX: targetX,\n        targetY: targetY,\n        duration: duration\n      }; // bail early when scrolling to the same position\n\n      if (this.animator.isAnimating() && this.animationInfo && this.animationInfo.targetX === targetX && this.animationInfo.targetY === targetY) {\n        return;\n      }\n\n      this.animationInfo = updatedAnimationInfo;\n      this.animator.stop();\n\n      if (!this.scrolling) {\n        this.scrolling = true;\n        this.forwardScrollEvent('onScrollStart');\n      }\n\n      this.scrollStopJob.stop();\n\n      if (Math.abs(maxLeft - targetX) < epsilon) {\n        targetX = maxLeft;\n      }\n\n      if (Math.abs(maxTop - targetY) < epsilon) {\n        targetY = maxTop;\n      }\n\n      if (this.overscrollEnabled && overscrollEffect) {\n        if (scrollLeft !== targetX && this.canScrollHorizontally(bounds)) {\n          this.checkAndApplyOverscrollEffectOnStart('horizontal', this.getEdgeFromPosition(targetX, maxLeft), targetX);\n        }\n\n        if (scrollTop !== targetY && this.canScrollVertically(bounds)) {\n          this.checkAndApplyOverscrollEffectOnStart('vertical', this.getEdgeFromPosition(targetY, maxTop), targetY);\n        }\n      }\n\n      this.showThumb(bounds);\n\n      if (animate) {\n        this.animator.animate(this.scrollAnimation(this.animationInfo));\n      } else {\n        this.scroll(targetX, targetY);\n        this.stop();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.animator.stop();\n      this.lastInputType = null;\n      this.isScrollAnimationTargetAccumulated = false;\n      this.startHidingThumb();\n\n      if (this.overscrollEnabled && !this.isDragging) {\n        // not check this.props.overscrollEffectOn for safty\n        this.clearAllOverscrollEffects();\n      }\n\n      if (this.props.stop) {\n        this.props.stop();\n      }\n\n      if (this.scrolling) {\n        this.scrollStopJob.start();\n      }\n    } // scrollTo API\n\n  }, {\n    key: \"showThumb\",\n    // scroll bar\n    value: function showThumb(bounds) {\n      if (this.state.isHorizontalScrollbarVisible && this.canScrollHorizontally(bounds) && this.horizontalScrollbarRef.current) {\n        this.horizontalScrollbarRef.current.showThumb();\n      }\n\n      if (this.state.isVerticalScrollbarVisible && this.canScrollVertically(bounds) && this.verticalScrollbarRef.current) {\n        this.verticalScrollbarRef.current.showThumb();\n      }\n    }\n  }, {\n    key: \"updateThumb\",\n    value: function updateThumb(scrollbarRef, bounds) {\n      scrollbarRef.current.update(_objectSpread({}, bounds, {\n        scrollLeft: this.scrollLeft,\n        scrollTop: this.scrollTop\n      }));\n    }\n  }, {\n    key: \"getScrollBounds\",\n    // ref\n    value: function getScrollBounds() {\n      if (this.childRefCurrent && typeof this.childRefCurrent.getScrollBounds === 'function') {\n        return this.childRefCurrent.getScrollBounds();\n      }\n    }\n  }, {\n    key: \"getMoreInfo\",\n    value: function getMoreInfo() {\n      if (this.childRefCurrent && typeof this.childRefCurrent.getMoreInfo === 'function') {\n        return this.childRefCurrent.getMoreInfo();\n      }\n    } // FIXME setting event handlers directly to work on the V8 snapshot.\n\n  }, {\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      var childRefCurrent = this.childRefCurrent,\n          containerRef = this.containerRef;\n\n      if (containerRef.current && containerRef.current.addEventListener) {\n        containerRef.current.addEventListener('wheel', this.onWheel);\n        containerRef.current.addEventListener('keydown', this.onKeyDown);\n      }\n\n      if (childRefCurrent && childRefCurrent.containerRef.current) {\n        if (childRefCurrent.containerRef.current.addEventListener) {\n          childRefCurrent.containerRef.current.addEventListener('mousedown', this.onMouseDown);\n        }\n      }\n\n      if (this.props.addEventListeners) {\n        this.props.addEventListeners(childRefCurrent.containerRef);\n      }\n    } // FIXME setting event handlers directly to work on the V8 snapshot.\n\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      var childRefCurrent = this.childRefCurrent,\n          containerRef = this.containerRef;\n\n      if (containerRef.current && containerRef.current.removeEventListener) {\n        containerRef.current.removeEventListener('wheel', this.onWheel);\n        containerRef.current.removeEventListener('keydown', this.onKeyDown);\n      }\n\n      if (childRefCurrent.containerRef.current && childRefCurrent.containerRef.current.removeEventListener) {\n        childRefCurrent.containerRef.current.removeEventListener('mousedown', this.onMouseDown);\n      }\n\n      if (this.props.removeEventListeners) {\n        this.props.removeEventListeners(childRefCurrent.containerRef);\n      }\n    } // render\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          className = _this$props3.className,\n          containerRenderer = _this$props3.containerRenderer,\n          noScrollByDrag = _this$props3.noScrollByDrag,\n          rtl = _this$props3.rtl,\n          style = _this$props3.style,\n          rest = _objectWithoutProperties(_this$props3, [\"className\", \"containerRenderer\", \"noScrollByDrag\", \"rtl\", \"style\"]),\n          _this$state3 = this.state,\n          isHorizontalScrollbarVisible = _this$state3.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state3.isVerticalScrollbarVisible,\n          scrollableClasses = (0, _classnames[\"default\"])(_ScrollableModule[\"default\"].scrollable, className),\n          childWrapper = noScrollByDrag ? 'div' : TouchableDiv,\n          childWrapperProps = _objectSpread({\n        className: _ScrollableModule[\"default\"].content\n      }, !noScrollByDrag && {\n        onDrag: this.onDrag,\n        onDragEnd: this.onDragEnd,\n        onDragStart: this.onDragStart,\n        onFlick: this.onFlick,\n        onTouchStart: this.onTouchStart\n      });\n\n      delete rest.addEventListeners;\n      delete rest.applyOverscrollEffect;\n      delete rest.cbScrollTo;\n      delete rest.clearOverscrollEffect;\n      delete rest.horizontalScrollbar;\n      delete rest.onFlick;\n      delete rest.onKeyDown;\n      delete rest.onMouseDown;\n      delete rest.onScroll;\n      delete rest.onScrollStart;\n      delete rest.onScrollStop;\n      delete rest.onWheel;\n      delete rest.overscrollEffectOn;\n      delete rest.removeEventListeners;\n      delete rest.scrollTo;\n      delete rest.stop;\n      delete rest.verticalScrollbar;\n      this.deferScrollTo = true;\n      return _react[\"default\"].createElement(_Resizable.ResizeContext.Provider, {\n        value: this.resizeRegistry.register\n      }, containerRenderer({\n        childComponentProps: rest,\n        childWrapper: childWrapper,\n        childWrapperProps: childWrapperProps,\n        className: scrollableClasses,\n        componentCss: _ScrollableModule[\"default\"],\n        containerRef: this.containerRef,\n        handleScroll: this.handleScroll,\n        horizontalScrollbarProps: this.horizontalScrollbarProps,\n        initChildRef: this.initChildRef,\n        isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,\n        isVerticalScrollbarVisible: isVerticalScrollbarVisible,\n        rtl: rtl,\n        scrollTo: this.scrollTo,\n        style: style,\n        verticalScrollbarProps: this.verticalScrollbarProps\n      }));\n    }\n  }]);\n\n  return ScrollableBase;\n}(_react.Component);\n/**\n * An unstyled component that provides horizontal and vertical scrollbars and makes a render prop element scrollable.\n *\n * @class Scrollable\n * @memberof ui/Scrollable\n * @extends ui/Scrollable.ScrollableBase\n * @ui\n * @private\n */\n\n\nexports.ScrollableBase = ScrollableBase;\nScrollableBase.displayName = 'ui:ScrollableBase';\nScrollableBase.propTypes =\n/** @lends ui/Scrollable.Scrollable.prototype */\n{\n  /**\n   * Render function.\n   *\n   * @type {Function}\n   * @required\n   * @private\n   */\n  containerRenderer: _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Called when adding additional event listeners in a themed component.\n   *\n   * @type {Function}\n   * @private\n   */\n  addEventListeners: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component to show overscroll effect.\n   *\n   * @type {Function}\n   * @private\n   */\n  applyOverscrollEffect: _propTypes[\"default\"].func,\n\n  /**\n   * A callback function that receives a reference to the `scrollTo` feature.\n   *\n   * Once received, the `scrollTo` method can be called as an imperative interface.\n   *\n   * The `scrollTo` function accepts the following paramaters:\n   * - {position: {x, y}} - Pixel value for x and/or y position\n   * - {align} - Where the scroll area should be aligned. Values are:\n   *   `'left'`, `'right'`, `'top'`, `'bottom'`,\n   *   `'topleft'`, `'topright'`, `'bottomleft'`, and `'bottomright'`.\n   * - {index} - Index of specific item. (`0` or positive integer)\n   *   This option is available for only `VirtualList` kind.\n   * - {node} - Node to scroll into view\n   * - {animate} - When `true`, scroll occurs with animation. When `false`, no\n   *   animation occurs.\n   * - {focus} - When `true`, attempts to focus item after scroll. Only valid when scrolling\n   *   by `index` or `node`.\n   * > Note: Only specify one of: `position`, `align`, `index` or `node`\n   *\n   * Example:\n   * ```\n   *\t// If you set cbScrollTo prop like below;\n   *\tcbScrollTo: (fn) => {this.scrollTo = fn;}\n   *\t// You can simply call like below;\n   *\tthis.scrollTo({align: 'top'}); // scroll to the top\n   * ```\n   *\n   * @type {Function}\n   * @public\n   */\n  cbScrollTo: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component to clear overscroll effect.\n   *\n   * @type {Function}\n   * @private\n   */\n  clearOverscrollEffect: _propTypes[\"default\"].func,\n\n  /**\n   * Client size of the container; valid values are an object that has `clientWidth` and `clientHeight`.\n   *\n   * @type {Object}\n   * @property {Number}    clientHeight    The client height of the list.\n   * @property {Number}    clientWidth    The client width of the list.\n   * @public\n   */\n  clientSize: _propTypes[\"default\"].shape({\n    clientHeight: _propTypes[\"default\"].number.isRequired,\n    clientWidth: _propTypes[\"default\"].number.isRequired\n  }),\n\n  /**\n   * Direction of the list or the scroller.\n   *\n   * `'both'` could be only used for[Scroller]{@link ui/Scroller.Scroller}.\n   *\n   * Valid values are:\n   * * `'both'`,\n   * * `'horizontal'`, and\n   * * `'vertical'`.\n   *\n   * @type {String}\n   * @private\n   */\n  direction: _propTypes[\"default\"].oneOf(['both', 'horizontal', 'vertical']),\n\n  /**\n   * Specifies how to show horizontal scrollbar.\n   *\n   * Valid values are:\n   * * `'auto'`,\n   * * `'visible'`, and\n   * * `'hidden'`.\n   *\n   * @type {String}\n   * @default 'auto'\n   * @public\n   */\n  horizontalScrollbar: _propTypes[\"default\"].oneOf(['auto', 'visible', 'hidden']),\n\n  /**\n   * Prevents scroll by dragging or flicking on the list or the scroller.\n   *\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  noScrollByDrag: _propTypes[\"default\"].bool,\n\n  /**\n   * Called when flicking with a mouse or a touch screen.\n   *\n   * @type {Function}\n   * @private\n   */\n  onFlick: _propTypes[\"default\"].func,\n\n  /**\n   * Called when pressing a key.\n   *\n   * @type {Function}\n   * @private\n   */\n  onKeyDown: _propTypes[\"default\"].func,\n\n  /**\n   * Called when trigerring a mousedown event.\n   *\n   * @type {Function}\n   * @private\n   */\n  onMouseDown: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scrolling.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * It is not recommended to set this prop since it can cause performance degradation.\n   * Use `onScrollStart` or `onScrollStop` instead.\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScroll: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scroll starts.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.\n   *\n   * Example:\n   * ```\n   * onScrollStart = ({scrollLeft, scrollTop, moreInfo}) => {\n   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;\n   *     // do something with firstVisibleIndex and lastVisibleIndex\n   * }\n   *\n   * render = () => (\n   *     <VirtualList\n   *         ...\n   *         onScrollStart={this.onScrollStart}\n   *         ...\n   *     />\n   * )\n   * ```\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScrollStart: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scroll stops.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.\n   *\n   * Example:\n   * ```\n   * onScrollStop = ({scrollLeft, scrollTop, moreInfo}) => {\n   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;\n   *     // do something with firstVisibleIndex and lastVisibleIndex\n   * }\n   *\n   * render = () => (\n   *     <VirtualList\n   *         ...\n   *         onScrollStop={this.onScrollStop}\n   *         ...\n   *     />\n   * )\n   * ```\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScrollStop: _propTypes[\"default\"].func,\n\n  /**\n   * Called when wheeling.\n   *\n   * @type {Function}\n   * @private\n   */\n  onWheel: _propTypes[\"default\"].func,\n\n  /**\n   * Specifies overscroll effects shows on which type of inputs.\n   *\n   * @type {Object}\n   * @default {drag: false, pageKey: false, wheel: false}\n   * @private\n   */\n  overscrollEffectOn: _propTypes[\"default\"].shape({\n    drag: _propTypes[\"default\"].bool,\n    pageKey: _propTypes[\"default\"].bool,\n    wheel: _propTypes[\"default\"].bool\n  }),\n\n  /**\n   * Called when removing additional event listeners in a themed component.\n   *\n   * @type {Function}\n   * @private\n   */\n  removeEventListeners: _propTypes[\"default\"].func,\n\n  /**\n   * Indicates the content's text direction is right-to-left.\n   *\n   * @type {Boolean}\n   * @private\n   */\n  rtl: _propTypes[\"default\"].bool,\n\n  /**\n   * Called to execute additional logic in a themed component when scrollTo is called.\n   *\n   * @type {Function}\n   * @private\n   */\n  scrollTo: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component when scroll stops.\n   *\n   * @type {Function}\n   * @private\n   */\n  stop: _propTypes[\"default\"].func,\n\n  /**\n   * Scrollable CSS style.\n   *\n   * Should be defined because we manipulate style prop in render().\n   *\n   * @type {Object}\n   * @public\n   */\n  style: _propTypes[\"default\"].object,\n\n  /**\n   * Specifies how to show vertical scrollbar.\n   *\n   * Valid values are:\n   * * `'auto'`,\n   * * `'visible'`, and\n   * * `'hidden'`.\n   *\n   * @type {String}\n   * @default 'auto'\n   * @public\n   */\n  verticalScrollbar: _propTypes[\"default\"].oneOf(['auto', 'visible', 'hidden'])\n};\nScrollableBase.defaultProps = {\n  cbScrollTo: nop,\n  horizontalScrollbar: 'auto',\n  noScrollByDrag: false,\n  onScroll: nop,\n  onScrollStart: nop,\n  onScrollStop: nop,\n  overscrollEffectOn: {\n    drag: false,\n    pageKey: false,\n    wheel: false\n  },\n  verticalScrollbar: 'auto'\n};\nScrollableBase.contextType = _Resizable.ResizeContext;\n\nvar Scrollable =\n/*#__PURE__*/\nfunction (_Component2) {\n  _inherits(Scrollable, _Component2);\n\n  function Scrollable() {\n    _classCallCheck(this, Scrollable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Scrollable).apply(this, arguments));\n  }\n\n  _createClass(Scrollable, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          childRenderer = _this$props4.childRenderer,\n          rest = _objectWithoutProperties(_this$props4, [\"childRenderer\"]);\n\n      return _react[\"default\"].createElement(ScrollableBase, Object.assign({}, rest, {\n        containerRenderer: function containerRenderer(_ref2) {\n          var childComponentProps = _ref2.childComponentProps,\n              ChildWrapper = _ref2.childWrapper,\n              childWrapperProps = _ref2.childWrapperProps,\n              containerRef = _ref2.containerRef,\n              className = _ref2.className,\n              componentCss = _ref2.componentCss,\n              handleScroll = _ref2.handleScroll,\n              horizontalScrollbarProps = _ref2.horizontalScrollbarProps,\n              initChildRef = _ref2.initChildRef,\n              isHorizontalScrollbarVisible = _ref2.isHorizontalScrollbarVisible,\n              isVerticalScrollbarVisible = _ref2.isVerticalScrollbarVisible,\n              rtl = _ref2.rtl,\n              scrollTo = _ref2.scrollTo,\n              style = _ref2.style,\n              verticalScrollbarProps = _ref2.verticalScrollbarProps;\n          return _react[\"default\"].createElement(\"div\", {\n            className: className,\n            ref: containerRef,\n            style: style\n          }, _react[\"default\"].createElement(\"div\", {\n            className: componentCss.container\n          }, _react[\"default\"].createElement(ChildWrapper, childWrapperProps, childRenderer(_objectSpread({}, childComponentProps, {\n            cbScrollTo: scrollTo,\n            className: componentCss.scrollableFill,\n            initChildRef: initChildRef,\n            onScroll: handleScroll,\n            rtl: rtl\n          }))), isVerticalScrollbarVisible ? _react[\"default\"].createElement(_Scrollbar[\"default\"], Object.assign({}, verticalScrollbarProps, {\n            disabled: !isVerticalScrollbarVisible\n          })) : null), isHorizontalScrollbarVisible ? _react[\"default\"].createElement(_Scrollbar[\"default\"], Object.assign({}, horizontalScrollbarProps, {\n            corner: isVerticalScrollbarVisible,\n            disabled: !isHorizontalScrollbarVisible\n          })) : null);\n        }\n      }));\n    }\n  }]);\n\n  return Scrollable;\n}(_react.Component);\n\nexports.Scrollable = Scrollable;\nScrollable.displayName = 'ui:Scrollable';\nScrollable.propTypes =\n/** @lends ui/Scrollable.Scrollable.prototype */\n{\n  /**\n   * Render function.\n   *\n   * @type {Function}\n   * @required\n   * @private\n   */\n  childRenderer: _propTypes[\"default\"].func.isRequired\n};\nvar _default = Scrollable;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/home/cdi/SteApp/node_modules/@enact/ui/Scrollable/Scrollable.js"],"names":["Object","defineProperty","exports","value","ScrollableBase","Scrollable","constants","_clamp","_interopRequireDefault","require","_classnames","_handle","_keymap","_Registry","_util","_propTypes","_react","_interopRequireWildcard","_ForwardRef","_Resizable","_resolution","_Touchable","_ScrollAnimator","_Scrollbar","_ScrollableModule","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","_typeof","Symbol","iterator","constructor","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","propertyIsEnumerable","sourceKeys","keys","_objectSpread","arguments","ownKeys","concat","filter","sym","enumerable","forEach","_defineProperty","configurable","writable","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_possibleConstructorReturn","self","_assertThisInitialized","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","ReferenceError","_inherits","subClass","superClass","create","_setPrototypeOf","p","animationDuration","epsilon","isPageDown","is","isPageUp","nop","overscrollTypeNone","overscrollTypeHold","overscrollTypeOnce","overscrollTypeDone","paginationPageMultiplier","scrollStopWaiting","scrollWheelPageMultiplierForMaxPixel","TouchableDiv","prop","_Component","_this","pixelPerLine","scrollWheelMultiplierForDeltaPixel","deferScrollTo","isScrollAnimationTargetAccumulated","isUpdatedScrollThumb","lastInputType","overscrollEnabled","overscrollStatus","horizontal","before","type","ratio","after","vertical","bounds","clientWidth","clientHeight","scrollWidth","scrollHeight","maxTop","maxLeft","wheelDirection","isDragging","scrolling","scrollLeft","scrollTop","scrollToInfo","childRefCurrent","animator","getRtlX","x","rtl","onMouseDown","ev","stop","forward","onDragStart","dragStartX","dragStartY","y","onDrag","direction","start","targetX","targetY","animate","overscrollEffect","overscrollEffectOn","drag","onDragEnd","flickTarget","_this$flickTarget","duration","clearAllOverscrollEffects","onFlick","simulate","velocityX","velocityY","onWheel","preventDefault","_assertThisInitialize","verticalScrollbarRef","horizontalScrollbarRef","getScrollBounds","canScrollHorizontally","canScrollVertically","eventDeltaMode","deltaMode","eventDelta","wheelDeltaY","deltaY","delta","calculateDistanceByWheel","Math","sign","scrollToAccumulatedTarget","wheel","scrollByPage","keyCode","state","isVerticalScrollbarVisible","pageDistance","pageKey","onKeyDown","accumulatedTargetX","accumulatedTargetY","getEdgeFromPosition","position","maxPosition","setOverscrollStatus","orientation","edge","status","getOverscrollStatus","calculateOverscrollRatio","isVertical","baseSize","maxPos","overDistance","min","applyOverscrollEffect","checkAndApplyOverscrollEffect","undefined","curPos","clearOverscrollEffect","applyOverscrollEffectOnDrag","targetPosition","oppositeEdge","checkAndApplyOverscrollEffectOnScroll","_this$getOverscrollSt","checkAndApplyOverscrollEffectOnStart","getReachedEdgeInfo","reachedEdgeInfo","bottom","left","right","top","_edge","doScrollStop","forwardScrollEvent","scrollStopJob","Job","scrollAnimation","animationInfo","curTime","sourceX","sourceY","toBeContinued","curTargetX","curTargetY","timingFunction","abs","scroll","setScrollLeft","setScrollTop","setScrollPosition","getPositionForScrollTo","opt","itemPos","align","includes","index","getItemPosition","stickTo","node","nodeType","getNodePosition","scrollTo","_this$getPositionForS","isNaN","startHidingThumb","isHorizontalScrollbarVisible","current","updateScrollbars","_this$props","horizontalScrollbar","verticalScrollbar","_this$state","curHorizontalScrollbarVisible","curVerticalScrollbarVisible","isVisibilityChanged","setState","updateScrollThumbSize","_this$props2","updatedBounds","update","initChildRef","ref","handleScroll","isAnimating","containerRef","getRtlPositionX","remeasure","createRef","horizontalScrollbarProps","clientSize","verticalScrollbarProps","resizeRegistry","handleResize","bind","cbScrollTo","componentDidMount","parent","context","addEventListeners","componentDidUpdate","prevProps","prevState","_this$state2","hasDataSizeChanged","syncClientSize","clampScrollPosition","notify","componentWillUnmount","removeEventListeners","action","enqueueForceUpdate","calculateMetrics","forceUpdate","maxPixel","scale","moreInfo","getMoreInfo","updateThumb","_ref","_ref$animate","_ref$duration","_ref$overscrollEffect","updatedAnimationInfo","showThumb","scrollbarRef","addEventListener","removeEventListener","render","_this$props3","className","containerRenderer","noScrollByDrag","style","rest","_this$state3","scrollableClasses","scrollable","childWrapper","childWrapperProps","content","onTouchStart","onScroll","onScrollStart","onScrollStop","createElement","ResizeContext","Provider","register","childComponentProps","componentCss","Component","displayName","propTypes","func","isRequired","shape","number","oneOf","bool","object","defaultProps","contextType","_Component2","apply","_this$props4","childRenderer","assign","_ref2","ChildWrapper","container","scrollableFill","disabled","corner","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScrollableBase = exports.Scrollable = exports.constants = exports[\"default\"] = void 0;\n\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _handle = require(\"@enact/core/handle\");\n\nvar _keymap = require(\"@enact/core/keymap\");\n\nvar _Registry = _interopRequireDefault(require(\"@enact/core/internal/Registry\"));\n\nvar _util = require(\"@enact/core/util\");\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _ForwardRef = _interopRequireDefault(require(\"../ForwardRef\"));\n\nvar _Resizable = require(\"../Resizable\");\n\nvar _resolution = _interopRequireDefault(require(\"../resolution\"));\n\nvar _Touchable = _interopRequireDefault(require(\"../Touchable\"));\n\nvar _ScrollAnimator = _interopRequireDefault(require(\"./ScrollAnimator\"));\n\nvar _Scrollbar = _interopRequireDefault(require(\"./Scrollbar\"));\n\nvar _ScrollableModule = _interopRequireDefault(require(\"./Scrollable.module.css\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj[\"default\"] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar constants = {\n  animationDuration: 1000,\n  epsilon: 1,\n  isPageDown: (0, _keymap.is)('pageDown'),\n  isPageUp: (0, _keymap.is)('pageUp'),\n  nop: function nop() {},\n  overscrollTypeNone: 0,\n  overscrollTypeHold: 1,\n  overscrollTypeOnce: 2,\n  overscrollTypeDone: 9,\n  paginationPageMultiplier: 0.8,\n  scrollStopWaiting: 200,\n  scrollWheelPageMultiplierForMaxPixel: 0.2 // The ratio of the maximum distance scrolled by wheel to the size of the viewport.\n\n},\n    animationDuration = constants.animationDuration,\n    epsilon = constants.epsilon,\n    isPageDown = constants.isPageDown,\n    isPageUp = constants.isPageUp,\n    nop = constants.nop,\n    overscrollTypeDone = constants.overscrollTypeDone,\n    overscrollTypeHold = constants.overscrollTypeHold,\n    overscrollTypeNone = constants.overscrollTypeNone,\n    overscrollTypeOnce = constants.overscrollTypeOnce,\n    paginationPageMultiplier = constants.paginationPageMultiplier,\n    scrollStopWaiting = constants.scrollStopWaiting,\n    scrollWheelPageMultiplierForMaxPixel = constants.scrollWheelPageMultiplierForMaxPixel;\nexports.constants = constants;\nvar TouchableDiv = (0, _ForwardRef[\"default\"])({\n  prop: 'ref'\n}, (0, _Touchable[\"default\"])('div'));\n/**\n * An unstyled component that passes scrollable behavior information as its render prop's arguments.\n *\n * @class ScrollableBase\n * @memberof ui/Scrollable\n * @ui\n * @private\n */\n\nvar ScrollableBase =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(ScrollableBase, _Component);\n\n  function ScrollableBase(props) {\n    var _this;\n\n    _classCallCheck(this, ScrollableBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollableBase).call(this, props));\n    _this.pixelPerLine = 39;\n    _this.scrollWheelMultiplierForDeltaPixel = 1.5;\n    _this.deferScrollTo = true;\n    _this.isScrollAnimationTargetAccumulated = false;\n    _this.isUpdatedScrollThumb = false;\n    _this.lastInputType = null;\n    _this.overscrollEnabled = false;\n    _this.overscrollStatus = {\n      horizontal: {\n        before: {\n          type: overscrollTypeNone,\n          ratio: 0\n        },\n        after: {\n          type: overscrollTypeNone,\n          ratio: 0\n        }\n      },\n      vertical: {\n        before: {\n          type: overscrollTypeNone,\n          ratio: 0\n        },\n        after: {\n          type: overscrollTypeNone,\n          ratio: 0\n        }\n      } // bounds info\n\n    };\n    _this.bounds = {\n      clientWidth: 0,\n      clientHeight: 0,\n      scrollWidth: 0,\n      scrollHeight: 0,\n      maxTop: 0,\n      maxLeft: 0 // wheel/drag/flick info\n\n    };\n    _this.wheelDirection = 0;\n    _this.isDragging = false;\n    _this.scrolling = false;\n    _this.scrollLeft = 0;\n    _this.scrollTop = 0;\n    _this.scrollToInfo = null;\n    _this.childRefCurrent = null;\n    _this.animator = new _ScrollAnimator[\"default\"]();\n\n    _this.getRtlX = function (x) {\n      return _this.props.rtl ? -x : x;\n    };\n\n    _this.onMouseDown = function (ev) {\n      _this.stop();\n\n      (0, _handle.forward)('onMouseDown', ev, _this.props);\n    };\n\n    _this.onDragStart = function (ev) {\n      if (ev.type === 'dragstart') return;\n\n      _this.stop();\n\n      _this.isDragging = true;\n      _this.dragStartX = _this.scrollLeft + _this.getRtlX(ev.x);\n      _this.dragStartY = _this.scrollTop + ev.y;\n    };\n\n    _this.onDrag = function (ev) {\n      if (ev.type === 'drag') return;\n      var direction = _this.props.direction;\n      _this.lastInputType = 'drag';\n\n      _this.start({\n        targetX: direction === 'vertical' ? 0 : _this.dragStartX - _this.getRtlX(ev.x),\n        // 'horizontal' or 'both'\n        targetY: direction === 'horizontal' ? 0 : _this.dragStartY - ev.y,\n        // 'vertical' or 'both'\n        animate: false,\n        overscrollEffect: _this.props.overscrollEffectOn.drag\n      });\n    };\n\n    _this.onDragEnd = function (ev) {\n      if (ev.type === 'dragend') return;\n      _this.isDragging = false;\n\n      if (_this.flickTarget) {\n        var _this$flickTarget = _this.flickTarget,\n            targetX = _this$flickTarget.targetX,\n            targetY = _this$flickTarget.targetY,\n            duration = _this$flickTarget.duration;\n        _this.lastInputType = 'drag';\n        _this.isScrollAnimationTargetAccumulated = false;\n\n        _this.start({\n          targetX: targetX,\n          targetY: targetY,\n          duration: duration,\n          overscrollEffect: _this.props.overscrollEffectOn.drag\n        });\n      } else {\n        _this.stop();\n      }\n\n      if (_this.overscrollEnabled) {\n        // not check this.props.overscrollEffectOn.drag for safety\n        _this.clearAllOverscrollEffects();\n      }\n\n      _this.flickTarget = null;\n    };\n\n    _this.onFlick = function (ev) {\n      var direction = _this.props.direction;\n      _this.flickTarget = _this.animator.simulate(_this.scrollLeft, _this.scrollTop, direction !== 'vertical' ? _this.getRtlX(-ev.velocityX) : 0, direction !== 'horizontal' ? -ev.velocityY : 0);\n\n      if (_this.props.onFlick) {\n        (0, _handle.forward)('onFlick', ev, _this.props);\n      }\n    };\n\n    _this.onWheel = function (ev) {\n      ev.preventDefault();\n\n      if (!_this.isDragging) {\n        var _assertThisInitialize = _assertThisInitialized(_this),\n            verticalScrollbarRef = _assertThisInitialize.verticalScrollbarRef,\n            horizontalScrollbarRef = _assertThisInitialize.horizontalScrollbarRef,\n            bounds = _this.getScrollBounds(),\n            canScrollHorizontally = _this.canScrollHorizontally(bounds),\n            canScrollVertically = _this.canScrollVertically(bounds),\n            eventDeltaMode = ev.deltaMode,\n            eventDelta = -ev.wheelDeltaY || ev.deltaY;\n\n        var delta = 0,\n            direction;\n        _this.lastInputType = 'wheel';\n\n        if (canScrollVertically) {\n          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);\n        } else if (canScrollHorizontally) {\n          delta = _this.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);\n        }\n\n        direction = Math.sign(delta);\n\n        if (direction !== _this.wheelDirection) {\n          _this.isScrollAnimationTargetAccumulated = false;\n          _this.wheelDirection = direction;\n        }\n\n        (0, _handle.forward)('onWheel', {\n          delta: delta,\n          horizontalScrollbarRef: horizontalScrollbarRef,\n          verticalScrollbarRef: verticalScrollbarRef\n        }, _this.props);\n\n        if (delta !== 0) {\n          _this.scrollToAccumulatedTarget(delta, canScrollVertically, _this.props.overscrollEffectOn.wheel);\n        }\n      }\n    };\n\n    _this.scrollByPage = function (keyCode) {\n      // Only scroll by page when the vertical scrollbar is visible. Otherwise, treat the\n      // scroller as a plain container\n      if (!_this.state.isVerticalScrollbarVisible) return;\n\n      var bounds = _this.getScrollBounds(),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          pageDistance = (isPageUp(keyCode) ? -1 : 1) * (canScrollVertically ? bounds.clientHeight : bounds.clientWidth) * paginationPageMultiplier;\n\n      _this.lastInputType = 'pageKey';\n\n      _this.scrollToAccumulatedTarget(pageDistance, canScrollVertically, _this.props.overscrollEffectOn.pageKey);\n    };\n\n    _this.onKeyDown = function (ev) {\n      if (_this.props.onKeyDown) {\n        (0, _handle.forward)('onKeyDown', ev, _this.props);\n      } else if (isPageUp(ev.keyCode) || isPageDown(ev.keyCode)) {\n        _this.scrollByPage(ev.keyCode);\n      }\n    };\n\n    _this.scrollToAccumulatedTarget = function (delta, vertical, overscrollEffect) {\n      if (!_this.isScrollAnimationTargetAccumulated) {\n        _this.accumulatedTargetX = _this.scrollLeft;\n        _this.accumulatedTargetY = _this.scrollTop;\n        _this.isScrollAnimationTargetAccumulated = true;\n      }\n\n      if (vertical) {\n        _this.accumulatedTargetY += delta;\n      } else {\n        _this.accumulatedTargetX += delta;\n      }\n\n      _this.start({\n        targetX: _this.accumulatedTargetX,\n        targetY: _this.accumulatedTargetY,\n        overscrollEffect: overscrollEffect\n      });\n    };\n\n    _this.getEdgeFromPosition = function (position, maxPosition) {\n      if (position <= 0) {\n        return 'before';\n      } else if (position >= maxPosition) {\n        return 'after';\n      } else {\n        return null;\n      }\n    };\n\n    _this.setOverscrollStatus = function (orientation, edge, type, ratio) {\n      var status = _this.overscrollStatus[orientation][edge];\n      status.type = type;\n      status.ratio = ratio;\n    };\n\n    _this.getOverscrollStatus = function (orientation, edge) {\n      return _this.overscrollStatus[orientation][edge];\n    };\n\n    _this.calculateOverscrollRatio = function (orientation, position) {\n      var bounds = _this.getScrollBounds(),\n          isVertical = orientation === 'vertical',\n          baseSize = isVertical ? bounds.clientHeight : bounds.clientWidth,\n          maxPos = bounds[isVertical ? 'maxTop' : 'maxLeft'];\n\n      var overDistance = 0;\n\n      if (position < 0) {\n        overDistance = -position;\n      } else if (position > maxPos) {\n        overDistance = position - maxPos;\n      } else {\n        return 0;\n      }\n\n      return Math.min(1, 2 * overDistance / baseSize);\n    };\n\n    _this.applyOverscrollEffect = function (orientation, edge, type, ratio) {\n      _this.props.applyOverscrollEffect(orientation, edge, type, ratio);\n\n      _this.setOverscrollStatus(orientation, edge, type === overscrollTypeOnce ? overscrollTypeDone : type, ratio);\n    };\n\n    _this.checkAndApplyOverscrollEffect = function (orientation, edge, type) {\n      var ratio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n      var isVertical = orientation === 'vertical',\n          curPos = isVertical ? _this.scrollTop : _this.scrollLeft,\n          maxPos = _this.getScrollBounds()[isVertical ? 'maxTop' : 'maxLeft'];\n\n      if (edge === 'before' && curPos <= 0 || edge === 'after' && curPos >= maxPos) {\n        // Already on the edge\n        _this.applyOverscrollEffect(orientation, edge, type, ratio);\n      } else {\n        _this.setOverscrollStatus(orientation, edge, type, ratio);\n      }\n    };\n\n    _this.clearOverscrollEffect = function (orientation, edge) {\n      if (_this.getOverscrollStatus(orientation, edge).type !== overscrollTypeNone) {\n        if (_this.props.clearOverscrollEffect) {\n          _this.props.clearOverscrollEffect(orientation, edge);\n        } else {\n          _this.applyOverscrollEffect(orientation, edge, overscrollTypeNone, 0);\n        }\n      }\n    };\n\n    _this.clearAllOverscrollEffects = function () {\n      ['horizontal', 'vertical'].forEach(function (orientation) {\n        ['before', 'after'].forEach(function (edge) {\n          _this.clearOverscrollEffect(orientation, edge);\n        });\n      });\n    };\n\n    _this.applyOverscrollEffectOnDrag = function (orientation, edge, targetPosition, type) {\n      if (edge) {\n        var oppositeEdge = edge === 'before' ? 'after' : 'before',\n            ratio = _this.calculateOverscrollRatio(orientation, targetPosition);\n\n        _this.applyOverscrollEffect(orientation, edge, type, ratio);\n\n        _this.clearOverscrollEffect(orientation, oppositeEdge);\n      } else {\n        _this.clearOverscrollEffect(orientation, 'before');\n\n        _this.clearOverscrollEffect(orientation, 'after');\n      }\n    };\n\n    _this.checkAndApplyOverscrollEffectOnScroll = function (orientation) {\n      ['before', 'after'].forEach(function (edge) {\n        var _this$getOverscrollSt = _this.getOverscrollStatus(orientation, edge),\n            ratio = _this$getOverscrollSt.ratio,\n            type = _this$getOverscrollSt.type;\n\n        if (type === overscrollTypeOnce) {\n          _this.checkAndApplyOverscrollEffect(orientation, edge, type, ratio);\n        }\n      });\n    };\n\n    _this.checkAndApplyOverscrollEffectOnStart = function (orientation, edge, targetPosition) {\n      if (_this.isDragging) {\n        _this.applyOverscrollEffectOnDrag(orientation, edge, targetPosition, overscrollTypeHold);\n      } else if (edge) {\n        _this.checkAndApplyOverscrollEffect(orientation, edge, overscrollTypeOnce);\n      }\n    };\n\n    _this.getReachedEdgeInfo = function () {\n      var bounds = _this.getScrollBounds(),\n          reachedEdgeInfo = {\n        bottom: false,\n        left: false,\n        right: false,\n        top: false\n      };\n\n      if (_this.canScrollHorizontally(bounds)) {\n        var rtl = _this.props.rtl,\n            edge = _this.getEdgeFromPosition(_this.scrollLeft, bounds.maxLeft);\n\n        if (edge) {\n          // if edge is null, no need to check which edge is reached.\n          if (edge === 'before' && !rtl || edge === 'after' && rtl) {\n            reachedEdgeInfo.left = true;\n          } else {\n            reachedEdgeInfo.right = true;\n          }\n        }\n      }\n\n      if (_this.canScrollVertically(bounds)) {\n        var _edge = _this.getEdgeFromPosition(_this.scrollTop, bounds.maxTop);\n\n        if (_edge === 'before') {\n          reachedEdgeInfo.top = true;\n        } else if (_edge === 'after') {\n          reachedEdgeInfo.bottom = true;\n        }\n      }\n\n      return reachedEdgeInfo;\n    };\n\n    _this.doScrollStop = function () {\n      _this.scrolling = false;\n\n      _this.forwardScrollEvent('onScrollStop', _this.getReachedEdgeInfo());\n    };\n\n    _this.scrollStopJob = new _util.Job(_this.doScrollStop, scrollStopWaiting);\n\n    _this.scrollAnimation = function (animationInfo) {\n      return function (curTime) {\n        var sourceX = animationInfo.sourceX,\n            sourceY = animationInfo.sourceY,\n            targetX = animationInfo.targetX,\n            targetY = animationInfo.targetY,\n            duration = animationInfo.duration,\n            bounds = _this.getScrollBounds();\n\n        if (curTime < duration) {\n          var toBeContinued = false,\n              curTargetX = sourceX,\n              curTargetY = sourceY;\n\n          if (_this.canScrollHorizontally(bounds)) {\n            curTargetX = _this.animator.timingFunction(sourceX, targetX, duration, curTime);\n\n            if (Math.abs(curTargetX - targetX) < epsilon) {\n              curTargetX = targetX;\n            } else {\n              toBeContinued = true;\n            }\n          }\n\n          if (_this.canScrollVertically(bounds)) {\n            curTargetY = _this.animator.timingFunction(sourceY, targetY, duration, curTime);\n\n            if (Math.abs(curTargetY - targetY) < epsilon) {\n              curTargetY = targetY;\n            } else {\n              toBeContinued = true;\n            }\n          }\n\n          _this.scroll(curTargetX, curTargetY);\n\n          if (!toBeContinued) {\n            _this.stop();\n          }\n        } else {\n          _this.scroll(targetX, targetY);\n\n          _this.stop();\n        }\n      };\n    };\n\n    _this.scroll = function (left, top) {\n      if (left !== _this.scrollLeft) {\n        _this.setScrollLeft(left);\n      }\n\n      if (top !== _this.scrollTop) {\n        _this.setScrollTop(top);\n      }\n\n      _this.childRefCurrent.setScrollPosition(_this.scrollLeft, _this.scrollTop);\n\n      _this.forwardScrollEvent('onScroll');\n    };\n\n    _this.getPositionForScrollTo = function (opt) {\n      var bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds);\n\n      var itemPos,\n          left = null,\n          top = null;\n\n      if (opt instanceof Object) {\n        if (opt.position instanceof Object) {\n          if (canScrollHorizontally) {\n            // We need '!=' to check if opt.potision.x is null or undefined\n            left = opt.position.x != null ? opt.position.x : _this.scrollLeft;\n          } else {\n            left = 0;\n          }\n\n          if (canScrollVertically) {\n            // We need '!=' to check if opt.potision.y is null or undefined\n            top = opt.position.y != null ? opt.position.y : _this.scrollTop;\n          } else {\n            top = 0;\n          }\n        } else if (typeof opt.align === 'string') {\n          if (canScrollHorizontally) {\n            if (opt.align.includes('left')) {\n              left = 0;\n            } else if (opt.align.includes('right')) {\n              left = bounds.maxLeft;\n            }\n          }\n\n          if (canScrollVertically) {\n            if (opt.align.includes('top')) {\n              top = 0;\n            } else if (opt.align.includes('bottom')) {\n              top = bounds.maxTop;\n            }\n          }\n        } else {\n          if (typeof opt.index === 'number' && typeof _this.childRefCurrent.getItemPosition === 'function') {\n            itemPos = _this.childRefCurrent.getItemPosition(opt.index, opt.stickTo);\n          } else if (opt.node instanceof Object) {\n            if (opt.node.nodeType === 1 && typeof _this.childRefCurrent.getNodePosition === 'function') {\n              itemPos = _this.childRefCurrent.getNodePosition(opt.node);\n            }\n          }\n\n          if (itemPos) {\n            if (canScrollHorizontally) {\n              left = itemPos.left;\n            }\n\n            if (canScrollVertically) {\n              top = itemPos.top;\n            }\n          }\n        }\n      }\n\n      return {\n        left: left,\n        top: top\n      };\n    };\n\n    _this.scrollTo = function (opt) {\n      if (!_this.deferScrollTo) {\n        var _this$getPositionForS = _this.getPositionForScrollTo(opt),\n            left = _this$getPositionForS.left,\n            top = _this$getPositionForS.top;\n\n        if (_this.props.scrollTo) {\n          _this.props.scrollTo(opt);\n        }\n\n        _this.scrollToInfo = null;\n\n        _this.start({\n          targetX: left !== null ? left : _this.scrollLeft,\n          targetY: top !== null ? top : _this.scrollTop,\n          animate: opt.animate\n        });\n      } else {\n        _this.scrollToInfo = opt;\n      }\n    };\n\n    _this.canScrollHorizontally = function (bounds) {\n      var direction = _this.props.direction;\n      return (direction === 'horizontal' || direction === 'both') && bounds.scrollWidth > bounds.clientWidth && !isNaN(bounds.scrollWidth);\n    };\n\n    _this.canScrollVertically = function (bounds) {\n      var direction = _this.props.direction;\n      return (direction === 'vertical' || direction === 'both') && bounds.scrollHeight > bounds.clientHeight && !isNaN(bounds.scrollHeight);\n    };\n\n    _this.startHidingThumb = function () {\n      if (_this.state.isHorizontalScrollbarVisible && _this.horizontalScrollbarRef.current) {\n        _this.horizontalScrollbarRef.current.startHidingThumb();\n      }\n\n      if (_this.state.isVerticalScrollbarVisible && _this.verticalScrollbarRef.current) {\n        _this.verticalScrollbarRef.current.startHidingThumb();\n      }\n    };\n\n    _this.updateScrollbars = function () {\n      var _this$props = _this.props,\n          horizontalScrollbar = _this$props.horizontalScrollbar,\n          verticalScrollbar = _this$props.verticalScrollbar,\n          _this$state = _this.state,\n          isHorizontalScrollbarVisible = _this$state.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state.isVerticalScrollbarVisible,\n          bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',\n          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible'; // determine if we should hide or show any scrollbars\n\n\n      var isVisibilityChanged = isHorizontalScrollbarVisible !== curHorizontalScrollbarVisible || isVerticalScrollbarVisible !== curVerticalScrollbarVisible;\n\n      if (isVisibilityChanged) {\n        // one or both scrollbars have changed visibility\n        _this.setState({\n          isHorizontalScrollbarVisible: curHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible: curVerticalScrollbarVisible\n        });\n      } else {\n        _this.deferScrollTo = false;\n        _this.isUpdatedScrollThumb = _this.updateScrollThumbSize();\n      }\n    };\n\n    _this.updateScrollThumbSize = function () {\n      var _this$props2 = _this.props,\n          horizontalScrollbar = _this$props2.horizontalScrollbar,\n          verticalScrollbar = _this$props2.verticalScrollbar,\n          bounds = _this.getScrollBounds(),\n          canScrollHorizontally = _this.canScrollHorizontally(bounds),\n          canScrollVertically = _this.canScrollVertically(bounds),\n          curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollHorizontally : horizontalScrollbar === 'visible',\n          curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollVertically : verticalScrollbar === 'visible';\n\n      if (curHorizontalScrollbarVisible || curVerticalScrollbarVisible) {\n        // no visibility change but need to notify whichever scrollbars are visible of the\n        // updated bounds and scroll position\n        var updatedBounds = _objectSpread({}, bounds, {\n          scrollLeft: _this.scrollLeft,\n          scrollTop: _this.scrollTop\n        });\n\n        if (curHorizontalScrollbarVisible && _this.horizontalScrollbarRef) {\n          _this.horizontalScrollbarRef.current.update(updatedBounds);\n        }\n\n        if (curVerticalScrollbarVisible && _this.verticalScrollbarRef) {\n          _this.verticalScrollbarRef.current.update(updatedBounds);\n        }\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.initChildRef = function (ref) {\n      if (ref) {\n        _this.childRefCurrent = ref;\n      }\n    };\n\n    _this.handleScroll = function () {\n      var childRefCurrent = _this.childRefCurrent; // Prevent scroll by focus.\n      // VirtualList and VirtualGridList DO NOT receive `onscroll` event.\n      // Only Scroller could get `onscroll` event.\n\n      if (!_this.animator.isAnimating() && childRefCurrent && childRefCurrent.containerRef.current && childRefCurrent.getRtlPositionX) {\n        // For Scroller\n        childRefCurrent.containerRef.current.scrollTop = _this.scrollTop;\n        childRefCurrent.containerRef.current.scrollLeft = childRefCurrent.getRtlPositionX(_this.scrollLeft);\n      }\n    };\n\n    _this.state = {\n      remeasure: false,\n      isHorizontalScrollbarVisible: props.horizontalScrollbar === 'visible',\n      isVerticalScrollbarVisible: props.verticalScrollbar === 'visible'\n    };\n    _this.containerRef = _react[\"default\"].createRef();\n    _this.horizontalScrollbarRef = _react[\"default\"].createRef();\n    _this.verticalScrollbarRef = _react[\"default\"].createRef();\n    _this.horizontalScrollbarProps = {\n      ref: _this.horizontalScrollbarRef,\n      vertical: false,\n      clientSize: props.clientSize\n    };\n    _this.verticalScrollbarProps = {\n      ref: _this.verticalScrollbarRef,\n      vertical: true,\n      clientSize: props.clientSize\n    };\n    _this.overscrollEnabled = !!props.applyOverscrollEffect; // Enable the early bail out of repeated scrolling to the same position\n\n    _this.animationInfo = null;\n    _this.resizeRegistry = _Registry[\"default\"].create(_this.handleResize.bind(_assertThisInitialized(_this)));\n    props.cbScrollTo(_this.scrollTo);\n    return _this;\n  }\n\n  _createClass(ScrollableBase, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.resizeRegistry.parent = this.context;\n      this.addEventListeners();\n      this.updateScrollbars();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$state2 = this.state,\n          isHorizontalScrollbarVisible = _this$state2.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state2.isVerticalScrollbarVisible,\n          hasDataSizeChanged = this.childRefCurrent.hasDataSizeChanged; // Need to sync calculated client size if it is different from the real size\n\n      if (this.childRefCurrent.syncClientSize) {\n        // If we actually synced, we need to reset scroll position.\n        if (this.childRefCurrent.syncClientSize()) {\n          this.setScrollLeft(0);\n          this.setScrollTop(0);\n        }\n      }\n\n      this.clampScrollPosition();\n      this.addEventListeners();\n\n      if (hasDataSizeChanged === false && (isHorizontalScrollbarVisible && !prevState.isHorizontalScrollbarVisible || isVerticalScrollbarVisible && !prevState.isVerticalScrollbarVisible)) {\n        this.deferScrollTo = false;\n        this.isUpdatedScrollThumb = this.updateScrollThumbSize();\n      } else {\n        this.updateScrollbars();\n      }\n\n      if (this.scrollToInfo !== null) {\n        if (!this.deferScrollTo) {\n          this.scrollTo(this.scrollToInfo);\n        }\n      } // publish container resize changes\n\n\n      var horizontal = isHorizontalScrollbarVisible !== prevState.isHorizontalScrollbarVisible;\n      var vertical = isVerticalScrollbarVisible !== prevState.isVerticalScrollbarVisible;\n\n      if (horizontal || vertical) {\n        this.resizeRegistry.notify({});\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.resizeRegistry.parent = null; // Before call cancelAnimationFrame, you must send scrollStop Event.\n\n      if (this.scrolling) {\n        this.forwardScrollEvent('onScrollStop', this.getReachedEdgeInfo());\n      }\n\n      this.scrollStopJob.stop();\n\n      if (this.animator.isAnimating()) {\n        this.animator.stop();\n      }\n\n      this.removeEventListeners();\n    }\n  }, {\n    key: \"handleResize\",\n    value: function handleResize(ev) {\n      if (ev.action === 'invalidateBounds') {\n        this.enqueueForceUpdate();\n      }\n    } // TODO: consider replacing forceUpdate() by storing bounds in state rather than a non-\n    // state member.\n\n  }, {\n    key: \"enqueueForceUpdate\",\n    value: function enqueueForceUpdate() {\n      this.childRefCurrent.calculateMetrics();\n      this.forceUpdate();\n    }\n  }, {\n    key: \"clampScrollPosition\",\n    value: function clampScrollPosition() {\n      var bounds = this.getScrollBounds();\n\n      if (this.scrollTop > bounds.maxTop) {\n        this.scrollTop = bounds.maxTop;\n      }\n\n      if (this.scrollLeft > bounds.maxLeft) {\n        this.scrollLeft = bounds.maxLeft;\n      }\n    } // constants\n\n  }, {\n    key: \"calculateDistanceByWheel\",\n    value: function calculateDistanceByWheel(deltaMode, delta, maxPixel) {\n      if (deltaMode === 0) {\n        delta = (0, _clamp[\"default\"])(-maxPixel, maxPixel, _resolution[\"default\"].scale(delta * this.scrollWheelMultiplierForDeltaPixel));\n      } else if (deltaMode === 1) {\n        // line; firefox\n        delta = (0, _clamp[\"default\"])(-maxPixel, maxPixel, _resolution[\"default\"].scale(delta * this.pixelPerLine * this.scrollWheelMultiplierForDeltaPixel));\n      } else if (deltaMode === 2) {\n        // page\n        delta = delta < 0 ? -maxPixel : maxPixel;\n      }\n\n      return delta;\n    }\n  }, {\n    key: \"forwardScrollEvent\",\n    // call scroll callbacks\n    value: function forwardScrollEvent(type, reachedEdgeInfo) {\n      (0, _handle.forward)(type, {\n        scrollLeft: this.scrollLeft,\n        scrollTop: this.scrollTop,\n        moreInfo: this.getMoreInfo(),\n        reachedEdgeInfo: reachedEdgeInfo\n      }, this.props);\n    } // update scroll position\n\n  }, {\n    key: \"setScrollLeft\",\n    value: function setScrollLeft(value) {\n      var bounds = this.getScrollBounds();\n      this.scrollLeft = (0, _clamp[\"default\"])(0, bounds.maxLeft, value);\n\n      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {\n        this.checkAndApplyOverscrollEffectOnScroll('horizontal');\n      }\n\n      if (this.state.isHorizontalScrollbarVisible) {\n        this.updateThumb(this.horizontalScrollbarRef, bounds);\n      }\n    }\n  }, {\n    key: \"setScrollTop\",\n    value: function setScrollTop(value) {\n      var bounds = this.getScrollBounds();\n      this.scrollTop = (0, _clamp[\"default\"])(0, bounds.maxTop, value);\n\n      if (this.overscrollEnabled && this.props.overscrollEffectOn[this.lastInputType]) {\n        this.checkAndApplyOverscrollEffectOnScroll('vertical');\n      }\n\n      if (this.state.isVerticalScrollbarVisible) {\n        this.updateThumb(this.verticalScrollbarRef, bounds);\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start(_ref) {\n      var targetX = _ref.targetX,\n          targetY = _ref.targetY,\n          _ref$animate = _ref.animate,\n          animate = _ref$animate === void 0 ? true : _ref$animate,\n          _ref$duration = _ref.duration,\n          duration = _ref$duration === void 0 ? animationDuration : _ref$duration,\n          _ref$overscrollEffect = _ref.overscrollEffect,\n          overscrollEffect = _ref$overscrollEffect === void 0 ? false : _ref$overscrollEffect;\n      var scrollLeft = this.scrollLeft,\n          scrollTop = this.scrollTop,\n          bounds = this.getScrollBounds(),\n          maxLeft = bounds.maxLeft,\n          maxTop = bounds.maxTop;\n      var updatedAnimationInfo = {\n        sourceX: scrollLeft,\n        sourceY: scrollTop,\n        targetX: targetX,\n        targetY: targetY,\n        duration: duration\n      }; // bail early when scrolling to the same position\n\n      if (this.animator.isAnimating() && this.animationInfo && this.animationInfo.targetX === targetX && this.animationInfo.targetY === targetY) {\n        return;\n      }\n\n      this.animationInfo = updatedAnimationInfo;\n      this.animator.stop();\n\n      if (!this.scrolling) {\n        this.scrolling = true;\n        this.forwardScrollEvent('onScrollStart');\n      }\n\n      this.scrollStopJob.stop();\n\n      if (Math.abs(maxLeft - targetX) < epsilon) {\n        targetX = maxLeft;\n      }\n\n      if (Math.abs(maxTop - targetY) < epsilon) {\n        targetY = maxTop;\n      }\n\n      if (this.overscrollEnabled && overscrollEffect) {\n        if (scrollLeft !== targetX && this.canScrollHorizontally(bounds)) {\n          this.checkAndApplyOverscrollEffectOnStart('horizontal', this.getEdgeFromPosition(targetX, maxLeft), targetX);\n        }\n\n        if (scrollTop !== targetY && this.canScrollVertically(bounds)) {\n          this.checkAndApplyOverscrollEffectOnStart('vertical', this.getEdgeFromPosition(targetY, maxTop), targetY);\n        }\n      }\n\n      this.showThumb(bounds);\n\n      if (animate) {\n        this.animator.animate(this.scrollAnimation(this.animationInfo));\n      } else {\n        this.scroll(targetX, targetY);\n        this.stop();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.animator.stop();\n      this.lastInputType = null;\n      this.isScrollAnimationTargetAccumulated = false;\n      this.startHidingThumb();\n\n      if (this.overscrollEnabled && !this.isDragging) {\n        // not check this.props.overscrollEffectOn for safty\n        this.clearAllOverscrollEffects();\n      }\n\n      if (this.props.stop) {\n        this.props.stop();\n      }\n\n      if (this.scrolling) {\n        this.scrollStopJob.start();\n      }\n    } // scrollTo API\n\n  }, {\n    key: \"showThumb\",\n    // scroll bar\n    value: function showThumb(bounds) {\n      if (this.state.isHorizontalScrollbarVisible && this.canScrollHorizontally(bounds) && this.horizontalScrollbarRef.current) {\n        this.horizontalScrollbarRef.current.showThumb();\n      }\n\n      if (this.state.isVerticalScrollbarVisible && this.canScrollVertically(bounds) && this.verticalScrollbarRef.current) {\n        this.verticalScrollbarRef.current.showThumb();\n      }\n    }\n  }, {\n    key: \"updateThumb\",\n    value: function updateThumb(scrollbarRef, bounds) {\n      scrollbarRef.current.update(_objectSpread({}, bounds, {\n        scrollLeft: this.scrollLeft,\n        scrollTop: this.scrollTop\n      }));\n    }\n  }, {\n    key: \"getScrollBounds\",\n    // ref\n    value: function getScrollBounds() {\n      if (this.childRefCurrent && typeof this.childRefCurrent.getScrollBounds === 'function') {\n        return this.childRefCurrent.getScrollBounds();\n      }\n    }\n  }, {\n    key: \"getMoreInfo\",\n    value: function getMoreInfo() {\n      if (this.childRefCurrent && typeof this.childRefCurrent.getMoreInfo === 'function') {\n        return this.childRefCurrent.getMoreInfo();\n      }\n    } // FIXME setting event handlers directly to work on the V8 snapshot.\n\n  }, {\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      var childRefCurrent = this.childRefCurrent,\n          containerRef = this.containerRef;\n\n      if (containerRef.current && containerRef.current.addEventListener) {\n        containerRef.current.addEventListener('wheel', this.onWheel);\n        containerRef.current.addEventListener('keydown', this.onKeyDown);\n      }\n\n      if (childRefCurrent && childRefCurrent.containerRef.current) {\n        if (childRefCurrent.containerRef.current.addEventListener) {\n          childRefCurrent.containerRef.current.addEventListener('mousedown', this.onMouseDown);\n        }\n      }\n\n      if (this.props.addEventListeners) {\n        this.props.addEventListeners(childRefCurrent.containerRef);\n      }\n    } // FIXME setting event handlers directly to work on the V8 snapshot.\n\n  }, {\n    key: \"removeEventListeners\",\n    value: function removeEventListeners() {\n      var childRefCurrent = this.childRefCurrent,\n          containerRef = this.containerRef;\n\n      if (containerRef.current && containerRef.current.removeEventListener) {\n        containerRef.current.removeEventListener('wheel', this.onWheel);\n        containerRef.current.removeEventListener('keydown', this.onKeyDown);\n      }\n\n      if (childRefCurrent.containerRef.current && childRefCurrent.containerRef.current.removeEventListener) {\n        childRefCurrent.containerRef.current.removeEventListener('mousedown', this.onMouseDown);\n      }\n\n      if (this.props.removeEventListeners) {\n        this.props.removeEventListeners(childRefCurrent.containerRef);\n      }\n    } // render\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props3 = this.props,\n          className = _this$props3.className,\n          containerRenderer = _this$props3.containerRenderer,\n          noScrollByDrag = _this$props3.noScrollByDrag,\n          rtl = _this$props3.rtl,\n          style = _this$props3.style,\n          rest = _objectWithoutProperties(_this$props3, [\"className\", \"containerRenderer\", \"noScrollByDrag\", \"rtl\", \"style\"]),\n          _this$state3 = this.state,\n          isHorizontalScrollbarVisible = _this$state3.isHorizontalScrollbarVisible,\n          isVerticalScrollbarVisible = _this$state3.isVerticalScrollbarVisible,\n          scrollableClasses = (0, _classnames[\"default\"])(_ScrollableModule[\"default\"].scrollable, className),\n          childWrapper = noScrollByDrag ? 'div' : TouchableDiv,\n          childWrapperProps = _objectSpread({\n        className: _ScrollableModule[\"default\"].content\n      }, !noScrollByDrag && {\n        onDrag: this.onDrag,\n        onDragEnd: this.onDragEnd,\n        onDragStart: this.onDragStart,\n        onFlick: this.onFlick,\n        onTouchStart: this.onTouchStart\n      });\n\n      delete rest.addEventListeners;\n      delete rest.applyOverscrollEffect;\n      delete rest.cbScrollTo;\n      delete rest.clearOverscrollEffect;\n      delete rest.horizontalScrollbar;\n      delete rest.onFlick;\n      delete rest.onKeyDown;\n      delete rest.onMouseDown;\n      delete rest.onScroll;\n      delete rest.onScrollStart;\n      delete rest.onScrollStop;\n      delete rest.onWheel;\n      delete rest.overscrollEffectOn;\n      delete rest.removeEventListeners;\n      delete rest.scrollTo;\n      delete rest.stop;\n      delete rest.verticalScrollbar;\n      this.deferScrollTo = true;\n      return _react[\"default\"].createElement(_Resizable.ResizeContext.Provider, {\n        value: this.resizeRegistry.register\n      }, containerRenderer({\n        childComponentProps: rest,\n        childWrapper: childWrapper,\n        childWrapperProps: childWrapperProps,\n        className: scrollableClasses,\n        componentCss: _ScrollableModule[\"default\"],\n        containerRef: this.containerRef,\n        handleScroll: this.handleScroll,\n        horizontalScrollbarProps: this.horizontalScrollbarProps,\n        initChildRef: this.initChildRef,\n        isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,\n        isVerticalScrollbarVisible: isVerticalScrollbarVisible,\n        rtl: rtl,\n        scrollTo: this.scrollTo,\n        style: style,\n        verticalScrollbarProps: this.verticalScrollbarProps\n      }));\n    }\n  }]);\n\n  return ScrollableBase;\n}(_react.Component);\n/**\n * An unstyled component that provides horizontal and vertical scrollbars and makes a render prop element scrollable.\n *\n * @class Scrollable\n * @memberof ui/Scrollable\n * @extends ui/Scrollable.ScrollableBase\n * @ui\n * @private\n */\n\n\nexports.ScrollableBase = ScrollableBase;\nScrollableBase.displayName = 'ui:ScrollableBase';\nScrollableBase.propTypes =\n/** @lends ui/Scrollable.Scrollable.prototype */\n{\n  /**\n   * Render function.\n   *\n   * @type {Function}\n   * @required\n   * @private\n   */\n  containerRenderer: _propTypes[\"default\"].func.isRequired,\n\n  /**\n   * Called when adding additional event listeners in a themed component.\n   *\n   * @type {Function}\n   * @private\n   */\n  addEventListeners: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component to show overscroll effect.\n   *\n   * @type {Function}\n   * @private\n   */\n  applyOverscrollEffect: _propTypes[\"default\"].func,\n\n  /**\n   * A callback function that receives a reference to the `scrollTo` feature.\n   *\n   * Once received, the `scrollTo` method can be called as an imperative interface.\n   *\n   * The `scrollTo` function accepts the following paramaters:\n   * - {position: {x, y}} - Pixel value for x and/or y position\n   * - {align} - Where the scroll area should be aligned. Values are:\n   *   `'left'`, `'right'`, `'top'`, `'bottom'`,\n   *   `'topleft'`, `'topright'`, `'bottomleft'`, and `'bottomright'`.\n   * - {index} - Index of specific item. (`0` or positive integer)\n   *   This option is available for only `VirtualList` kind.\n   * - {node} - Node to scroll into view\n   * - {animate} - When `true`, scroll occurs with animation. When `false`, no\n   *   animation occurs.\n   * - {focus} - When `true`, attempts to focus item after scroll. Only valid when scrolling\n   *   by `index` or `node`.\n   * > Note: Only specify one of: `position`, `align`, `index` or `node`\n   *\n   * Example:\n   * ```\n   *\t// If you set cbScrollTo prop like below;\n   *\tcbScrollTo: (fn) => {this.scrollTo = fn;}\n   *\t// You can simply call like below;\n   *\tthis.scrollTo({align: 'top'}); // scroll to the top\n   * ```\n   *\n   * @type {Function}\n   * @public\n   */\n  cbScrollTo: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component to clear overscroll effect.\n   *\n   * @type {Function}\n   * @private\n   */\n  clearOverscrollEffect: _propTypes[\"default\"].func,\n\n  /**\n   * Client size of the container; valid values are an object that has `clientWidth` and `clientHeight`.\n   *\n   * @type {Object}\n   * @property {Number}    clientHeight    The client height of the list.\n   * @property {Number}    clientWidth    The client width of the list.\n   * @public\n   */\n  clientSize: _propTypes[\"default\"].shape({\n    clientHeight: _propTypes[\"default\"].number.isRequired,\n    clientWidth: _propTypes[\"default\"].number.isRequired\n  }),\n\n  /**\n   * Direction of the list or the scroller.\n   *\n   * `'both'` could be only used for[Scroller]{@link ui/Scroller.Scroller}.\n   *\n   * Valid values are:\n   * * `'both'`,\n   * * `'horizontal'`, and\n   * * `'vertical'`.\n   *\n   * @type {String}\n   * @private\n   */\n  direction: _propTypes[\"default\"].oneOf(['both', 'horizontal', 'vertical']),\n\n  /**\n   * Specifies how to show horizontal scrollbar.\n   *\n   * Valid values are:\n   * * `'auto'`,\n   * * `'visible'`, and\n   * * `'hidden'`.\n   *\n   * @type {String}\n   * @default 'auto'\n   * @public\n   */\n  horizontalScrollbar: _propTypes[\"default\"].oneOf(['auto', 'visible', 'hidden']),\n\n  /**\n   * Prevents scroll by dragging or flicking on the list or the scroller.\n   *\n   * @type {Boolean}\n   * @default false\n   * @private\n   */\n  noScrollByDrag: _propTypes[\"default\"].bool,\n\n  /**\n   * Called when flicking with a mouse or a touch screen.\n   *\n   * @type {Function}\n   * @private\n   */\n  onFlick: _propTypes[\"default\"].func,\n\n  /**\n   * Called when pressing a key.\n   *\n   * @type {Function}\n   * @private\n   */\n  onKeyDown: _propTypes[\"default\"].func,\n\n  /**\n   * Called when trigerring a mousedown event.\n   *\n   * @type {Function}\n   * @private\n   */\n  onMouseDown: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scrolling.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * It is not recommended to set this prop since it can cause performance degradation.\n   * Use `onScrollStart` or `onScrollStop` instead.\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScroll: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scroll starts.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.\n   *\n   * Example:\n   * ```\n   * onScrollStart = ({scrollLeft, scrollTop, moreInfo}) => {\n   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;\n   *     // do something with firstVisibleIndex and lastVisibleIndex\n   * }\n   *\n   * render = () => (\n   *     <VirtualList\n   *         ...\n   *         onScrollStart={this.onScrollStart}\n   *         ...\n   *     />\n   * )\n   * ```\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScrollStart: _propTypes[\"default\"].func,\n\n  /**\n   * Called when scroll stops.\n   *\n   * Passes `scrollLeft`, `scrollTop`, and `moreInfo`.\n   * You can get firstVisibleIndex and lastVisibleIndex from VirtualList with `moreInfo`.\n   *\n   * Example:\n   * ```\n   * onScrollStop = ({scrollLeft, scrollTop, moreInfo}) => {\n   *     const {firstVisibleIndex, lastVisibleIndex} = moreInfo;\n   *     // do something with firstVisibleIndex and lastVisibleIndex\n   * }\n   *\n   * render = () => (\n   *     <VirtualList\n   *         ...\n   *         onScrollStop={this.onScrollStop}\n   *         ...\n   *     />\n   * )\n   * ```\n   *\n   * @type {Function}\n   * @param {Object} event\n   * @param {Number} event.scrollLeft Scroll left value.\n   * @param {Number} event.scrollTop Scroll top value.\n   * @param {Object} event.moreInfo The object including `firstVisibleIndex` and `lastVisibleIndex` properties.\n   * @public\n   */\n  onScrollStop: _propTypes[\"default\"].func,\n\n  /**\n   * Called when wheeling.\n   *\n   * @type {Function}\n   * @private\n   */\n  onWheel: _propTypes[\"default\"].func,\n\n  /**\n   * Specifies overscroll effects shows on which type of inputs.\n   *\n   * @type {Object}\n   * @default {drag: false, pageKey: false, wheel: false}\n   * @private\n   */\n  overscrollEffectOn: _propTypes[\"default\"].shape({\n    drag: _propTypes[\"default\"].bool,\n    pageKey: _propTypes[\"default\"].bool,\n    wheel: _propTypes[\"default\"].bool\n  }),\n\n  /**\n   * Called when removing additional event listeners in a themed component.\n   *\n   * @type {Function}\n   * @private\n   */\n  removeEventListeners: _propTypes[\"default\"].func,\n\n  /**\n   * Indicates the content's text direction is right-to-left.\n   *\n   * @type {Boolean}\n   * @private\n   */\n  rtl: _propTypes[\"default\"].bool,\n\n  /**\n   * Called to execute additional logic in a themed component when scrollTo is called.\n   *\n   * @type {Function}\n   * @private\n   */\n  scrollTo: _propTypes[\"default\"].func,\n\n  /**\n   * Called to execute additional logic in a themed component when scroll stops.\n   *\n   * @type {Function}\n   * @private\n   */\n  stop: _propTypes[\"default\"].func,\n\n  /**\n   * Scrollable CSS style.\n   *\n   * Should be defined because we manipulate style prop in render().\n   *\n   * @type {Object}\n   * @public\n   */\n  style: _propTypes[\"default\"].object,\n\n  /**\n   * Specifies how to show vertical scrollbar.\n   *\n   * Valid values are:\n   * * `'auto'`,\n   * * `'visible'`, and\n   * * `'hidden'`.\n   *\n   * @type {String}\n   * @default 'auto'\n   * @public\n   */\n  verticalScrollbar: _propTypes[\"default\"].oneOf(['auto', 'visible', 'hidden'])\n};\nScrollableBase.defaultProps = {\n  cbScrollTo: nop,\n  horizontalScrollbar: 'auto',\n  noScrollByDrag: false,\n  onScroll: nop,\n  onScrollStart: nop,\n  onScrollStop: nop,\n  overscrollEffectOn: {\n    drag: false,\n    pageKey: false,\n    wheel: false\n  },\n  verticalScrollbar: 'auto'\n};\nScrollableBase.contextType = _Resizable.ResizeContext;\n\nvar Scrollable =\n/*#__PURE__*/\nfunction (_Component2) {\n  _inherits(Scrollable, _Component2);\n\n  function Scrollable() {\n    _classCallCheck(this, Scrollable);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Scrollable).apply(this, arguments));\n  }\n\n  _createClass(Scrollable, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          childRenderer = _this$props4.childRenderer,\n          rest = _objectWithoutProperties(_this$props4, [\"childRenderer\"]);\n\n      return _react[\"default\"].createElement(ScrollableBase, Object.assign({}, rest, {\n        containerRenderer: function containerRenderer(_ref2) {\n          var childComponentProps = _ref2.childComponentProps,\n              ChildWrapper = _ref2.childWrapper,\n              childWrapperProps = _ref2.childWrapperProps,\n              containerRef = _ref2.containerRef,\n              className = _ref2.className,\n              componentCss = _ref2.componentCss,\n              handleScroll = _ref2.handleScroll,\n              horizontalScrollbarProps = _ref2.horizontalScrollbarProps,\n              initChildRef = _ref2.initChildRef,\n              isHorizontalScrollbarVisible = _ref2.isHorizontalScrollbarVisible,\n              isVerticalScrollbarVisible = _ref2.isVerticalScrollbarVisible,\n              rtl = _ref2.rtl,\n              scrollTo = _ref2.scrollTo,\n              style = _ref2.style,\n              verticalScrollbarProps = _ref2.verticalScrollbarProps;\n          return _react[\"default\"].createElement(\"div\", {\n            className: className,\n            ref: containerRef,\n            style: style\n          }, _react[\"default\"].createElement(\"div\", {\n            className: componentCss.container\n          }, _react[\"default\"].createElement(ChildWrapper, childWrapperProps, childRenderer(_objectSpread({}, childComponentProps, {\n            cbScrollTo: scrollTo,\n            className: componentCss.scrollableFill,\n            initChildRef: initChildRef,\n            onScroll: handleScroll,\n            rtl: rtl\n          }))), isVerticalScrollbarVisible ? _react[\"default\"].createElement(_Scrollbar[\"default\"], Object.assign({}, verticalScrollbarProps, {\n            disabled: !isVerticalScrollbarVisible\n          })) : null), isHorizontalScrollbarVisible ? _react[\"default\"].createElement(_Scrollbar[\"default\"], Object.assign({}, horizontalScrollbarProps, {\n            corner: isVerticalScrollbarVisible,\n            disabled: !isHorizontalScrollbarVisible\n          })) : null);\n        }\n      }));\n    }\n  }]);\n\n  return Scrollable;\n}(_react.Component);\n\nexports.Scrollable = Scrollable;\nScrollable.displayName = 'ui:Scrollable';\nScrollable.propTypes =\n/** @lends ui/Scrollable.Scrollable.prototype */\n{\n  /**\n   * Render function.\n   *\n   * @type {Function}\n   * @required\n   * @private\n   */\n  childRenderer: _propTypes[\"default\"].func.isRequired\n};\nvar _default = Scrollable;\nexports[\"default\"] = _default;"]},"metadata":{},"sourceType":"module"}