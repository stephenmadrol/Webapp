{"ast":null,"code":"\"use strict\";\n/*\n * MathUtils.js - Misc math utility routines\n *\n * Copyright © 2013-2015, 2018 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar MathUtils = {};\n/**\n * Return the sign of the given number. If the sign is negative, this function\n * returns -1. If the sign is positive or zero, this function returns 1.\n * @static\n * @param {number} num the number to test\n * @return {number} -1 if the number is negative, and 1 otherwise\n */\n\nMathUtils.signum = function (num) {\n  var n = num;\n\n  if (typeof num === 'string') {\n    n = parseInt(num, 10);\n  } else if (typeof num !== 'number') {\n    return 1;\n  }\n\n  return n < 0 ? -1 : 1;\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.floor = function (num) {\n  return Math.floor(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.ceiling = function (num) {\n  return Math.ceil(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.down = function (num) {\n  return num < 0 ? Math.ceil(num) : Math.floor(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.up = function (num) {\n  return num < 0 ? Math.floor(num) : Math.ceil(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfup = function (num) {\n  return num < 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfdown = function (num) {\n  return num < 0 ? Math.floor(num + 0.5) : Math.ceil(num - 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfeven = function (num) {\n  return Math.floor(num) % 2 === 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfodd = function (num) {\n  return Math.floor(num) % 2 !== 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * Do a proper modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range [0, modulus).<p>\n *\n *\n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.\n */\n\n\nMathUtils.mod = function (dividend, modulus) {\n  if (modulus == 0) {\n    return 0;\n  }\n\n  var x = dividend % modulus;\n  return x < 0 ? x + modulus : x;\n};\n/**\n * Do a proper adjusted modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range (0, modulus]. The adjusted\n * modulo function differs from the regular modulo function in that when the remainder is\n * zero, the modulus should be returned instead.<p>\n *\n *\n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.\n */\n\n\nMathUtils.amod = function (dividend, modulus) {\n  if (modulus == 0) {\n    return 0;\n  }\n\n  var x = dividend % modulus;\n  return x <= 0 ? x + modulus : x;\n};\n/**\n * Return the number with the decimal shifted by the given precision.\n * Positive precisions shift the decimal to the right giving larger\n * numbers, and negative ones shift the decimal to the left giving\n * smaller numbers.\n *\n * @static\n * @param {number} number the number to shift\n * @param {number} precision the number of places to move the decimal point\n * @returns {number} the number with the decimal point shifted by the\n * given number of decimals\n */\n\n\nMathUtils.shiftDecimal = function shift(number, precision) {\n  var numArray = (\"\" + number).split(\"e\");\n  return +(numArray[0] + \"e\" + (numArray[1] ? +numArray[1] + precision : precision));\n};\n/**\n * Returns the base 10 logarithm of a number. For platforms that support\n * Math.log10() it is used directly. For plaforms that do not, such as Qt/QML,\n * it will be calculated using the natural logarithm.\n *\n * @param {number} num the number to take the logarithm of\n * @returns {number} the base-10 logarithm of the given number\n */\n\n\nMathUtils.log10 = function (num) {\n  if (typeof Math.log10 === \"function\") {\n    return Math.log10(num);\n  }\n\n  return Math.log(num) / Math.LN10;\n};\n/**\n * Return the given number with only the given number of significant digits.\n * The number of significant digits can start with the digits greater than\n * 1 and straddle the decimal point, or it may start after the decimal point.\n * If the number of digits requested is less than 1, the original number\n * will be returned unchanged.\n *\n * @static\n * @param {number} number the number to return with only significant digits\n * @param {number} digits the number of significant digits to include in the\n * returned number\n * @param {function(number): number=} round a rounding function to use\n * @returns {number} the given number with only the requested number of\n * significant digits\n */\n\n\nMathUtils.significant = function (number, digits, round) {\n  if (digits < 1 || number === 0) return number;\n  var rnd = round || Math.round;\n  var factor = -Math.floor(MathUtils.log10(Math.abs(number))) + digits - 1;\n  return MathUtils.shiftDecimal(rnd(MathUtils.shiftDecimal(number, factor)), -factor);\n};\n\nmodule.exports = MathUtils;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteAPp\\node_modules\\@enact\\i18n\\ilib\\lib\\MathUtils.js"],"names":["MathUtils","signum","num","n","parseInt","floor","Math","ceiling","ceil","down","up","halfup","halfdown","halfeven","halfodd","mod","dividend","modulus","x","amod","shiftDecimal","shift","number","precision","numArray","split","log10","log","LN10","significant","digits","round","rnd","factor","abs","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * MathUtils.js - Misc math utility routines\n *\n * Copyright © 2013-2015, 2018 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MathUtils = {};\n/**\n * Return the sign of the given number. If the sign is negative, this function\n * returns -1. If the sign is positive or zero, this function returns 1.\n * @static\n * @param {number} num the number to test\n * @return {number} -1 if the number is negative, and 1 otherwise\n */\n\nMathUtils.signum = function (num) {\n  var n = num;\n\n  if (typeof num === 'string') {\n    n = parseInt(num, 10);\n  } else if (typeof num !== 'number') {\n    return 1;\n  }\n\n  return n < 0 ? -1 : 1;\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.floor = function (num) {\n  return Math.floor(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.ceiling = function (num) {\n  return Math.ceil(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.down = function (num) {\n  return num < 0 ? Math.ceil(num) : Math.floor(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.up = function (num) {\n  return num < 0 ? Math.floor(num) : Math.ceil(num);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfup = function (num) {\n  return num < 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfdown = function (num) {\n  return num < 0 ? Math.floor(num + 0.5) : Math.ceil(num - 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfeven = function (num) {\n  return Math.floor(num) % 2 === 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * @static\n * @protected\n * @param {number} num number to round\n * @return {number} rounded number\n */\n\n\nMathUtils.halfodd = function (num) {\n  return Math.floor(num) % 2 !== 0 ? Math.ceil(num - 0.5) : Math.floor(num + 0.5);\n};\n/**\n * Do a proper modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range [0, modulus).<p>\n *\n *\n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.\n */\n\n\nMathUtils.mod = function (dividend, modulus) {\n  if (modulus == 0) {\n    return 0;\n  }\n\n  var x = dividend % modulus;\n  return x < 0 ? x + modulus : x;\n};\n/**\n * Do a proper adjusted modulo function. The Javascript % operator will give the truncated\n * division algorithm, but for calendrical calculations, we need the Euclidean\n * division algorithm where the remainder of any division, whether the dividend\n * is negative or not, is always a positive number in the range (0, modulus]. The adjusted\n * modulo function differs from the regular modulo function in that when the remainder is\n * zero, the modulus should be returned instead.<p>\n *\n *\n * @static\n * @param {number} dividend the number being divided\n * @param {number} modulus the number dividing the dividend. This should always be a positive number.\n * @return the remainder of dividing the dividend by the modulus.\n */\n\n\nMathUtils.amod = function (dividend, modulus) {\n  if (modulus == 0) {\n    return 0;\n  }\n\n  var x = dividend % modulus;\n  return x <= 0 ? x + modulus : x;\n};\n/**\n * Return the number with the decimal shifted by the given precision.\n * Positive precisions shift the decimal to the right giving larger\n * numbers, and negative ones shift the decimal to the left giving\n * smaller numbers.\n *\n * @static\n * @param {number} number the number to shift\n * @param {number} precision the number of places to move the decimal point\n * @returns {number} the number with the decimal point shifted by the\n * given number of decimals\n */\n\n\nMathUtils.shiftDecimal = function shift(number, precision) {\n  var numArray = (\"\" + number).split(\"e\");\n  return +(numArray[0] + \"e\" + (numArray[1] ? +numArray[1] + precision : precision));\n};\n/**\n * Returns the base 10 logarithm of a number. For platforms that support\n * Math.log10() it is used directly. For plaforms that do not, such as Qt/QML,\n * it will be calculated using the natural logarithm.\n *\n * @param {number} num the number to take the logarithm of\n * @returns {number} the base-10 logarithm of the given number\n */\n\n\nMathUtils.log10 = function (num) {\n  if (typeof Math.log10 === \"function\") {\n    return Math.log10(num);\n  }\n\n  return Math.log(num) / Math.LN10;\n};\n/**\n * Return the given number with only the given number of significant digits.\n * The number of significant digits can start with the digits greater than\n * 1 and straddle the decimal point, or it may start after the decimal point.\n * If the number of digits requested is less than 1, the original number\n * will be returned unchanged.\n *\n * @static\n * @param {number} number the number to return with only significant digits\n * @param {number} digits the number of significant digits to include in the\n * returned number\n * @param {function(number): number=} round a rounding function to use\n * @returns {number} the given number with only the requested number of\n * significant digits\n */\n\n\nMathUtils.significant = function (number, digits, round) {\n  if (digits < 1 || number === 0) return number;\n  var rnd = round || Math.round;\n  var factor = -Math.floor(MathUtils.log10(Math.abs(number))) + digits - 1;\n  return MathUtils.shiftDecimal(rnd(MathUtils.shiftDecimal(number, factor)), -factor);\n};\n\nmodule.exports = MathUtils;"]},"metadata":{},"sourceType":"module"}