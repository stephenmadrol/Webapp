{"ast":null,"code":"\"use strict\";\n/*\n * packedbuffer.js - represent a packed buffer of bytes\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Represents a binary buffer of unsigned bytes that will be parsed in various ways. The buffer\n * can be decoded by reading various lengths of bytes and interpreting them as longs\n * or unsigned bytes, etc. The bytes are interpreted in big-endian (network) format.\n * @constructor\n * @param {string} buffer the binary buffer represented as a string\n */\n\nvar PackedBuffer = function PackedBuffer(buffer) {\n  this.buffer = buffer;\n  this.index = 0;\n};\n/**\n * Return the specified number of signed long integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many longs as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of longs to return\n * @returns {Array.<number>} the array of signed long integers\n */\n\n\nPackedBuffer.prototype.getLongs = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index + 3 < this.buffer.length; i++) {\n      var longnum = this.buffer[this.index] << 24 | this.buffer[this.index + 1] << 16 | this.buffer[this.index + 2] << 8 | this.buffer[this.index + 3];\n      result.push(longnum);\n      this.index += 4;\n    }\n  }\n\n  return result;\n};\n/**\n * Return a signed long integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a long if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the long at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a long\n */\n\n\nPackedBuffer.prototype.getLong = function () {\n  var longs = this.getLongs(1);\n\n  if (longs && longs.length > 0) {\n    return longs[0];\n  }\n};\n/**\n * Return the specified number of signed byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number|undefined} num The number of bytes to return\n * @returns {Array.<number>} the array of signed byte integers\n */\n\n\nPackedBuffer.prototype.getBytes = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      var bytenum = this.buffer[this.index++];\n\n      if (bytenum & 0x80) {\n        bytenum -= 0x100;\n      }\n\n      result.push(bytenum);\n    }\n  }\n\n  return result;\n};\n/**\n * Return a signed byte integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a byte if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the byte at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a byte\n */\n\n\nPackedBuffer.prototype.getByte = function () {\n  var bytes = this.getBytes(1);\n\n  if (bytes && bytes.length > 0) {\n    return bytes[0];\n  }\n};\n/**\n * Return the specified number of unsigned byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of bytes to return\n * @returns {Array.<number>} the array of unsigned byte integers\n */\n\n\nPackedBuffer.prototype.getUnsignedBytes = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      result.push(this.buffer[this.index++]);\n    }\n  }\n\n  return result;\n};\n/**\n * Return a string made out of the given number of bytes and convert\n * from UTF-8 to UTF-16.\n *\n * @param {number} num The number of bytes to make a string out of\n * @returns {string} a string made out of the given bytes\n */\n\n\nPackedBuffer.prototype.getString = function (num) {\n  var arr = this.getUnsignedBytes(num);\n  var str = '';\n\n  for (var i = 0; i < arr.length; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n\n  return str;\n};\n/**\n * Advance the current pointer in the buffer by the specified number of\n * bytes in the string.\n *\n * @param {number} num The number of bytes to skip\n * @returns {void}\n */\n\n\nPackedBuffer.prototype.skip = function (num) {\n  this.index += num;\n};\n\nmodule.exports = PackedBuffer;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/i18n/src/packedbuffer.js"],"names":["PackedBuffer","buffer","index","prototype","getLongs","num","result","length","i","longnum","push","getLong","longs","getBytes","bytenum","getByte","bytes","getUnsignedBytes","getString","arr","str","String","fromCharCode","skip","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * packedbuffer.js - represent a packed buffer of bytes\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Represents a binary buffer of unsigned bytes that will be parsed in various ways. The buffer\n * can be decoded by reading various lengths of bytes and interpreting them as longs\n * or unsigned bytes, etc. The bytes are interpreted in big-endian (network) format.\n * @constructor\n * @param {string} buffer the binary buffer represented as a string\n */\nvar PackedBuffer = function PackedBuffer(buffer) {\n  this.buffer = buffer;\n  this.index = 0;\n};\n/**\n * Return the specified number of signed long integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many longs as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of longs to return\n * @returns {Array.<number>} the array of signed long integers\n */\n\n\nPackedBuffer.prototype.getLongs = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index + 3 < this.buffer.length; i++) {\n      var longnum = this.buffer[this.index] << 24 | this.buffer[this.index + 1] << 16 | this.buffer[this.index + 2] << 8 | this.buffer[this.index + 3];\n      result.push(longnum);\n      this.index += 4;\n    }\n  }\n\n  return result;\n};\n/**\n * Return a signed long integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a long if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the long at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a long\n */\n\n\nPackedBuffer.prototype.getLong = function () {\n  var longs = this.getLongs(1);\n\n  if (longs && longs.length > 0) {\n    return longs[0];\n  }\n};\n/**\n * Return the specified number of signed byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number|undefined} num The number of bytes to return\n * @returns {Array.<number>} the array of signed byte integers\n */\n\n\nPackedBuffer.prototype.getBytes = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      var bytenum = this.buffer[this.index++];\n\n      if (bytenum & 0x80) {\n        bytenum -= 0x100;\n      }\n\n      result.push(bytenum);\n    }\n  }\n\n  return result;\n};\n/**\n * Return a signed byte integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a byte if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the byte at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a byte\n */\n\n\nPackedBuffer.prototype.getByte = function () {\n  var bytes = this.getBytes(1);\n\n  if (bytes && bytes.length > 0) {\n    return bytes[0];\n  }\n};\n/**\n * Return the specified number of unsigned byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of bytes to return\n * @returns {Array.<number>} the array of unsigned byte integers\n */\n\n\nPackedBuffer.prototype.getUnsignedBytes = function (num) {\n  var result;\n\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      result.push(this.buffer[this.index++]);\n    }\n  }\n\n  return result;\n};\n/**\n * Return a string made out of the given number of bytes and convert\n * from UTF-8 to UTF-16.\n *\n * @param {number} num The number of bytes to make a string out of\n * @returns {string} a string made out of the given bytes\n */\n\n\nPackedBuffer.prototype.getString = function (num) {\n  var arr = this.getUnsignedBytes(num);\n  var str = '';\n\n  for (var i = 0; i < arr.length; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n\n  return str;\n};\n/**\n * Advance the current pointer in the buffer by the specified number of\n * bytes in the string.\n *\n * @param {number} num The number of bytes to skip\n * @returns {void}\n */\n\n\nPackedBuffer.prototype.skip = function (num) {\n  this.index += num;\n};\n\nmodule.exports = PackedBuffer;"]},"metadata":{},"sourceType":"module"}