{"ast":null,"code":"\"use strict\";\n/*\n * han.js - Represent a Han Chinese Lunar calendar object.\n * \n * Copyright © 2014-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends \nilib.js \nCalendar.js \nMathUtils.js \nAstro.js\nGregorianDate.js\nGregRataDie.js\nRataDie.js\n*/\n\nvar ilib = require(\"./ilib.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar Astro = require(\"./Astro.js\");\n\nvar RataDie = require(\"./RataDie.js\");\n\nvar GregorianDate = require(\"./GregorianDate.js\");\n\nvar GregRataDie = require(\"./GregRataDie.js\");\n/**\n * @class\n * Construct a new Han algorithmic calendar object. This class encodes information about\n * a Han algorithmic calendar.<p>\n * \n * \n * @constructor\n * @param {Object=} params optional parameters to load the calendrical data\n * @extends Calendar\n */\n\n\nvar HanCal = function HanCal(params) {\n  this.type = \"han\";\n  var sync = params && typeof params.sync === 'boolean' ? params.sync : true;\n  Astro.initAstro(sync, params && params.loadParams, ilib.bind(this, function (x) {\n    if (params && typeof params.onLoad === 'function') {\n      params.onLoad(this);\n    }\n  }));\n};\n/**\n * @protected\n * @static\n * @param {number} year\n * @param {number=} cycle\n * @return {number}\n */\n\n\nHanCal._getElapsedYear = function (year, cycle) {\n  var elapsedYear = year || 0;\n\n  if (typeof year !== 'undefined' && year < 61 && typeof cycle !== 'undefined') {\n    elapsedYear = 60 * cycle + year;\n  }\n\n  return elapsedYear;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @param {number} longitude longitude to seek \n * @returns {number} the julian day of the next time that the solar longitude \n * is a multiple of the given longitude\n */\n\n\nHanCal._hanNextSolarLongitude = function (jd, longitude) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var sol = Astro._nextSolarLongitude(uni, longitude);\n\n  return Astro._localFromUniversal(sol, tz);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the major solar term for the julian day\n */\n\n\nHanCal._majorSTOnOrAfter = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var next = Astro._fixangle(30 * Math.ceil(Astro._solarLongitude(uni) / 30));\n\n  return HanCal._hanNextSolarLongitude(jd, next);\n};\n/**\n * @protected\n * @static\n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n */\n\n\nHanCal._solsticeBefore = function (year, cycle) {\n  var elapsedYear = HanCal._getElapsedYear(year, cycle);\n\n  var gregyear = elapsedYear - 2697;\n  var rd = new GregRataDie({\n    year: gregyear - 1,\n    month: 12,\n    day: 15,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  });\n  return HanCal._majorSTOnOrAfter(rd.getRataDie() + RataDie.gregorianEpoch);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {number} the current major solar term\n */\n\n\nHanCal._chineseTZ = function (jd) {\n  var year = GregorianDate._calcYear(jd - RataDie.gregorianEpoch);\n\n  return year < 1929 ? 465.6666666666666666 : 480;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the julian day of next new moon on or after the given julian day date\n */\n\n\nHanCal._newMoonOnOrAfter = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var moon = Astro._newMoonAtOrAfter(uni); // floor to the start of the julian day\n\n\n  return Astro._floorToJD(Astro._localFromUniversal(moon, tz));\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the julian day of previous new moon before the given julian day date\n */\n\n\nHanCal._newMoonBefore = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var moon = Astro._newMoonBefore(uni); // floor to the start of the julian day\n\n\n  return Astro._floorToJD(Astro._localFromUniversal(moon, tz));\n};\n/**\n * @static\n * @protected\n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n */\n\n\nHanCal._leapYearCalc = function (year, cycle) {\n  var ret = {\n    elapsedYear: HanCal._getElapsedYear(year, cycle)\n  };\n  ret.solstice1 = HanCal._solsticeBefore(ret.elapsedYear);\n  ret.solstice2 = HanCal._solsticeBefore(ret.elapsedYear + 1); // ceil to the end of the julian day\n\n  ret.m1 = HanCal._newMoonOnOrAfter(Astro._ceilToJD(ret.solstice1));\n  ret.m2 = HanCal._newMoonBefore(Astro._ceilToJD(ret.solstice2));\n  return ret;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {number} the current major solar term\n */\n\n\nHanCal._currentMajorST = function (jd) {\n  var s = Astro._solarLongitude(Astro._universalFromLocal(jd, HanCal._chineseTZ(jd)));\n\n  return MathUtils.amod(2 + Math.floor(s / 30), 12);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {boolean} true if there is no major solar term in the same year\n */\n\n\nHanCal._noMajorST = function (jd) {\n  return HanCal._currentMajorST(jd) === HanCal._currentMajorST(HanCal._newMoonOnOrAfter(jd + 1));\n};\n/**\n * Return the number of months in the given year. The number of months in a year varies\n * for some luni-solar calendars because in some years, an extra month is needed to extend the \n * days in a year to an entire solar year. The month is represented as a 1-based number\n * where 1=first month, 2=second month, etc.\n * \n * @param {number} year a year for which the number of months is sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} The number of months in the given year\n */\n\n\nHanCal.prototype.getNumMonths = function (year, cycle) {\n  return this.isLeapYear(year, cycle) ? 13 : 12;\n};\n/**\n * Return the number of days in a particular month in a particular year. This function\n * can return a different number for a month depending on the year because of things\n * like leap years.\n * \n * @param {number} month the elapsed month for which the length is sought\n * @param {number} year the elapsed year within which that month can be found\n * @return {number} the number of days within the given month in the given year\n */\n\n\nHanCal.prototype.getMonLength = function (month, year) {\n  // distance between two new moons in Nanjing China\n  var calc = HanCal._leapYearCalc(year);\n\n  var priorNewMoon = HanCal._newMoonOnOrAfter(calc.m1 + month * 29);\n\n  var postNewMoon = HanCal._newMoonOnOrAfter(priorNewMoon + 1);\n\n  return postNewMoon - priorNewMoon;\n};\n/**\n * Return the equivalent year in the 2820 year cycle that begins on \n * Far 1, 474. This particular cycle obeys the cycle-of-years formula \n * whereas the others do not specifically. This cycle can be used as\n * a proxy for other years outside of the cycle by shifting them into \n * the cycle.   \n * @param {number} year year to find the equivalent cycle year for\n * @returns {number} the equivalent cycle year\n */\n\n\nHanCal.prototype.equivalentCycleYear = function (year) {\n  var y = year - (year >= 0 ? 474 : 473);\n  return MathUtils.mod(y, 2820) + 474;\n};\n/**\n * Return true if the given year is a leap year in the Han calendar.\n * If the year is given as a year/cycle combination, then the year should be in the \n * range [1,60] and the given cycle is the cycle in which the year is located. If \n * the year is greater than 60, then\n * it represents the total number of years elapsed in the proleptic calendar since\n * the beginning of the Chinese epoch in on 15 Feb, -2636 (Gregorian). In this \n * case, the cycle parameter is ignored.\n * \n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {boolean} true if the given year is a leap year\n */\n\n\nHanCal.prototype.isLeapYear = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  return Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n};\n/**\n * Return the month of the year that is the leap month. If the given year is\n * not a leap year, then this method will return -1.\n * \n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} the number of the month that is doubled in this leap year, or -1\n * if this is not a leap year\n */\n\n\nHanCal.prototype.getLeapMonth = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  if (Math.round((calc.m2 - calc.m1) / 29.530588853000001) != 12) {\n    return -1; // no leap month\n  } // search between rd1 and rd2 for the first month with no major solar term. That is our leap month.\n\n\n  var month = 0;\n\n  var m = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  while (!HanCal._noMajorST(m)) {\n    month++;\n    m = HanCal._newMoonOnOrAfter(m + 1);\n  } // return the number of the month that is doubled\n\n\n  return month;\n};\n/**\n * Return the date of Chinese New Years in the given calendar year.\n * \n * @param {number} year the Chinese year for which the new year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} the julian day of the beginning of the given year \n */\n\n\nHanCal.prototype.newYears = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  if (Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12 && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2))) {\n    return HanCal._newMoonOnOrAfter(m2 + 1);\n  }\n\n  return m2;\n};\n/**\n * Return the type of this calendar.\n * \n * @return {string} the name of the type of this calendar \n */\n\n\nHanCal.prototype.getType = function () {\n  return this.type;\n};\n/* register this calendar for the factory method */\n\n\nCalendar._constructors[\"han\"] = HanCal;\nmodule.exports = HanCal;","map":{"version":3,"sources":["/home/cdi/final/SteApp/node_modules/@enact/i18n/ilib/lib/HanCal.js"],"names":["ilib","require","MathUtils","Calendar","Astro","RataDie","GregorianDate","GregRataDie","HanCal","params","type","sync","initAstro","loadParams","bind","x","onLoad","_getElapsedYear","year","cycle","elapsedYear","_hanNextSolarLongitude","jd","longitude","tz","_chineseTZ","uni","_universalFromLocal","sol","_nextSolarLongitude","_localFromUniversal","_majorSTOnOrAfter","next","_fixangle","Math","ceil","_solarLongitude","_solsticeBefore","gregyear","rd","month","day","hour","minute","second","millisecond","getRataDie","gregorianEpoch","_calcYear","_newMoonOnOrAfter","moon","_newMoonAtOrAfter","_floorToJD","_newMoonBefore","_leapYearCalc","ret","solstice1","solstice2","m1","_ceilToJD","m2","_currentMajorST","s","amod","floor","_noMajorST","prototype","getNumMonths","isLeapYear","getMonLength","calc","priorNewMoon","postNewMoon","equivalentCycleYear","y","mod","round","getLeapMonth","m","newYears","getType","_constructors","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * han.js - Represent a Han Chinese Lunar calendar object.\n * \n * Copyright © 2014-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends \nilib.js \nCalendar.js \nMathUtils.js \nAstro.js\nGregorianDate.js\nGregRataDie.js\nRataDie.js\n*/\nvar ilib = require(\"./ilib.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar Astro = require(\"./Astro.js\");\n\nvar RataDie = require(\"./RataDie.js\");\n\nvar GregorianDate = require(\"./GregorianDate.js\");\n\nvar GregRataDie = require(\"./GregRataDie.js\");\n/**\n * @class\n * Construct a new Han algorithmic calendar object. This class encodes information about\n * a Han algorithmic calendar.<p>\n * \n * \n * @constructor\n * @param {Object=} params optional parameters to load the calendrical data\n * @extends Calendar\n */\n\n\nvar HanCal = function HanCal(params) {\n  this.type = \"han\";\n  var sync = params && typeof params.sync === 'boolean' ? params.sync : true;\n  Astro.initAstro(sync, params && params.loadParams, ilib.bind(this, function (x) {\n    if (params && typeof params.onLoad === 'function') {\n      params.onLoad(this);\n    }\n  }));\n};\n/**\n * @protected\n * @static\n * @param {number} year\n * @param {number=} cycle\n * @return {number}\n */\n\n\nHanCal._getElapsedYear = function (year, cycle) {\n  var elapsedYear = year || 0;\n\n  if (typeof year !== 'undefined' && year < 61 && typeof cycle !== 'undefined') {\n    elapsedYear = 60 * cycle + year;\n  }\n\n  return elapsedYear;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @param {number} longitude longitude to seek \n * @returns {number} the julian day of the next time that the solar longitude \n * is a multiple of the given longitude\n */\n\n\nHanCal._hanNextSolarLongitude = function (jd, longitude) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var sol = Astro._nextSolarLongitude(uni, longitude);\n\n  return Astro._localFromUniversal(sol, tz);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the major solar term for the julian day\n */\n\n\nHanCal._majorSTOnOrAfter = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var next = Astro._fixangle(30 * Math.ceil(Astro._solarLongitude(uni) / 30));\n\n  return HanCal._hanNextSolarLongitude(jd, next);\n};\n/**\n * @protected\n * @static\n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n */\n\n\nHanCal._solsticeBefore = function (year, cycle) {\n  var elapsedYear = HanCal._getElapsedYear(year, cycle);\n\n  var gregyear = elapsedYear - 2697;\n  var rd = new GregRataDie({\n    year: gregyear - 1,\n    month: 12,\n    day: 15,\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  });\n  return HanCal._majorSTOnOrAfter(rd.getRataDie() + RataDie.gregorianEpoch);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {number} the current major solar term\n */\n\n\nHanCal._chineseTZ = function (jd) {\n  var year = GregorianDate._calcYear(jd - RataDie.gregorianEpoch);\n\n  return year < 1929 ? 465.6666666666666666 : 480;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the julian day of next new moon on or after the given julian day date\n */\n\n\nHanCal._newMoonOnOrAfter = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var moon = Astro._newMoonAtOrAfter(uni); // floor to the start of the julian day\n\n\n  return Astro._floorToJD(Astro._localFromUniversal(moon, tz));\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from \n * @returns {number} the julian day of previous new moon before the given julian day date\n */\n\n\nHanCal._newMoonBefore = function (jd) {\n  var tz = HanCal._chineseTZ(jd);\n\n  var uni = Astro._universalFromLocal(jd, tz);\n\n  var moon = Astro._newMoonBefore(uni); // floor to the start of the julian day\n\n\n  return Astro._floorToJD(Astro._localFromUniversal(moon, tz));\n};\n/**\n * @static\n * @protected\n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n */\n\n\nHanCal._leapYearCalc = function (year, cycle) {\n  var ret = {\n    elapsedYear: HanCal._getElapsedYear(year, cycle)\n  };\n  ret.solstice1 = HanCal._solsticeBefore(ret.elapsedYear);\n  ret.solstice2 = HanCal._solsticeBefore(ret.elapsedYear + 1); // ceil to the end of the julian day\n\n  ret.m1 = HanCal._newMoonOnOrAfter(Astro._ceilToJD(ret.solstice1));\n  ret.m2 = HanCal._newMoonBefore(Astro._ceilToJD(ret.solstice2));\n  return ret;\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {number} the current major solar term\n */\n\n\nHanCal._currentMajorST = function (jd) {\n  var s = Astro._solarLongitude(Astro._universalFromLocal(jd, HanCal._chineseTZ(jd)));\n\n  return MathUtils.amod(2 + Math.floor(s / 30), 12);\n};\n/**\n * @protected\n * @static\n * @param {number} jd julian day to calculate from\n * @returns {boolean} true if there is no major solar term in the same year\n */\n\n\nHanCal._noMajorST = function (jd) {\n  return HanCal._currentMajorST(jd) === HanCal._currentMajorST(HanCal._newMoonOnOrAfter(jd + 1));\n};\n/**\n * Return the number of months in the given year. The number of months in a year varies\n * for some luni-solar calendars because in some years, an extra month is needed to extend the \n * days in a year to an entire solar year. The month is represented as a 1-based number\n * where 1=first month, 2=second month, etc.\n * \n * @param {number} year a year for which the number of months is sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} The number of months in the given year\n */\n\n\nHanCal.prototype.getNumMonths = function (year, cycle) {\n  return this.isLeapYear(year, cycle) ? 13 : 12;\n};\n/**\n * Return the number of days in a particular month in a particular year. This function\n * can return a different number for a month depending on the year because of things\n * like leap years.\n * \n * @param {number} month the elapsed month for which the length is sought\n * @param {number} year the elapsed year within which that month can be found\n * @return {number} the number of days within the given month in the given year\n */\n\n\nHanCal.prototype.getMonLength = function (month, year) {\n  // distance between two new moons in Nanjing China\n  var calc = HanCal._leapYearCalc(year);\n\n  var priorNewMoon = HanCal._newMoonOnOrAfter(calc.m1 + month * 29);\n\n  var postNewMoon = HanCal._newMoonOnOrAfter(priorNewMoon + 1);\n\n  return postNewMoon - priorNewMoon;\n};\n/**\n * Return the equivalent year in the 2820 year cycle that begins on \n * Far 1, 474. This particular cycle obeys the cycle-of-years formula \n * whereas the others do not specifically. This cycle can be used as\n * a proxy for other years outside of the cycle by shifting them into \n * the cycle.   \n * @param {number} year year to find the equivalent cycle year for\n * @returns {number} the equivalent cycle year\n */\n\n\nHanCal.prototype.equivalentCycleYear = function (year) {\n  var y = year - (year >= 0 ? 474 : 473);\n  return MathUtils.mod(y, 2820) + 474;\n};\n/**\n * Return true if the given year is a leap year in the Han calendar.\n * If the year is given as a year/cycle combination, then the year should be in the \n * range [1,60] and the given cycle is the cycle in which the year is located. If \n * the year is greater than 60, then\n * it represents the total number of years elapsed in the proleptic calendar since\n * the beginning of the Chinese epoch in on 15 Feb, -2636 (Gregorian). In this \n * case, the cycle parameter is ignored.\n * \n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {boolean} true if the given year is a leap year\n */\n\n\nHanCal.prototype.isLeapYear = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  return Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12;\n};\n/**\n * Return the month of the year that is the leap month. If the given year is\n * not a leap year, then this method will return -1.\n * \n * @param {number} year the year for which the leap year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} the number of the month that is doubled in this leap year, or -1\n * if this is not a leap year\n */\n\n\nHanCal.prototype.getLeapMonth = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  if (Math.round((calc.m2 - calc.m1) / 29.530588853000001) != 12) {\n    return -1; // no leap month\n  } // search between rd1 and rd2 for the first month with no major solar term. That is our leap month.\n\n\n  var month = 0;\n\n  var m = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  while (!HanCal._noMajorST(m)) {\n    month++;\n    m = HanCal._newMoonOnOrAfter(m + 1);\n  } // return the number of the month that is doubled\n\n\n  return month;\n};\n/**\n * Return the date of Chinese New Years in the given calendar year.\n * \n * @param {number} year the Chinese year for which the new year information is being sought\n * @param {number=} cycle if the given year < 60, this can specify the cycle. If the\n * cycle is not given, then the year should be given as elapsed years since the beginning\n * of the epoch\n * @return {number} the julian day of the beginning of the given year \n */\n\n\nHanCal.prototype.newYears = function (year, cycle) {\n  var calc = HanCal._leapYearCalc(year, cycle);\n\n  var m2 = HanCal._newMoonOnOrAfter(calc.m1 + 1);\n\n  if (Math.round((calc.m2 - calc.m1) / 29.530588853000001) === 12 && (HanCal._noMajorST(calc.m1) || HanCal._noMajorST(m2))) {\n    return HanCal._newMoonOnOrAfter(m2 + 1);\n  }\n\n  return m2;\n};\n/**\n * Return the type of this calendar.\n * \n * @return {string} the name of the type of this calendar \n */\n\n\nHanCal.prototype.getType = function () {\n  return this.type;\n};\n/* register this calendar for the factory method */\n\n\nCalendar._constructors[\"han\"] = HanCal;\nmodule.exports = HanCal;"]},"metadata":{},"sourceType":"module"}