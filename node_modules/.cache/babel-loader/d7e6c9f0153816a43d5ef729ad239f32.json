{"ast":null,"code":"\"use strict\";\n/*\n * HebrewDate.js - Represent a date in the Hebrew calendar\n *\n * Copyright © 2012-2015, 2018, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends\nilib.js\nLocale.js\nLocaleInfo.js\nTimeZone.js\nIDate.js\nMathUtils.js\nCalendar.js\nHebrewCal.js\nHebrewRataDie.js\n*/\n\nvar ilib = require(\"./ilib.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IDate = require(\"./IDate.js\");\n\nvar TimeZone = require(\"./TimeZone.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar HebrewCal = require(\"./HebrewCal.js\");\n\nvar HebrewRataDie = require(\"./HebrewRataDie.js\");\n/**\n * @class\n * Construct a new civil Hebrew date object. The constructor can be called\n * with a params object that can contain the following properties:<p>\n *\n * <ul>\n * <li><i>julianday</i> - the Julian Day to set into this date\n * <li><i>year</i> - any integer except 0. Years go from -1 (BCE) to 1 (CE), skipping the zero year\n * <li><i>month</i> - 1 to 12, where 1 means Nisan, 2 means Iyyar, etc.\n * <li><i>day</i> - 1 to 30\n * <li><i>hour</i> - 0 to 23. A formatter is used to display 12 hour clocks, but this representation\n * is always done with an unambiguous 24 hour representation\n * <li><i>parts</i> - 0 to 1079. Specify the halaqim parts of an hour. Either specify\n * the parts or specify the minutes, seconds, and milliseconds, but not both.\n * <li><i>minute</i> - 0 to 59\n * <li><i>second</i> - 0 to 59\n * <li><i>millisecond</i> - 0 to 999\n * <li><i>locale</i> - the TimeZone instance or time zone name as a string\n * of this julian date. The date/time is kept in the local time. The time zone\n * is used later if this date is formatted according to a different time zone and\n * the difference has to be calculated, or when the date format has a time zone\n * component in it.\n * <li><i>timezone</i> - the time zone of this instance. If the time zone is not\n * given, it can be inferred from this locale. For locales that span multiple\n * time zones, the one with the largest population is chosen as the one that\n * represents the locale.\n *\n * <li><i>date</i> - use the given intrinsic Javascript date to initialize this one.\n * </ul>\n *\n * If called with another Hebrew date argument, the date components of the given\n * date are copied into the current one.<p>\n *\n * If the constructor is called with no arguments at all or if none of the\n * properties listed above\n * from <i>julianday</i> through <i>millisecond</i> are present, then the date\n * components are\n * filled in with the current date at the time of instantiation. Note that if\n * you do not give the time zone when defaulting to the current time and the\n * time zone for all of ilib was not set with <i>ilib.setTimeZone()</i>, then the\n * time zone will default to UTC (\"Universal Time, Coordinated\" or \"Greenwich\n * Mean Time\").<p>\n *\n *\n * @constructor\n * @extends IDate\n * @param {Object=} params parameters that govern the settings and behaviour of this Hebrew date\n */\n\n\nvar HebrewDate = function HebrewDate(params) {\n  this.cal = new HebrewCal();\n  params = params || {};\n\n  if (params.timezone) {\n    this.timezone = params.timezone;\n  }\n\n  if (params.locale) {\n    this.locale = typeof params.locale === 'string' ? new Locale(params.locale) : params.locale;\n  }\n\n  if (!this.timezone) {\n    if (this.locale) {\n      new LocaleInfo(this.locale, {\n        sync: params.sync,\n        loadParams: params.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.timezone = li.getTimeZone();\n\n          this._init(params);\n        })\n      });\n    } else {\n      this.timezone = \"local\";\n\n      this._init(params);\n    }\n  } else {\n    this._init(params);\n  }\n};\n\nHebrewDate.prototype = new IDate({\n  noinstance: true\n});\nHebrewDate.prototype.parent = IDate;\nHebrewDate.prototype.constructor = HebrewDate;\n/**\n * Initialize this date\n * @private\n */\n\nHebrewDate.prototype._init = function (params) {\n  if (params.year || params.month || params.day || params.hour || params.minute || params.second || params.millisecond || params.parts) {\n    /**\n     * Year in the Hebrew calendar.\n     * @type number\n     */\n    this.year = parseInt(params.year, 10) || 0;\n    /**\n     * The month number, ranging from 1 to 13.\n     * @type number\n     */\n\n    this.month = parseInt(params.month, 10) || 1;\n    /**\n     * The day of the month. This ranges from 1 to 30.\n     * @type number\n     */\n\n    this.day = parseInt(params.day, 10) || 1;\n    /**\n     * The hour of the day. This can be a number from 0 to 23, as times are\n     * stored unambiguously in the 24-hour clock.\n     * @type number\n     */\n\n    this.hour = parseInt(params.hour, 10) || 0;\n\n    if (typeof params.parts !== 'undefined') {\n      /**\n       * The parts (halaqim) of the hour. This can be a number from 0 to 1079.\n       * @type number\n       */\n      this.parts = parseInt(params.parts, 10);\n      var seconds = parseInt(params.parts, 10) * 3.333333333333;\n      this.minute = Math.floor(seconds / 60);\n      seconds -= this.minute * 60;\n      this.second = Math.floor(seconds);\n      this.millisecond = seconds - this.second;\n    } else {\n      /**\n       * The minute of the hours. Ranges from 0 to 59.\n       * @type number\n       */\n      this.minute = parseInt(params.minute, 10) || 0;\n      /**\n       * The second of the minute. Ranges from 0 to 59.\n       * @type number\n       */\n\n      this.second = parseInt(params.second, 10) || 0;\n      /**\n       * The millisecond of the second. Ranges from 0 to 999.\n       * @type number\n       */\n\n      this.millisecond = parseInt(params.millisecond, 10) || 0;\n    }\n    /**\n     * The day of the year. Ranges from 1 to 383.\n     * @type number\n     */\n\n\n    this.dayOfYear = parseInt(params.dayOfYear, 10);\n\n    if (typeof params.dst === 'boolean') {\n      this.dst = params.dst;\n    }\n\n    this.rd = this.newRd(this); // add the time zone offset to the rd to convert to UTC\n\n    new TimeZone({\n      id: this.timezone,\n      sync: params.sync,\n      loadParams: params.loadParams,\n      onLoad: ilib.bind(this, function (tz) {\n        this.tz = tz; // getOffsetMillis requires that this.year, this.rd, and this.dst\n        // are set in order to figure out which time zone rules apply and\n        // what the offset is at that point in the year\n\n        this.offset = this.tz._getOffsetMillisWallTime(this) / 86400000;\n\n        if (this.offset !== 0) {\n          this.rd = this.newRd({\n            rd: this.rd.getRataDie() - this.offset\n          });\n        }\n\n        this._init2(params);\n      })\n    });\n  } else {\n    this._init2(params);\n  }\n};\n/**\n * Finish initializing this date\n * @private\n */\n\n\nHebrewDate.prototype._init2 = function (params) {\n  if (!this.rd) {\n    this.rd = this.newRd(params);\n\n    this._calcDateComponents();\n  }\n\n  if (typeof params.onLoad === \"function\") {\n    params.onLoad(this);\n  }\n};\n/**\n * the cumulative lengths of each month for a non-leap year, without new years corrections,\n * that can be used in reverse to map days to months\n * @private\n * @const\n * @type Array.<number>\n */\n\n\nHebrewDate.cumMonthLengthsReverse = [//  [days, monthnumber],\n[0, 7],\n/* Tishri - Jewish New Year (Rosh HaShanah) starts in month 7 */\n[30, 8],\n/* Heshvan */\n[59, 9],\n/* Kislev */\n[88, 10],\n/* Teveth */\n[117, 11],\n/* Shevat */\n[147, 12],\n/* Adar I */\n[176, 1],\n/* Nisan */\n[206, 2],\n/* Iyyar */\n[235, 3],\n/* Sivan */\n[265, 4],\n/* Tammuz */\n[294, 5],\n/* Av */\n[324, 6],\n/* Elul */\n[354, 7]\n/* end of year sentinel value */\n];\n/**\n * the cumulative lengths of each month for a leap year, without new years corrections\n * that can be used in reverse to map days to months\n *\n * @private\n * @const\n * @type Array.<number>\n */\n\nHebrewDate.cumMonthLengthsLeapReverse = [//  [days, monthnumber],\n[0, 7],\n/* Tishri - Jewish New Year (Rosh HaShanah) starts in month 7 */\n[30, 8],\n/* Heshvan */\n[59, 9],\n/* Kislev */\n[88, 10],\n/* Teveth */\n[117, 11],\n/* Shevat */\n[147, 12],\n/* Adar I */\n[177, 13],\n/* Adar II */\n[206, 1],\n/* Nisan */\n[236, 2],\n/* Iyyar */\n[265, 3],\n/* Sivan */\n[295, 4],\n/* Tammuz */\n[324, 5],\n/* Av */\n[354, 6],\n/* Elul */\n[384, 7]\n/* end of year sentinel value */\n];\n/**\n * Number of days difference between RD 0 of the Hebrew calendar\n * (Jan 1, 1 Gregorian = JD 1721057.5) and RD 0 of the Hebrew calendar\n * (September 7, -3760 Gregorian = JD 347997.25)\n * @private\n * @const\n * @type number\n */\n\nHebrewDate.GregorianDiff = 1373060.25;\n/**\n * Return a new RD for this date type using the given params.\n * @private\n * @param {Object=} params the parameters used to create this rata die instance\n * @returns {RataDie} the new RD instance for the given params\n */\n\nHebrewDate.prototype.newRd = function (params) {\n  return new HebrewRataDie(params);\n};\n/**\n * Return the year for the given RD\n * @protected\n * @param {number} rd RD to calculate from\n * @returns {number} the year for the RD\n */\n\n\nHebrewDate.prototype._calcYear = function (rd) {\n  var year, approximation, nextNewYear; // divide by the average number of days per year in the Hebrew calendar\n  // to approximate the year, then tweak it to get the real year\n\n  approximation = Math.floor(rd / 365.246822206) + 1; // console.log(\"HebrewDate._calcYear: approx is \" + approximation);\n  // search forward from approximation-1 for the year that actually contains this rd\n\n  year = approximation;\n  nextNewYear = HebrewCal.newYear(year);\n\n  while (rd >= nextNewYear) {\n    year++;\n    nextNewYear = HebrewCal.newYear(year);\n  }\n\n  return year - 1;\n};\n/**\n * Calculate date components for the given RD date.\n * @protected\n */\n\n\nHebrewDate.prototype._calcDateComponents = function () {\n  var remainder,\n      i,\n      table,\n      target,\n      rd = this.rd.getRataDie(); // console.log(\"HebrewDate.calcComponents: calculating for rd \" + rd);\n\n  if (typeof this.offset === \"undefined\") {\n    this.year = this._calcYear(rd); // now offset the RD by the time zone, then recalculate in case we were\n    // near the year boundary\n\n    if (!this.tz) {\n      this.tz = new TimeZone({\n        id: this.timezone\n      });\n    }\n\n    this.offset = this.tz.getOffsetMillis(this) / 86400000;\n  }\n\n  if (this.offset !== 0) {\n    rd += this.offset;\n    this.year = this._calcYear(rd);\n  } // console.log(\"HebrewDate.calcComponents: year is \" + this.year + \" with starting rd \" + thisNewYear);\n\n\n  remainder = rd - HebrewCal.newYear(this.year); // console.log(\"HebrewDate.calcComponents: remainder is \" + remainder);\n  // take out new years corrections so we get the right month when we look it up in the table\n\n  if (remainder >= 59) {\n    if (remainder >= 88) {\n      if (HebrewCal.longKislev(this.year)) {\n        remainder--;\n      }\n    }\n\n    if (HebrewCal.longHeshvan(this.year)) {\n      remainder--;\n    }\n  } // console.log(\"HebrewDate.calcComponents: after new years corrections, remainder is \" + remainder);\n\n\n  table = this.cal.isLeapYear(this.year) ? HebrewDate.cumMonthLengthsLeapReverse : HebrewDate.cumMonthLengthsReverse;\n  i = 0;\n  target = Math.floor(remainder);\n\n  while (i + 1 < table.length && target >= table[i + 1][0]) {\n    i++;\n  }\n\n  this.month = table[i][1]; // console.log(\"HebrewDate.calcComponents: remainder is \" + remainder);\n\n  remainder -= table[i][0]; // console.log(\"HebrewDate.calcComponents: month is \" + this.month + \" and remainder is \" + remainder);\n\n  this.day = Math.floor(remainder);\n  remainder -= this.day;\n  this.day++; // days are 1-based\n  // console.log(\"HebrewDate.calcComponents: day is \" + this.day + \" and remainder is \" + remainder);\n  // now convert to milliseconds for the rest of the calculation\n\n  remainder = Math.round(remainder * 86400000);\n  this.hour = Math.floor(remainder / 3600000);\n  remainder -= this.hour * 3600000; // the hours from 0 to 6 are actually 18:00 to midnight of the previous\n  // gregorian day, so we have to adjust for that\n\n  if (this.hour >= 6) {\n    this.hour -= 6;\n  } else {\n    this.hour += 18;\n  }\n\n  this.minute = Math.floor(remainder / 60000);\n  remainder -= this.minute * 60000;\n  this.second = Math.floor(remainder / 1000);\n  remainder -= this.second * 1000;\n  this.millisecond = Math.floor(remainder);\n};\n/**\n * Return the day of the week of this date. The day of the week is encoded\n * as number from 0 to 6, with 0=Sunday, 1=Monday, etc., until 6=Saturday.\n *\n * @return {number} the day of the week\n */\n\n\nHebrewDate.prototype.getDayOfWeek = function () {\n  var rd = Math.floor(this.rd.getRataDie() + (this.offset || 0));\n  return MathUtils.mod(rd + 1, 7);\n};\n/**\n * Get the Halaqim (parts) of an hour. There are 1080 parts in an hour, which means\n * each part is 3.33333333 seconds long. This means the number returned may not\n * be an integer.\n *\n * @return {number} the halaqim parts of the current hour\n */\n\n\nHebrewDate.prototype.getHalaqim = function () {\n  if (this.parts < 0) {\n    // convert to ms first, then to parts\n    var h = this.minute * 60000 + this.second * 1000 + this.millisecond;\n    this.parts = h * 0.0003;\n  }\n\n  return this.parts;\n};\n/**\n * Return the rd number of the first Sunday of the given ISO year.\n * @protected\n * @return the rd of the first Sunday of the ISO year\n */\n\n\nHebrewDate.prototype.firstSunday = function (year) {\n  var tishri1 = this.newRd({\n    year: year,\n    month: 7,\n    day: 1,\n    hour: 18,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    cal: this.cal\n  });\n  var firstThu = this.newRd({\n    rd: tishri1.onOrAfter(4),\n    cal: this.cal\n  });\n  return firstThu.before(0);\n};\n/**\n * Return the ordinal day of the year. Days are counted from 1 and proceed linearly up to\n * 385, regardless of months or weeks, etc. That is, Tishri 1st is day 1, and\n * Elul 29 is 385 for a leap year with a long Heshvan and long Kislev.\n * @return {number} the ordinal day of the year\n */\n\n\nHebrewDate.prototype.getDayOfYear = function () {\n  var table = this.cal.isLeapYear(this.year) ? HebrewRataDie.cumMonthLengthsLeap : HebrewRataDie.cumMonthLengths;\n  var days = table[this.month - 1];\n\n  if ((this.month < 7 || this.month > 8) && HebrewCal.longHeshvan(this.year)) {\n    days++;\n  }\n\n  if ((this.month < 7 || this.month > 9) && HebrewCal.longKislev(this.year)) {\n    days++;\n  }\n\n  return days + this.day;\n};\n/**\n * Return the ordinal number of the week within the month. The first week of a month is\n * the first one that contains 4 or more days in that month. If any days precede this\n * first week, they are marked as being in week 0. This function returns values from 0\n * through 6.<p>\n *\n * The locale is a required parameter because different locales that use the same\n * Hebrew calendar consider different days of the week to be the beginning of\n * the week. This can affect the week of the month in which some days are located.\n *\n * @param {Locale|string} locale the locale or locale spec to use when figuring out\n * the first day of the week\n * @return {number} the ordinal number of the week within the current month\n */\n\n\nHebrewDate.prototype.getWeekOfMonth = function (locale) {\n  var li = new LocaleInfo(locale),\n      first = this.newRd({\n    year: this.year,\n    month: this.month,\n    day: 1,\n    hour: 18,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }),\n      rd = this.rd.getRataDie(),\n      weekStart = first.onOrAfter(li.getFirstDayOfWeek());\n\n  if (weekStart - first.getRataDie() > 3) {\n    // if the first week has 4 or more days in it of the current month, then consider\n    // that week 1. Otherwise, it is week 0. To make it week 1, move the week start\n    // one week earlier.\n    weekStart -= 7;\n  }\n\n  return rd < weekStart ? 0 : Math.floor((rd - weekStart) / 7) + 1;\n};\n/**\n * Return the era for this date as a number. The value for the era for Hebrew\n * calendars is -1 for \"before the Hebrew era\" and 1 for \"the Hebrew era\".\n * Hebrew era dates are any date after Tishri 1, 1, which is the same as\n * September 7, 3760 BC in the Gregorian calendar.\n *\n * @return {number} 1 if this date is in the Hebrew era, -1 if it is before the\n * Hebrew era\n */\n\n\nHebrewDate.prototype.getEra = function () {\n  return this.year < 1 ? -1 : 1;\n};\n/**\n * Return the name of the calendar that governs this date.\n *\n * @return {string} a string giving the name of the calendar\n */\n\n\nHebrewDate.prototype.getCalendar = function () {\n  return \"hebrew\";\n}; // register with the factory method\n\n\nIDate._constructors[\"hebrew\"] = HebrewDate;\nmodule.exports = HebrewDate;","map":{"version":3,"sources":["/home/cdi/stephen/node_modules/@enact/i18n/ilib/lib/HebrewDate.js"],"names":["ilib","require","MathUtils","Locale","LocaleInfo","IDate","TimeZone","Calendar","HebrewCal","HebrewRataDie","HebrewDate","params","cal","timezone","locale","sync","loadParams","onLoad","bind","li","getTimeZone","_init","prototype","noinstance","parent","constructor","year","month","day","hour","minute","second","millisecond","parts","parseInt","seconds","Math","floor","dayOfYear","dst","rd","newRd","id","tz","offset","_getOffsetMillisWallTime","getRataDie","_init2","_calcDateComponents","cumMonthLengthsReverse","cumMonthLengthsLeapReverse","GregorianDiff","_calcYear","approximation","nextNewYear","newYear","remainder","i","table","target","getOffsetMillis","longKislev","longHeshvan","isLeapYear","length","round","getDayOfWeek","mod","getHalaqim","h","firstSunday","tishri1","firstThu","onOrAfter","before","getDayOfYear","cumMonthLengthsLeap","cumMonthLengths","days","getWeekOfMonth","first","weekStart","getFirstDayOfWeek","getEra","getCalendar","_constructors","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/*\n * HebrewDate.js - Represent a date in the Hebrew calendar\n *\n * Copyright © 2012-2015, 2018, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* !depends\nilib.js\nLocale.js\nLocaleInfo.js\nTimeZone.js\nIDate.js\nMathUtils.js\nCalendar.js\nHebrewCal.js\nHebrewRataDie.js\n*/\nvar ilib = require(\"./ilib.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar IDate = require(\"./IDate.js\");\n\nvar TimeZone = require(\"./TimeZone.js\");\n\nvar Calendar = require(\"./Calendar.js\");\n\nvar HebrewCal = require(\"./HebrewCal.js\");\n\nvar HebrewRataDie = require(\"./HebrewRataDie.js\");\n/**\n * @class\n * Construct a new civil Hebrew date object. The constructor can be called\n * with a params object that can contain the following properties:<p>\n *\n * <ul>\n * <li><i>julianday</i> - the Julian Day to set into this date\n * <li><i>year</i> - any integer except 0. Years go from -1 (BCE) to 1 (CE), skipping the zero year\n * <li><i>month</i> - 1 to 12, where 1 means Nisan, 2 means Iyyar, etc.\n * <li><i>day</i> - 1 to 30\n * <li><i>hour</i> - 0 to 23. A formatter is used to display 12 hour clocks, but this representation\n * is always done with an unambiguous 24 hour representation\n * <li><i>parts</i> - 0 to 1079. Specify the halaqim parts of an hour. Either specify\n * the parts or specify the minutes, seconds, and milliseconds, but not both.\n * <li><i>minute</i> - 0 to 59\n * <li><i>second</i> - 0 to 59\n * <li><i>millisecond</i> - 0 to 999\n * <li><i>locale</i> - the TimeZone instance or time zone name as a string\n * of this julian date. The date/time is kept in the local time. The time zone\n * is used later if this date is formatted according to a different time zone and\n * the difference has to be calculated, or when the date format has a time zone\n * component in it.\n * <li><i>timezone</i> - the time zone of this instance. If the time zone is not\n * given, it can be inferred from this locale. For locales that span multiple\n * time zones, the one with the largest population is chosen as the one that\n * represents the locale.\n *\n * <li><i>date</i> - use the given intrinsic Javascript date to initialize this one.\n * </ul>\n *\n * If called with another Hebrew date argument, the date components of the given\n * date are copied into the current one.<p>\n *\n * If the constructor is called with no arguments at all or if none of the\n * properties listed above\n * from <i>julianday</i> through <i>millisecond</i> are present, then the date\n * components are\n * filled in with the current date at the time of instantiation. Note that if\n * you do not give the time zone when defaulting to the current time and the\n * time zone for all of ilib was not set with <i>ilib.setTimeZone()</i>, then the\n * time zone will default to UTC (\"Universal Time, Coordinated\" or \"Greenwich\n * Mean Time\").<p>\n *\n *\n * @constructor\n * @extends IDate\n * @param {Object=} params parameters that govern the settings and behaviour of this Hebrew date\n */\n\n\nvar HebrewDate = function HebrewDate(params) {\n  this.cal = new HebrewCal();\n  params = params || {};\n\n  if (params.timezone) {\n    this.timezone = params.timezone;\n  }\n\n  if (params.locale) {\n    this.locale = typeof params.locale === 'string' ? new Locale(params.locale) : params.locale;\n  }\n\n  if (!this.timezone) {\n    if (this.locale) {\n      new LocaleInfo(this.locale, {\n        sync: params.sync,\n        loadParams: params.loadParams,\n        onLoad: ilib.bind(this, function (li) {\n          this.li = li;\n          this.timezone = li.getTimeZone();\n\n          this._init(params);\n        })\n      });\n    } else {\n      this.timezone = \"local\";\n\n      this._init(params);\n    }\n  } else {\n    this._init(params);\n  }\n};\n\nHebrewDate.prototype = new IDate({\n  noinstance: true\n});\nHebrewDate.prototype.parent = IDate;\nHebrewDate.prototype.constructor = HebrewDate;\n/**\n * Initialize this date\n * @private\n */\n\nHebrewDate.prototype._init = function (params) {\n  if (params.year || params.month || params.day || params.hour || params.minute || params.second || params.millisecond || params.parts) {\n    /**\n     * Year in the Hebrew calendar.\n     * @type number\n     */\n    this.year = parseInt(params.year, 10) || 0;\n    /**\n     * The month number, ranging from 1 to 13.\n     * @type number\n     */\n\n    this.month = parseInt(params.month, 10) || 1;\n    /**\n     * The day of the month. This ranges from 1 to 30.\n     * @type number\n     */\n\n    this.day = parseInt(params.day, 10) || 1;\n    /**\n     * The hour of the day. This can be a number from 0 to 23, as times are\n     * stored unambiguously in the 24-hour clock.\n     * @type number\n     */\n\n    this.hour = parseInt(params.hour, 10) || 0;\n\n    if (typeof params.parts !== 'undefined') {\n      /**\n       * The parts (halaqim) of the hour. This can be a number from 0 to 1079.\n       * @type number\n       */\n      this.parts = parseInt(params.parts, 10);\n      var seconds = parseInt(params.parts, 10) * 3.333333333333;\n      this.minute = Math.floor(seconds / 60);\n      seconds -= this.minute * 60;\n      this.second = Math.floor(seconds);\n      this.millisecond = seconds - this.second;\n    } else {\n      /**\n       * The minute of the hours. Ranges from 0 to 59.\n       * @type number\n       */\n      this.minute = parseInt(params.minute, 10) || 0;\n      /**\n       * The second of the minute. Ranges from 0 to 59.\n       * @type number\n       */\n\n      this.second = parseInt(params.second, 10) || 0;\n      /**\n       * The millisecond of the second. Ranges from 0 to 999.\n       * @type number\n       */\n\n      this.millisecond = parseInt(params.millisecond, 10) || 0;\n    }\n    /**\n     * The day of the year. Ranges from 1 to 383.\n     * @type number\n     */\n\n\n    this.dayOfYear = parseInt(params.dayOfYear, 10);\n\n    if (typeof params.dst === 'boolean') {\n      this.dst = params.dst;\n    }\n\n    this.rd = this.newRd(this); // add the time zone offset to the rd to convert to UTC\n\n    new TimeZone({\n      id: this.timezone,\n      sync: params.sync,\n      loadParams: params.loadParams,\n      onLoad: ilib.bind(this, function (tz) {\n        this.tz = tz; // getOffsetMillis requires that this.year, this.rd, and this.dst\n        // are set in order to figure out which time zone rules apply and\n        // what the offset is at that point in the year\n\n        this.offset = this.tz._getOffsetMillisWallTime(this) / 86400000;\n\n        if (this.offset !== 0) {\n          this.rd = this.newRd({\n            rd: this.rd.getRataDie() - this.offset\n          });\n        }\n\n        this._init2(params);\n      })\n    });\n  } else {\n    this._init2(params);\n  }\n};\n/**\n * Finish initializing this date\n * @private\n */\n\n\nHebrewDate.prototype._init2 = function (params) {\n  if (!this.rd) {\n    this.rd = this.newRd(params);\n\n    this._calcDateComponents();\n  }\n\n  if (typeof params.onLoad === \"function\") {\n    params.onLoad(this);\n  }\n};\n/**\n * the cumulative lengths of each month for a non-leap year, without new years corrections,\n * that can be used in reverse to map days to months\n * @private\n * @const\n * @type Array.<number>\n */\n\n\nHebrewDate.cumMonthLengthsReverse = [//  [days, monthnumber],\n[0, 7],\n/* Tishri - Jewish New Year (Rosh HaShanah) starts in month 7 */\n[30, 8],\n/* Heshvan */\n[59, 9],\n/* Kislev */\n[88, 10],\n/* Teveth */\n[117, 11],\n/* Shevat */\n[147, 12],\n/* Adar I */\n[176, 1],\n/* Nisan */\n[206, 2],\n/* Iyyar */\n[235, 3],\n/* Sivan */\n[265, 4],\n/* Tammuz */\n[294, 5],\n/* Av */\n[324, 6],\n/* Elul */\n[354, 7]\n/* end of year sentinel value */\n];\n/**\n * the cumulative lengths of each month for a leap year, without new years corrections\n * that can be used in reverse to map days to months\n *\n * @private\n * @const\n * @type Array.<number>\n */\n\nHebrewDate.cumMonthLengthsLeapReverse = [//  [days, monthnumber],\n[0, 7],\n/* Tishri - Jewish New Year (Rosh HaShanah) starts in month 7 */\n[30, 8],\n/* Heshvan */\n[59, 9],\n/* Kislev */\n[88, 10],\n/* Teveth */\n[117, 11],\n/* Shevat */\n[147, 12],\n/* Adar I */\n[177, 13],\n/* Adar II */\n[206, 1],\n/* Nisan */\n[236, 2],\n/* Iyyar */\n[265, 3],\n/* Sivan */\n[295, 4],\n/* Tammuz */\n[324, 5],\n/* Av */\n[354, 6],\n/* Elul */\n[384, 7]\n/* end of year sentinel value */\n];\n/**\n * Number of days difference between RD 0 of the Hebrew calendar\n * (Jan 1, 1 Gregorian = JD 1721057.5) and RD 0 of the Hebrew calendar\n * (September 7, -3760 Gregorian = JD 347997.25)\n * @private\n * @const\n * @type number\n */\n\nHebrewDate.GregorianDiff = 1373060.25;\n/**\n * Return a new RD for this date type using the given params.\n * @private\n * @param {Object=} params the parameters used to create this rata die instance\n * @returns {RataDie} the new RD instance for the given params\n */\n\nHebrewDate.prototype.newRd = function (params) {\n  return new HebrewRataDie(params);\n};\n/**\n * Return the year for the given RD\n * @protected\n * @param {number} rd RD to calculate from\n * @returns {number} the year for the RD\n */\n\n\nHebrewDate.prototype._calcYear = function (rd) {\n  var year, approximation, nextNewYear; // divide by the average number of days per year in the Hebrew calendar\n  // to approximate the year, then tweak it to get the real year\n\n  approximation = Math.floor(rd / 365.246822206) + 1; // console.log(\"HebrewDate._calcYear: approx is \" + approximation);\n  // search forward from approximation-1 for the year that actually contains this rd\n\n  year = approximation;\n  nextNewYear = HebrewCal.newYear(year);\n\n  while (rd >= nextNewYear) {\n    year++;\n    nextNewYear = HebrewCal.newYear(year);\n  }\n\n  return year - 1;\n};\n/**\n * Calculate date components for the given RD date.\n * @protected\n */\n\n\nHebrewDate.prototype._calcDateComponents = function () {\n  var remainder,\n      i,\n      table,\n      target,\n      rd = this.rd.getRataDie(); // console.log(\"HebrewDate.calcComponents: calculating for rd \" + rd);\n\n  if (typeof this.offset === \"undefined\") {\n    this.year = this._calcYear(rd); // now offset the RD by the time zone, then recalculate in case we were\n    // near the year boundary\n\n    if (!this.tz) {\n      this.tz = new TimeZone({\n        id: this.timezone\n      });\n    }\n\n    this.offset = this.tz.getOffsetMillis(this) / 86400000;\n  }\n\n  if (this.offset !== 0) {\n    rd += this.offset;\n    this.year = this._calcYear(rd);\n  } // console.log(\"HebrewDate.calcComponents: year is \" + this.year + \" with starting rd \" + thisNewYear);\n\n\n  remainder = rd - HebrewCal.newYear(this.year); // console.log(\"HebrewDate.calcComponents: remainder is \" + remainder);\n  // take out new years corrections so we get the right month when we look it up in the table\n\n  if (remainder >= 59) {\n    if (remainder >= 88) {\n      if (HebrewCal.longKislev(this.year)) {\n        remainder--;\n      }\n    }\n\n    if (HebrewCal.longHeshvan(this.year)) {\n      remainder--;\n    }\n  } // console.log(\"HebrewDate.calcComponents: after new years corrections, remainder is \" + remainder);\n\n\n  table = this.cal.isLeapYear(this.year) ? HebrewDate.cumMonthLengthsLeapReverse : HebrewDate.cumMonthLengthsReverse;\n  i = 0;\n  target = Math.floor(remainder);\n\n  while (i + 1 < table.length && target >= table[i + 1][0]) {\n    i++;\n  }\n\n  this.month = table[i][1]; // console.log(\"HebrewDate.calcComponents: remainder is \" + remainder);\n\n  remainder -= table[i][0]; // console.log(\"HebrewDate.calcComponents: month is \" + this.month + \" and remainder is \" + remainder);\n\n  this.day = Math.floor(remainder);\n  remainder -= this.day;\n  this.day++; // days are 1-based\n  // console.log(\"HebrewDate.calcComponents: day is \" + this.day + \" and remainder is \" + remainder);\n  // now convert to milliseconds for the rest of the calculation\n\n  remainder = Math.round(remainder * 86400000);\n  this.hour = Math.floor(remainder / 3600000);\n  remainder -= this.hour * 3600000; // the hours from 0 to 6 are actually 18:00 to midnight of the previous\n  // gregorian day, so we have to adjust for that\n\n  if (this.hour >= 6) {\n    this.hour -= 6;\n  } else {\n    this.hour += 18;\n  }\n\n  this.minute = Math.floor(remainder / 60000);\n  remainder -= this.minute * 60000;\n  this.second = Math.floor(remainder / 1000);\n  remainder -= this.second * 1000;\n  this.millisecond = Math.floor(remainder);\n};\n/**\n * Return the day of the week of this date. The day of the week is encoded\n * as number from 0 to 6, with 0=Sunday, 1=Monday, etc., until 6=Saturday.\n *\n * @return {number} the day of the week\n */\n\n\nHebrewDate.prototype.getDayOfWeek = function () {\n  var rd = Math.floor(this.rd.getRataDie() + (this.offset || 0));\n  return MathUtils.mod(rd + 1, 7);\n};\n/**\n * Get the Halaqim (parts) of an hour. There are 1080 parts in an hour, which means\n * each part is 3.33333333 seconds long. This means the number returned may not\n * be an integer.\n *\n * @return {number} the halaqim parts of the current hour\n */\n\n\nHebrewDate.prototype.getHalaqim = function () {\n  if (this.parts < 0) {\n    // convert to ms first, then to parts\n    var h = this.minute * 60000 + this.second * 1000 + this.millisecond;\n    this.parts = h * 0.0003;\n  }\n\n  return this.parts;\n};\n/**\n * Return the rd number of the first Sunday of the given ISO year.\n * @protected\n * @return the rd of the first Sunday of the ISO year\n */\n\n\nHebrewDate.prototype.firstSunday = function (year) {\n  var tishri1 = this.newRd({\n    year: year,\n    month: 7,\n    day: 1,\n    hour: 18,\n    minute: 0,\n    second: 0,\n    millisecond: 0,\n    cal: this.cal\n  });\n  var firstThu = this.newRd({\n    rd: tishri1.onOrAfter(4),\n    cal: this.cal\n  });\n  return firstThu.before(0);\n};\n/**\n * Return the ordinal day of the year. Days are counted from 1 and proceed linearly up to\n * 385, regardless of months or weeks, etc. That is, Tishri 1st is day 1, and\n * Elul 29 is 385 for a leap year with a long Heshvan and long Kislev.\n * @return {number} the ordinal day of the year\n */\n\n\nHebrewDate.prototype.getDayOfYear = function () {\n  var table = this.cal.isLeapYear(this.year) ? HebrewRataDie.cumMonthLengthsLeap : HebrewRataDie.cumMonthLengths;\n  var days = table[this.month - 1];\n\n  if ((this.month < 7 || this.month > 8) && HebrewCal.longHeshvan(this.year)) {\n    days++;\n  }\n\n  if ((this.month < 7 || this.month > 9) && HebrewCal.longKislev(this.year)) {\n    days++;\n  }\n\n  return days + this.day;\n};\n/**\n * Return the ordinal number of the week within the month. The first week of a month is\n * the first one that contains 4 or more days in that month. If any days precede this\n * first week, they are marked as being in week 0. This function returns values from 0\n * through 6.<p>\n *\n * The locale is a required parameter because different locales that use the same\n * Hebrew calendar consider different days of the week to be the beginning of\n * the week. This can affect the week of the month in which some days are located.\n *\n * @param {Locale|string} locale the locale or locale spec to use when figuring out\n * the first day of the week\n * @return {number} the ordinal number of the week within the current month\n */\n\n\nHebrewDate.prototype.getWeekOfMonth = function (locale) {\n  var li = new LocaleInfo(locale),\n      first = this.newRd({\n    year: this.year,\n    month: this.month,\n    day: 1,\n    hour: 18,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }),\n      rd = this.rd.getRataDie(),\n      weekStart = first.onOrAfter(li.getFirstDayOfWeek());\n\n  if (weekStart - first.getRataDie() > 3) {\n    // if the first week has 4 or more days in it of the current month, then consider\n    // that week 1. Otherwise, it is week 0. To make it week 1, move the week start\n    // one week earlier.\n    weekStart -= 7;\n  }\n\n  return rd < weekStart ? 0 : Math.floor((rd - weekStart) / 7) + 1;\n};\n/**\n * Return the era for this date as a number. The value for the era for Hebrew\n * calendars is -1 for \"before the Hebrew era\" and 1 for \"the Hebrew era\".\n * Hebrew era dates are any date after Tishri 1, 1, which is the same as\n * September 7, 3760 BC in the Gregorian calendar.\n *\n * @return {number} 1 if this date is in the Hebrew era, -1 if it is before the\n * Hebrew era\n */\n\n\nHebrewDate.prototype.getEra = function () {\n  return this.year < 1 ? -1 : 1;\n};\n/**\n * Return the name of the calendar that governs this date.\n *\n * @return {string} a string giving the name of the calendar\n */\n\n\nHebrewDate.prototype.getCalendar = function () {\n  return \"hebrew\";\n}; // register with the factory method\n\n\nIDate._constructors[\"hebrew\"] = HebrewDate;\nmodule.exports = HebrewDate;"]},"metadata":{},"sourceType":"module"}