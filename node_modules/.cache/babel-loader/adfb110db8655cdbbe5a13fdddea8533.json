{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updatePointerPosition = exports.setPointerMode = exports.notifyPointerMove = exports.notifyKeyDown = exports.hasPointerMoved = exports.getPointerMode = exports.getLastPointerPosition = void 0;\n\nvar _keymap = require(\"@enact/core/keymap\");\n\nvar _util = require(\"@enact/core/util\");\n/**\n * Exports methods and members for working with pointer events in spotlight\n *\n * @module spotlight/pointer\n * @private\n */\n\n/*\n * Whether Spotlight is in pointer mode (as opposed to 5-way mode).\n *\n * @type {Boolean}\n * @default true\n * @private\n */\n\n\nvar _pointerMode = true;\n/**\n * Sets the current pointer mode\n *\n * @param   {Boolean} pointerMode `true` to enable pointer mode; `false` to disable pointer mode\n * @memberof spotlight/pointer\n * @private\n */\n\nvar setPointerMode = function setPointerMode(pointerMode) {\n  _pointerMode = pointerMode;\n};\n/**\n * Gets the current pointer mode\n *\n * @returns {Boolean} The current state of pointer mode\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.setPointerMode = setPointerMode;\n\nvar getPointerMode = function getPointerMode() {\n  return _pointerMode;\n}; // Cached pointer position\n\n\nexports.getPointerMode = getPointerMode;\nvar _pointerX = null;\nvar _pointerY = null;\n/**\n * Returns whether or not the current pointer position matches the provided coordinates\n *\n * @param   {Number} x Pointer position relative to the left side of the viewport\n * @param   {Number} y Pointer position relative to the top side of the viewport\n *\n * @returns {Boolean}   `true` if the position was changed\n * @memberof spotlight/pointer\n * @private\n */\n\nvar hasPointerMoved = function hasPointerMoved(x, y) {\n  return x !== _pointerX || y !== _pointerY;\n};\n/**\n * Updates the cached pointer position, updating the current pointer mode when the position has\n * changed.\n *\n * @param   {Number} x Pointer position relative to the left side of the viewport\n * @param   {Number} y Pointer position relative to the top side of the viewport\n *\n * @returns {Boolean}   `true` if the position was updated\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.hasPointerMoved = hasPointerMoved;\n\nvar updatePointerPosition = function updatePointerPosition(x, y) {\n  // Chrome emits mousemove on scroll, but client coordinates do not change.\n  if (hasPointerMoved(x, y)) {\n    setPointerMode(true);\n    _pointerX = x;\n    _pointerY = y;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns the last known position of the pointer\n *\n * @returns {Object} Contains `x` and `y` coordinates for the pointer\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.updatePointerPosition = updatePointerPosition;\n\nvar getLastPointerPosition = function getLastPointerPosition() {\n  return {\n    x: _pointerX,\n    y: _pointerY\n  };\n}; // 30ms (_pointerHiddenToKeyTimeout) is semi-arbitrary, to account for the time it takes for the\n// following directional key event to fire, and to prevent momentary spotting of the last\n// focused item - needs to be a value large enough to account for the potentially-trailing\n// event, but not too large that another unrelated event can be fired inside the window\n\n\nexports.getLastPointerPosition = getLastPointerPosition;\nvar hidePointerJob = new _util.Job(function (callback) {\n  setPointerMode(false);\n\n  if (callback) {\n    callback();\n  }\n}, 30);\n/**\n * Notifies spotlight of a change in the pointer position\n *\n * @param   {Node}     target   Node under the pointer\n * @param   {Number}   x        Horizontal position relative to the left side of the viewport\n * @param   {Number}   y        Vertical position relative to the top side of the viewport\n *\n * @returns {Boolean}           `true` if the change in position results in a change in focus\n * @memberof spotlight/pointer\n * @private\n */\n\nvar notifyPointerMove = function notifyPointerMove(current, target, x, y) {\n  var priorPointerMode = getPointerMode();\n\n  if (updatePointerPosition(x, y)) {\n    // if we're entering pointer mode and the target element isn't within the currently\n    // focused element, there may be a new navigable target\n    return !priorPointerMode || !current || !current.contains(target);\n  } // the pointer hasn't actually moved (surprise!)\n\n\n  return false;\n};\n/**\n * Notifies the pointer module of key events. If the pointer should be hidden, a timer is set and\n * `callback` is invoked after the timer has expired and pointer mode has been disabled. For any\n * other type of key event, pointer mode is disabled and `false` is returned.\n *\n * @param   {Number}    keyCode     Key event key code\n * @param   {Function}  [callback]  Optional callback to invoke upon hiding the pointer.\n *\n * @returns {Boolean}               `true` for pointer hide or show key events\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.notifyPointerMove = notifyPointerMove;\n\nvar notifyKeyDown = function notifyKeyDown(keyCode, callback) {\n  // for hide/show pointer events, handle them and return true\n  if ((0, _keymap.is)('pointerHide', keyCode)) {\n    hidePointerJob.start(callback);\n    return true;\n  } else if ((0, _keymap.is)('pointerShow', keyCode)) {\n    setPointerMode(true);\n    return true;\n  } else if (!(0, _keymap.is)('nonModal', keyCode) && !(0, _keymap.is)('cancel', keyCode)) {\n    setPointerMode(false);\n  }\n\n  return false;\n};\n\nexports.notifyKeyDown = notifyKeyDown;","map":{"version":3,"sources":["/home/cdi/final/SteApp/node_modules/@enact/spotlight/src/pointer.js"],"names":["Object","defineProperty","exports","value","updatePointerPosition","setPointerMode","notifyPointerMove","notifyKeyDown","hasPointerMoved","getPointerMode","getLastPointerPosition","_keymap","require","_util","_pointerMode","pointerMode","_pointerX","_pointerY","x","y","hidePointerJob","Job","callback","current","target","priorPointerMode","contains","keyCode","is","start"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updatePointerPosition = exports.setPointerMode = exports.notifyPointerMove = exports.notifyKeyDown = exports.hasPointerMoved = exports.getPointerMode = exports.getLastPointerPosition = void 0;\n\nvar _keymap = require(\"@enact/core/keymap\");\n\nvar _util = require(\"@enact/core/util\");\n\n/**\n * Exports methods and members for working with pointer events in spotlight\n *\n * @module spotlight/pointer\n * @private\n */\n\n/*\n * Whether Spotlight is in pointer mode (as opposed to 5-way mode).\n *\n * @type {Boolean}\n * @default true\n * @private\n */\nvar _pointerMode = true;\n/**\n * Sets the current pointer mode\n *\n * @param   {Boolean} pointerMode `true` to enable pointer mode; `false` to disable pointer mode\n * @memberof spotlight/pointer\n * @private\n */\n\nvar setPointerMode = function setPointerMode(pointerMode) {\n  _pointerMode = pointerMode;\n};\n/**\n * Gets the current pointer mode\n *\n * @returns {Boolean} The current state of pointer mode\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.setPointerMode = setPointerMode;\n\nvar getPointerMode = function getPointerMode() {\n  return _pointerMode;\n}; // Cached pointer position\n\n\nexports.getPointerMode = getPointerMode;\nvar _pointerX = null;\nvar _pointerY = null;\n/**\n * Returns whether or not the current pointer position matches the provided coordinates\n *\n * @param   {Number} x Pointer position relative to the left side of the viewport\n * @param   {Number} y Pointer position relative to the top side of the viewport\n *\n * @returns {Boolean}   `true` if the position was changed\n * @memberof spotlight/pointer\n * @private\n */\n\nvar hasPointerMoved = function hasPointerMoved(x, y) {\n  return x !== _pointerX || y !== _pointerY;\n};\n/**\n * Updates the cached pointer position, updating the current pointer mode when the position has\n * changed.\n *\n * @param   {Number} x Pointer position relative to the left side of the viewport\n * @param   {Number} y Pointer position relative to the top side of the viewport\n *\n * @returns {Boolean}   `true` if the position was updated\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.hasPointerMoved = hasPointerMoved;\n\nvar updatePointerPosition = function updatePointerPosition(x, y) {\n  // Chrome emits mousemove on scroll, but client coordinates do not change.\n  if (hasPointerMoved(x, y)) {\n    setPointerMode(true);\n    _pointerX = x;\n    _pointerY = y;\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns the last known position of the pointer\n *\n * @returns {Object} Contains `x` and `y` coordinates for the pointer\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.updatePointerPosition = updatePointerPosition;\n\nvar getLastPointerPosition = function getLastPointerPosition() {\n  return {\n    x: _pointerX,\n    y: _pointerY\n  };\n}; // 30ms (_pointerHiddenToKeyTimeout) is semi-arbitrary, to account for the time it takes for the\n// following directional key event to fire, and to prevent momentary spotting of the last\n// focused item - needs to be a value large enough to account for the potentially-trailing\n// event, but not too large that another unrelated event can be fired inside the window\n\n\nexports.getLastPointerPosition = getLastPointerPosition;\nvar hidePointerJob = new _util.Job(function (callback) {\n  setPointerMode(false);\n\n  if (callback) {\n    callback();\n  }\n}, 30);\n/**\n * Notifies spotlight of a change in the pointer position\n *\n * @param   {Node}     target   Node under the pointer\n * @param   {Number}   x        Horizontal position relative to the left side of the viewport\n * @param   {Number}   y        Vertical position relative to the top side of the viewport\n *\n * @returns {Boolean}           `true` if the change in position results in a change in focus\n * @memberof spotlight/pointer\n * @private\n */\n\nvar notifyPointerMove = function notifyPointerMove(current, target, x, y) {\n  var priorPointerMode = getPointerMode();\n\n  if (updatePointerPosition(x, y)) {\n    // if we're entering pointer mode and the target element isn't within the currently\n    // focused element, there may be a new navigable target\n    return !priorPointerMode || !current || !current.contains(target);\n  } // the pointer hasn't actually moved (surprise!)\n\n\n  return false;\n};\n/**\n * Notifies the pointer module of key events. If the pointer should be hidden, a timer is set and\n * `callback` is invoked after the timer has expired and pointer mode has been disabled. For any\n * other type of key event, pointer mode is disabled and `false` is returned.\n *\n * @param   {Number}    keyCode     Key event key code\n * @param   {Function}  [callback]  Optional callback to invoke upon hiding the pointer.\n *\n * @returns {Boolean}               `true` for pointer hide or show key events\n * @memberof spotlight/pointer\n * @private\n */\n\n\nexports.notifyPointerMove = notifyPointerMove;\n\nvar notifyKeyDown = function notifyKeyDown(keyCode, callback) {\n  // for hide/show pointer events, handle them and return true\n  if ((0, _keymap.is)('pointerHide', keyCode)) {\n    hidePointerJob.start(callback);\n    return true;\n  } else if ((0, _keymap.is)('pointerShow', keyCode)) {\n    setPointerMode(true);\n    return true;\n  } else if (!(0, _keymap.is)('nonModal', keyCode) && !(0, _keymap.is)('cancel', keyCode)) {\n    setPointerMode(false);\n  }\n\n  return false;\n};\n\nexports.notifyKeyDown = notifyKeyDown;"]},"metadata":{},"sourceType":"module"}