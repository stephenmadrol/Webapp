{"ast":null,"code":"\"use strict\";\n/*\n * TimeZone.js - Definition of a time zone class\n * \n * Copyright Â© 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends \nilib.js \nLocale.js\nLocaleInfo.js\nUtils.js\nMathUtils.js\nJSUtils.js\nGregRataDie.js\nIString.js\nCalendarFactory.js\n*/\n// !data localeinfo zoneinfo\n\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar GregRataDie = require(\"./GregRataDie.js\");\n\nvar CalendarFactory = require(\"./CalendarFactory.js\");\n\nvar IString = require(\"./IString.js\");\n/**\n * @class\n * Create a time zone instance. \n * \n * This class reports and transforms\n * information about particular time zones.<p>\n * \n * The options parameter may contain any of the following properties:\n * \n * <ul>\n * <li><i>id</i> - The id of the requested time zone such as \"Europe/London\" or \n * \"America/Los_Angeles\". These are taken from the IANA time zone database. (See\n * http://www.iana.org/time-zones for more information.) <p>\n * \n * There is one special \n * time zone that is not taken from the IANA database called simply \"local\". In\n * this case, this class will attempt to discover the current time zone and\n * daylight savings time settings by calling standard Javascript classes to \n * determine the offsets from UTC. \n * \n * <li><i>locale</i> - The locale for this time zone.\n * \n * <li><i>offset</i> - Choose the time zone based on the offset from UTC given in\n * number of minutes (negative is west, positive is east).\n * \n * <li><i>onLoad</i> - a callback function to call when the data is fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the data is loaded, the onLoad function is called with the current \n * instance as a parameter. \n * \n * <li><i>sync</i> - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *  \n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * There is currently no way in the ECMAscript\n * standard to tell which exact time zone is currently in use. Choosing the\n * id \"locale\" or specifying an explicit offset will not give a specific time zone, \n * as it is impossible to tell with certainty which zone the offsets \n * match.<p>\n * \n * When the id \"local\" is given or the offset option is specified, this class will\n * have the following behaviours:\n * <ul>\n * <li>The display name will always be given as the RFC822 style, no matter what\n * style is requested\n * <li>The id will also be returned as the RFC822 style display name\n * <li>When the offset is explicitly given, this class will assume the time zone \n * does not support daylight savings time, and the offsets will be calculated \n * the same way year round.\n * <li>When the offset is explicitly given, the inDaylightSavings() method will \n * always return false.\n * <li>When the id \"local\" is given, this class will attempt to determine the \n * daylight savings time settings by examining the offset from UTC on Jan 1\n * and June 1 of the current year. If they are different, this class assumes\n * that the local time zone uses DST. When the offset for a particular date is\n * requested, it will use the built-in Javascript support to determine the \n * offset for that date.\n * </ul> \n * \n * If a more specific time zone is \n * needed with display names and known start/stop times for DST, use the \"id\" \n * property instead to specify the time zone exactly. You can perhaps ask the\n * user which time zone they prefer so that your app does not need to guess.<p>\n * \n * If the id and the offset are both not given, the default time zone for the \n * locale is retrieved from\n * the locale info. If the locale is not specified, the default locale for the\n * library is used.<p>\n * \n * Because this class was designed for use in web sites, and the vast majority\n * of dates and times being formatted are recent date/times, this class is simplified\n * by not implementing historical time zones. That is, when governments change the \n * time zone rules for a particular zone, only the latest such rule is implemented \n * in this class. That means that determining the offset for a date that is prior \n * to the last change may give the wrong result. Historical time zone calculations\n * may be implemented in a later version of iLib if there is enough demand for it,\n * but it would entail a much larger set of time zone data that would have to be\n * loaded.  \n * \n * \n * @constructor\n * @param {Object} options Options guiding the construction of this time zone instance\n */\n\n\nvar TimeZone = function TimeZone(options) {\n  this.sync = true;\n  this.locale = new Locale();\n  this.isLocal = false;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.id) {\n      var id = options.id.toString();\n\n      if (id === 'local') {\n        this.isLocal = true; // use standard Javascript Date to figure out the time zone offsets\n\n        var now = new Date(),\n            jan1 = new Date(now.getFullYear(), 0, 1),\n            // months in std JS Date object are 0-based\n        jun1 = new Date(now.getFullYear(), 5, 1); // Javascript's method returns the offset backwards, so we have to\n        // take the negative to get the correct offset\n\n        this.offsetJan1 = -jan1.getTimezoneOffset();\n        this.offsetJun1 = -jun1.getTimezoneOffset(); // the offset of the standard time for the time zone is always the one that is closest \n        // to negative infinity of the two, no matter whether you are in the northern or southern \n        // hemisphere, east or west\n\n        this.offset = Math.min(this.offsetJan1, this.offsetJun1);\n      }\n\n      this.id = id;\n    } else if (options.offset) {\n      this.offset = typeof options.offset === 'string' ? parseInt(options.offset, 10) : options.offset;\n      this.id = this.getDisplayName(undefined, undefined);\n    }\n\n    if (typeof options.sync !== 'undefined') {\n      this.sync = !!options.sync;\n    }\n\n    this.loadParams = options.loadParams;\n    this.onLoad = options.onLoad;\n  } //console.log(\"timezone: locale is \" + this.locale);\n\n\n  if (!this.id) {\n    new LocaleInfo(this.locale, {\n      sync: this.sync,\n      loadParams: this.loadParams,\n      onLoad: ilib.bind(this, function (li) {\n        this.id = li.getTimeZone() || \"Etc/UTC\";\n\n        this._loadtzdata();\n      })\n    });\n  } else {\n    this._loadtzdata();\n  } //console.log(\"localeinfo is: \" + JSON.stringify(this.locinfo));\n  //console.log(\"id is: \" + JSON.stringify(this.id));\n\n};\n/*\n * Explanation of the compressed time zone info properties.\n * {\n *     \"o\": \"8:0\",      // offset from UTC\n *     \"f\": \"W{c}T\",    // standard abbreviation. For time zones that observe DST, the {c} replacement is replaced with the \n *                      // letter in the e.c or s.c properties below \n *     \"e\": {           // info about the end of DST\n *         \"j\": 78322.5 // Julian day when the transition happens. Either specify the \"j\" property or all of the \"m\", \"r\", and \n *                      // \"t\" properties, but not both sets.\n *         \"m\": 3,      // month that it ends\n *         \"r\": \"l0\",   // rule for the day it ends \"l\" = \"last\", numbers are Sun=0 through Sat=6. Other syntax is \"0>7\". \n *                      // This means the 0-day (Sun) after the 7th of the month. Other possible operators are <, >, <=, >=\n *         \"t\": \"2:0\",  // time of day that the DST turns off, hours:minutes\n *         \"c\": \"S\"     // character to replace into the abbreviation for standard time \n *     },\n *     \"s\": {           // info about the start of DST\n *         \"j\": 78189.5 // Julian day when the transition happens. Either specify the \"j\" property or all of the \"m\", \"r\", and \n *                      // \"t\" properties, but not both sets.\n *         \"m\": 10,     // month that it starts\n *         \"r\": \"l0\",   // rule for the day it starts \"l\" = \"last\", numbers are Sun=0 through Sat=6. Other syntax is \"0>7\".\n *                      // This means the 0-day (Sun) after the 7th of the month. Other possible operators are <, >, <=, >=\n *         \"t\": \"2:0\",  // time of day that the DST turns on, hours:minutes\n *         \"v\": \"1:0\",  // amount of time saved in hours:minutes\n *         \"c\": \"D\"     // character to replace into the abbreviation for daylight time\n *     },\n *     \"c\": \"AU\",       // ISO code for the country that contains this time zone\n *     \"n\": \"W. Australia {c} Time\"\n *                      // long English name of the zone. The {c} replacement is for the word \"Standard\" or \"Daylight\" as appropriate\n * }\n */\n\n\nTimeZone.prototype._loadtzdata = function () {\n  var zoneName = this.id.replace(/-/g, \"m\").replace(/\\+/g, \"p\"); // console.log(\"id is: \" + JSON.stringify(this.id));\n  // console.log(\"zoneinfo is: \" + JSON.stringify(ilib.data.zoneinfo[zoneName]));\n\n  if (!ilib.data.zoneinfo[zoneName] && typeof this.offset === 'undefined') {\n    Utils.loadData({\n      object: \"TimeZone\",\n      nonlocale: true,\n      // locale independent \n      name: \"zoneinfo/\" + this.id + \".json\",\n      sync: this.sync,\n      loadParams: this.loadParams,\n      callback: ilib.bind(this, function (tzdata) {\n        if (tzdata && !JSUtils.isEmpty(tzdata)) {\n          ilib.data.zoneinfo[zoneName] = tzdata;\n        }\n\n        this._initZone(zoneName);\n      })\n    });\n  } else {\n    this._initZone(zoneName);\n  }\n};\n\nTimeZone.prototype._initZone = function (zoneName) {\n  /** \n   * @private\n   * @type {{o:string,f:string,e:Object.<{m:number,r:string,t:string,z:string}>,s:Object.<{m:number,r:string,t:string,z:string,v:string,c:string}>,c:string,n:string}} \n   */\n  this.zone = ilib.data.zoneinfo[zoneName];\n\n  if (!this.zone && typeof this.offset === 'undefined') {\n    this.id = \"Etc/UTC\";\n    this.zone = ilib.data.zoneinfo[this.id];\n  }\n\n  this._calcDSTSavings();\n\n  if (typeof this.offset === 'undefined' && this.zone.o) {\n    var offsetParts = this._offsetStringToObj(this.zone.o);\n    /**\n     * @private\n     * @type {number} raw offset from UTC without DST, in minutes\n     */\n\n\n    this.offset = (Math.abs(offsetParts.h || 0) * 60 + (offsetParts.m || 0)) * MathUtils.signum(offsetParts.h || 0);\n  }\n\n  if (this.onLoad && typeof this.onLoad === 'function') {\n    this.onLoad(this);\n  }\n};\n/** @private */\n\n\nTimeZone._marshallIds = function (country, sync, callback) {\n  var tz,\n      ids = [];\n\n  if (!country) {\n    // local is a special zone meaning \"the local time zone according to the JS engine we are running upon\"\n    ids.push(\"local\");\n\n    for (tz in ilib.data.timezones) {\n      if (ilib.data.timezones[tz]) {\n        ids.push(ilib.data.timezones[tz]);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(ids);\n    }\n  } else {\n    if (!ilib.data.zoneinfo.zonetab) {\n      Utils.loadData({\n        object: \"TimeZone\",\n        nonlocale: true,\n        // locale independent \n        name: \"zoneinfo/zonetab.json\",\n        sync: sync,\n        callback: ilib.bind(this, function (tzdata) {\n          if (tzdata) {\n            ilib.data.zoneinfo.zonetab = tzdata;\n          }\n\n          ids = ilib.data.zoneinfo.zonetab[country];\n\n          if (typeof callback === 'function') {\n            callback(ids);\n          }\n        })\n      });\n    } else {\n      ids = ilib.data.zoneinfo.zonetab[country];\n\n      if (typeof callback === 'function') {\n        callback(ids);\n      }\n    }\n  }\n\n  return ids;\n};\n/**\n * Return an array of available zone ids that the constructor knows about.\n * The country parameter is optional. If it is not given, all time zones will\n * be returned. If it specifies a country code, then only time zones for that\n * country will be returned.\n * \n * @param {string|undefined} country country code for which time zones are being sought\n * @param {boolean} sync whether to find the available ids synchronously (true) or asynchronously (false)\n * @param {function(Array.<string>)} onLoad callback function to call when the data is finished loading\n * @return {Array.<string>} an array of zone id strings\n */\n\n\nTimeZone.getAvailableIds = function (country, sync, onLoad) {\n  var tz,\n      ids = [];\n\n  if (typeof sync !== 'boolean') {\n    sync = true;\n  }\n\n  if (ilib.data.timezones.length === 0) {\n    if (typeof ilib._load !== 'undefined' && typeof ilib._load.listAvailableFiles === 'function') {\n      ilib._load.listAvailableFiles(sync, function (hash) {\n        for (var dir in hash) {\n          var files = hash[dir];\n\n          if (ilib.isArray(files)) {\n            files.forEach(function (filename) {\n              if (filename && filename.match(/^zoneinfo/)) {\n                ilib.data.timezones.push(filename.replace(/^zoneinfo\\//, \"\").replace(/\\.json$/, \"\"));\n              }\n            });\n          }\n        }\n\n        ids = TimeZone._marshallIds(country, sync, onLoad);\n      });\n    } else {\n      for (tz in ilib.data.zoneinfo) {\n        if (ilib.data.zoneinfo[tz]) {\n          ilib.data.timezones.push(tz);\n        }\n      }\n\n      ids = TimeZone._marshallIds(country, sync, onLoad);\n    }\n  } else {\n    ids = TimeZone._marshallIds(country, sync, onLoad);\n  }\n\n  return ids;\n};\n/**\n * Return the id used to uniquely identify this time zone.\n * @return {string} a unique id for this time zone\n */\n\n\nTimeZone.prototype.getId = function () {\n  return this.id.toString();\n};\n/**\n * Return the abbreviation that is used for the current time zone on the given date.\n * The date may be in DST or during standard time, and many zone names have different\n * abbreviations depending on whether or not the date is falls within DST.<p>\n * \n * There are two styles that are supported:\n * \n * <ol>\n * <li>standard - returns the 3 to 5 letter abbreviation of the time zone name such \n * as \"CET\" for \"Central European Time\" or \"PDT\" for \"Pacific Daylight Time\"\n * <li>rfc822 - returns an RFC 822 style time zone specifier, which specifies more\n * explicitly what the offset is from UTC\n * <li>long - returns the long name of the zone in English\n * </ol>\n *  \n * @param {IDate=} date a date to determine if it is in daylight time or standard time\n * @param {string=} style one of \"standard\" or \"rfc822\". Default if not specified is \"standard\"\n * @return {string} the name of the time zone, abbreviated according to the style \n */\n\n\nTimeZone.prototype.getDisplayName = function (date, style) {\n  style = this.isLocal || typeof this.zone === 'undefined' ? \"rfc822\" : style || \"standard\";\n\n  switch (style) {\n    default:\n    case 'standard':\n      if (this.zone.f && this.zone.f !== \"zzz\") {\n        if (this.zone.f.indexOf(\"{c}\") !== -1) {\n          var letter = \"\";\n          letter = this.inDaylightTime(date) ? this.zone.s && this.zone.s.c : this.zone.e && this.zone.e.c;\n          var temp = new IString(this.zone.f);\n          return temp.format({\n            c: letter || \"\"\n          });\n        }\n\n        return this.zone.f;\n      }\n\n      var temp = \"GMT\" + this.zone.o;\n\n      if (this.inDaylightTime(date)) {\n        temp += \"+\" + this.zone.s.v;\n      }\n\n      return temp;\n      break;\n\n    case 'rfc822':\n      var offset = this.getOffset(date),\n          // includes the DST if applicable\n      ret = \"UTC\",\n          hour = offset.h || 0,\n          minute = offset.m || 0;\n\n      if (hour !== 0) {\n        ret += hour > 0 ? \"+\" : \"-\";\n\n        if (Math.abs(hour) < 10) {\n          ret += \"0\";\n        }\n\n        ret += hour < 0 ? -hour : hour;\n\n        if (minute < 10) {\n          ret += \"0\";\n        }\n\n        ret += minute;\n      }\n\n      return ret;\n\n    case 'long':\n      if (this.zone.n) {\n        if (this.zone.n.indexOf(\"{c}\") !== -1) {\n          var str = this.inDaylightTime(date) ? \"Daylight\" : \"Standard\";\n          var temp = new IString(this.zone.n);\n          return temp.format({\n            c: str || \"\"\n          });\n        }\n\n        return this.zone.n;\n      }\n\n      var temp = \"GMT\" + this.zone.o;\n\n      if (this.inDaylightTime(date)) {\n        temp += \"+\" + this.zone.s.v;\n      }\n\n      return temp;\n      break;\n  }\n};\n/**\n * Convert the offset string to an object with an h, m, and possibly s property\n * to indicate the hours, minutes, and seconds.\n * \n * @private\n * @param {string} str the offset string to convert to an object\n * @return {Object.<{h:number,m:number,s:number}>} an object giving the offset for the zone at \n * the given date/time, in hours, minutes, and seconds\n */\n\n\nTimeZone.prototype._offsetStringToObj = function (str) {\n  var offsetParts = typeof str === 'string' ? str.split(\":\") : [],\n      ret = {\n    h: 0\n  },\n      temp;\n\n  if (offsetParts.length > 0) {\n    ret.h = parseInt(offsetParts[0], 10);\n\n    if (offsetParts.length > 1) {\n      temp = parseInt(offsetParts[1], 10);\n\n      if (temp) {\n        ret.m = temp;\n      }\n\n      if (offsetParts.length > 2) {\n        temp = parseInt(offsetParts[2], 10);\n\n        if (temp) {\n          ret.s = temp;\n        }\n      }\n    }\n  }\n\n  return ret;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving.\n * @param {IDate=} date the date for which the offset is needed\n * @return {Object.<{h:number,m:number}>} an object giving the offset for the zone at \n * the given date/time, in hours, minutes, and seconds  \n */\n\n\nTimeZone.prototype.getOffset = function (date) {\n  if (!date) {\n    return this.getRawOffset();\n  }\n\n  var offset = this.getOffsetMillis(date) / 60000;\n  var hours = MathUtils.down(offset / 60),\n      minutes = Math.abs(offset) - Math.abs(hours) * 60;\n  var ret = {\n    h: hours\n  };\n\n  if (minutes != 0) {\n    ret.m = minutes;\n  }\n\n  return ret;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time expressed in \n * milliseconds. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving. Negative numbers indicate offsets west\n * of UTC and conversely, positive numbers indicate offset east of UTC.\n *  \n * @param {IDate=} date the date for which the offset is needed, or null for the\n * present date\n * @return {number} the number of milliseconds of offset from UTC that the given date is\n */\n\n\nTimeZone.prototype.getOffsetMillis = function (date) {\n  var ret; // check if the dst property is defined -- the intrinsic JS Date object doesn't work so\n  // well if we are in the overlap time at the end of DST\n\n  if (this.isLocal && typeof date.dst === 'undefined') {\n    var d = !date ? new Date() : new Date(date.getTimeExtended());\n    return -d.getTimezoneOffset() * 60000;\n  }\n\n  ret = this.offset;\n\n  if (date && this.inDaylightTime(date)) {\n    ret += this.dstSavings;\n  }\n\n  return ret * 60000;\n};\n/**\n * Return the offset in milliseconds when the date has an RD number in wall\n * time rather than in UTC time.\n * @protected\n * @param date the date to check in wall time\n * @returns {number} the number of milliseconds of offset from UTC that the given date is\n */\n\n\nTimeZone.prototype._getOffsetMillisWallTime = function (date) {\n  var ret;\n  ret = this.offset;\n\n  if (date && this.inDaylightTime(date, true)) {\n    ret += this.dstSavings;\n  }\n\n  return ret * 60000;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving.\n * @param {IDate=} date the date for which the offset is needed\n * @return {string} the offset for the zone at the given date/time as a string in the \n * format \"h:m:s\" \n */\n\n\nTimeZone.prototype.getOffsetStr = function (date) {\n  var offset = this.getOffset(date),\n      ret;\n  ret = offset.h;\n\n  if (typeof offset.m !== 'undefined') {\n    ret += \":\" + offset.m;\n\n    if (typeof offset.s !== 'undefined') {\n      ret += \":\" + offset.s;\n    }\n  } else {\n    ret += \":0\";\n  }\n\n  return ret;\n};\n/**\n * Gets the offset from UTC for this time zone.\n * @return {Object.<{h:number,m:number,s:number}>} an object giving the offset from \n * UTC for this time zone, in hours, minutes, and seconds \n */\n\n\nTimeZone.prototype.getRawOffset = function () {\n  var hours = MathUtils.down(this.offset / 60),\n      minutes = Math.abs(this.offset) - Math.abs(hours) * 60;\n  var ret = {\n    h: hours\n  };\n\n  if (minutes != 0) {\n    ret.m = minutes;\n  }\n\n  return ret;\n};\n/**\n * Gets the offset from UTC for this time zone expressed in milliseconds. Negative numbers\n * indicate zones west of UTC, and positive numbers indicate zones east of UTC.\n * \n * @return {number} an number giving the offset from \n * UTC for this time zone in milliseconds \n */\n\n\nTimeZone.prototype.getRawOffsetMillis = function () {\n  return this.offset * 60000;\n};\n/**\n * Gets the offset from UTC for this time zone without DST savings.\n * @return {string} the offset from UTC for this time zone, in the format \"h:m:s\" \n */\n\n\nTimeZone.prototype.getRawOffsetStr = function () {\n  var off = this.getRawOffset();\n  return off.h + \":\" + (off.m || \"0\");\n};\n/**\n * Return the amount of time in hours:minutes that the clock is advanced during\n * daylight savings time.\n * @return {Object.<{h:number,m:number,s:number}>} the amount of time that the \n * clock advances for DST in hours, minutes, and seconds \n */\n\n\nTimeZone.prototype.getDSTSavings = function () {\n  if (this.isLocal) {\n    // take the absolute because the difference in the offsets may be positive or\n    // negative, depending on the hemisphere\n    var savings = Math.abs(this.offsetJan1 - this.offsetJun1);\n    var hours = MathUtils.down(savings / 60),\n        minutes = savings - hours * 60;\n    return {\n      h: hours,\n      m: minutes\n    };\n  } else if (this.zone && this.zone.s) {\n    return this._offsetStringToObj(this.zone.s.v); // this.zone.start.savings\n  }\n\n  return {\n    h: 0\n  };\n};\n/**\n * Return the amount of time in hours:minutes that the clock is advanced during\n * daylight savings time.\n * @return {string} the amount of time that the clock advances for DST in the\n * format \"h:m:s\"\n */\n\n\nTimeZone.prototype.getDSTSavingsStr = function () {\n  if (this.isLocal) {\n    var savings = this.getDSTSavings();\n    return savings.h + \":\" + savings.m;\n  } else if (typeof this.offset !== 'undefined' && this.zone && this.zone.s) {\n    return this.zone.s.v; // this.zone.start.savings\n  }\n\n  return \"0:0\";\n};\n/**\n * return the rd of the start of DST transition for the given year\n * @protected\n * @param {Object} rule set of rules\n * @param {number} year year to check\n * @return {number} the rd of the start of DST for the year\n */\n\n\nTimeZone.prototype._calcRuleStart = function (rule, year) {\n  var type = \"=\",\n      weekday = 0,\n      day,\n      refDay,\n      cal,\n      hour = 0,\n      minute = 0,\n      second = 0,\n      time,\n      i;\n\n  if (typeof rule.j !== 'undefined') {\n    refDay = new GregRataDie({\n      julianday: rule.j\n    });\n  } else {\n    if (rule.r.charAt(0) == 'l' || rule.r.charAt(0) == 'f') {\n      cal = CalendarFactory({\n        type: \"gregorian\"\n      }); // can be synchronous\n\n      type = rule.r.charAt(0);\n      weekday = parseInt(rule.r.substring(1), 10);\n      day = type === 'l' ? cal.getMonLength(rule.m, year) : 1; //console.log(\"_calcRuleStart: Calculating the \" + \n      //\t\t(rule.r.charAt(0) == 'f' ? \"first \" : \"last \") + weekday + \n      //\t\t\" of month \" + rule.m);\n    } else {\n      i = rule.r.indexOf('<');\n\n      if (i == -1) {\n        i = rule.r.indexOf('>');\n      }\n\n      if (i != -1) {\n        type = rule.r.charAt(i);\n        weekday = parseInt(rule.r.substring(0, i), 10);\n        day = parseInt(rule.r.substring(i + 1), 10); //console.log(\"_calcRuleStart: Calculating the \" + weekday + \n        //\t\ttype + day + \" of month \" + rule.m);\n      } else {\n        day = parseInt(rule.r, 10); //console.log(\"_calcRuleStart: Calculating the \" + day + \" of month \" + rule.m);\n      }\n    }\n\n    if (rule.t) {\n      time = rule.t.split(\":\");\n      hour = parseInt(time[0], 10);\n\n      if (time.length > 1) {\n        minute = parseInt(time[1], 10);\n\n        if (time.length > 2) {\n          second = parseInt(time[2], 10);\n        }\n      }\n    } //console.log(\"calculating rd of \" + year + \"/\" + rule.m + \"/\" + day);\n\n\n    refDay = new GregRataDie({\n      year: year,\n      month: rule.m,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second\n    });\n  } //console.log(\"refDay is \" + JSON.stringify(refDay));\n\n\n  var d = refDay.getRataDie();\n\n  switch (type) {\n    case 'l':\n    case '<':\n      //console.log(\"returning \" + refDay.onOrBefore(rd, weekday));\n      d = refDay.onOrBefore(weekday);\n      break;\n\n    case 'f':\n    case '>':\n      //console.log(\"returning \" + refDay.onOrAfterRd(rd, weekday));\n      d = refDay.onOrAfter(weekday);\n      break;\n  }\n\n  return d;\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._calcDSTSavings = function () {\n  var saveParts = this.getDSTSavings();\n  /**\n   * @private\n   * @type {number} savings in minutes when DST is in effect \n   */\n\n  this.dstSavings = (Math.abs(saveParts.h || 0) * 60 + (saveParts.m || 0)) * MathUtils.signum(saveParts.h || 0);\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._getDSTStartRule = function (year) {\n  // TODO: update this when historic/future zones are supported\n  return this.zone.s;\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._getDSTEndRule = function (year) {\n  // TODO: update this when historic/future zones are supported\n  return this.zone.e;\n};\n/**\n * Returns whether or not the given date is in daylight saving time for the current\n * zone. Note that daylight savings time is observed for the summer. Because\n * the seasons are reversed, daylight savings time in the southern hemisphere usually\n * runs from the end of the year through New Years into the first few months of the\n * next year. This method will correctly calculate the start and end of DST for any\n * location.\n * \n * @param {IDate=} date a date for which the info about daylight time is being sought,\n * or undefined to tell whether we are currently in daylight savings time\n * @param {boolean=} wallTime if true, then the given date is in wall time. If false or\n * undefined, it is in the usual UTC time.\n * @return {boolean} true if the given date is in DST for the current zone, and false\n * otherwise.\n */\n\n\nTimeZone.prototype.inDaylightTime = function (date, wallTime) {\n  var rd, startRd, endRd, year;\n\n  if (this.isLocal) {\n    // check if the dst property is defined -- the intrinsic JS Date object doesn't work so\n    // well if we are in the overlap time at the end of DST, so we have to work around that\n    // problem by adding in the savings ourselves\n    var offset = this.offset * 60000;\n\n    if (typeof date.dst !== 'undefined' && !date.dst) {\n      offset += this.dstSavings * 60000;\n    }\n\n    var d = new Date(date ? date.getTimeExtended() - offset : undefined); // the DST offset is always the one that is closest to positive infinity, no matter \n    // if you are in the northern or southern hemisphere, east or west\n\n    var dst = Math.max(this.offsetJan1, this.offsetJun1);\n    return -d.getTimezoneOffset() === dst;\n  }\n\n  if (!date || !date.cal || date.cal.type !== \"gregorian\") {\n    // convert to Gregorian so that we can tell if it is in DST or not\n    var time = date && typeof date.getTimeExtended === 'function' ? date.getTimeExtended() : undefined;\n    rd = new GregRataDie({\n      unixtime: time\n    }).getRataDie();\n    year = new Date(time).getUTCFullYear();\n  } else {\n    rd = date.rd.getRataDie();\n    year = date.year;\n  } // rd should be a Gregorian RD number now, in UTC\n  // if we aren't using daylight time in this zone for the given year, then we are \n  // not in daylight time\n\n\n  if (!this.useDaylightTime(year)) {\n    return false;\n  } // these calculate the start/end in local wall time\n\n\n  var startrule = this._getDSTStartRule(year);\n\n  var endrule = this._getDSTEndRule(year);\n\n  startRd = this._calcRuleStart(startrule, year);\n  endRd = this._calcRuleStart(endrule, year);\n\n  if (wallTime) {\n    // rd is in wall time, so we have to make sure to skip the missing time\n    // at the start of DST when standard time ends and daylight time begins\n    startRd += this.dstSavings / 1440;\n  } else {\n    // rd is in UTC, so we have to convert the start/end to UTC time so \n    // that they can be compared directly to the UTC rd number of the date\n    // when DST starts, time is standard time already, so we only have\n    // to subtract the offset to get to UTC and not worry about the DST savings\n    startRd -= this.offset / 1440; // when DST ends, time is in daylight time already, so we have to\n    // subtract the DST savings to get back to standard time, then the\n    // offset to get to UTC\n\n    endRd -= (this.offset + this.dstSavings) / 1440;\n  } // In the northern hemisphere, the start comes first some time in spring (Feb-Apr), \n  // then the end some time in the fall (Sept-Nov). In the southern\n  // hemisphere, it is the other way around because the seasons are reversed. Standard\n  // time is still in the winter, but the winter months are May-Aug, and daylight \n  // savings time usually starts Aug-Oct of one year and runs through Mar-May of the \n  // next year.\n\n\n  if (rd < endRd && endRd - rd <= this.dstSavings / 1440 && typeof date.dst === 'boolean') {\n    // take care of the magic overlap time at the end of DST\n    return date.dst;\n  }\n\n  if (startRd < endRd) {\n    // northern hemisphere\n    return rd >= startRd && rd < endRd ? true : false;\n  } // southern hemisphere\n\n\n  return rd >= startRd || rd < endRd ? true : false;\n};\n/**\n * Returns true if this time zone switches to daylight savings time at some point\n * in the year, and false otherwise.\n * @param {number} year Whether or not the time zone uses daylight time in the given year. If\n * this parameter is not given, the current year is assumed.\n * @return {boolean} true if the time zone uses daylight savings time\n */\n\n\nTimeZone.prototype.useDaylightTime = function (year) {\n  // this zone uses daylight savings time iff there is a rule defining when to start\n  // and when to stop the DST\n  return this.isLocal && this.offsetJan1 !== this.offsetJun1 || typeof this.zone !== 'undefined' && typeof this.zone.s !== 'undefined' && typeof this.zone.e !== 'undefined';\n};\n/**\n * Returns the ISO 3166 code of the country for which this time zone is defined.\n * @return {string} the ISO 3166 code of the country for this zone\n */\n\n\nTimeZone.prototype.getCountry = function () {\n  return this.zone.c;\n};\n\nmodule.exports = TimeZone;","map":{"version":3,"sources":["F:\\books\\vscode\\enact\\final\\SteApp\\node_modules\\@enact\\i18n\\ilib\\lib\\TimeZone.js"],"names":["ilib","require","Utils","MathUtils","JSUtils","Locale","LocaleInfo","GregRataDie","CalendarFactory","IString","TimeZone","options","sync","locale","isLocal","id","toString","now","Date","jan1","getFullYear","jun1","offsetJan1","getTimezoneOffset","offsetJun1","offset","Math","min","parseInt","getDisplayName","undefined","loadParams","onLoad","bind","li","getTimeZone","_loadtzdata","prototype","zoneName","replace","data","zoneinfo","loadData","object","nonlocale","name","callback","tzdata","isEmpty","_initZone","zone","_calcDSTSavings","o","offsetParts","_offsetStringToObj","abs","h","m","signum","_marshallIds","country","tz","ids","push","timezones","zonetab","getAvailableIds","length","_load","listAvailableFiles","hash","dir","files","isArray","forEach","filename","match","getId","date","style","f","indexOf","letter","inDaylightTime","s","c","e","temp","format","v","getOffset","ret","hour","minute","n","str","split","getRawOffset","getOffsetMillis","hours","down","minutes","dst","d","getTimeExtended","dstSavings","_getOffsetMillisWallTime","getOffsetStr","getRawOffsetMillis","getRawOffsetStr","off","getDSTSavings","savings","getDSTSavingsStr","_calcRuleStart","rule","year","type","weekday","day","refDay","cal","second","time","i","j","julianday","r","charAt","substring","getMonLength","t","month","getRataDie","onOrBefore","onOrAfter","saveParts","_getDSTStartRule","_getDSTEndRule","wallTime","rd","startRd","endRd","max","unixtime","getUTCFullYear","useDaylightTime","startrule","endrule","getCountry","module","exports"],"mappings":"AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;AAYA;;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,WAAD,CAAlB;;AAEA,IAAIC,KAAK,GAAGD,OAAO,CAAC,YAAD,CAAnB;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,gBAAD,CAAvB;;AAEA,IAAIG,OAAO,GAAGH,OAAO,CAAC,cAAD,CAArB;;AAEA,IAAII,MAAM,GAAGJ,OAAO,CAAC,aAAD,CAApB;;AAEA,IAAIK,UAAU,GAAGL,OAAO,CAAC,iBAAD,CAAxB;;AAEA,IAAIM,WAAW,GAAGN,OAAO,CAAC,kBAAD,CAAzB;;AAEA,IAAIO,eAAe,GAAGP,OAAO,CAAC,sBAAD,CAA7B;;AAEA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,cAAD,CAArB;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FA,IAAIS,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACxC,OAAKC,IAAL,GAAY,IAAZ;AACA,OAAKC,MAAL,GAAc,IAAIR,MAAJ,EAAd;AACA,OAAKS,OAAL,GAAe,KAAf;;AAEA,MAAIH,OAAJ,EAAa;AACX,QAAIA,OAAO,CAACE,MAAZ,EAAoB;AAClB,WAAKA,MAAL,GAAc,OAAOF,OAAO,CAACE,MAAf,KAA0B,QAA1B,GAAqC,IAAIR,MAAJ,CAAWM,OAAO,CAACE,MAAnB,CAArC,GAAkEF,OAAO,CAACE,MAAxF;AACD;;AAED,QAAIF,OAAO,CAACI,EAAZ,EAAgB;AACd,UAAIA,EAAE,GAAGJ,OAAO,CAACI,EAAR,CAAWC,QAAX,EAAT;;AAEA,UAAID,EAAE,KAAK,OAAX,EAAoB;AAClB,aAAKD,OAAL,GAAe,IAAf,CADkB,CACG;;AAErB,YAAIG,GAAG,GAAG,IAAIC,IAAJ,EAAV;AAAA,YACIC,IAAI,GAAG,IAAID,IAAJ,CAASD,GAAG,CAACG,WAAJ,EAAT,EAA4B,CAA5B,EAA+B,CAA/B,CADX;AAAA,YAEI;AACJC,QAAAA,IAAI,GAAG,IAAIH,IAAJ,CAASD,GAAG,CAACG,WAAJ,EAAT,EAA4B,CAA5B,EAA+B,CAA/B,CAHP,CAHkB,CAMwB;AAC1C;;AAEA,aAAKE,UAAL,GAAkB,CAACH,IAAI,CAACI,iBAAL,EAAnB;AACA,aAAKC,UAAL,GAAkB,CAACH,IAAI,CAACE,iBAAL,EAAnB,CAVkB,CAU2B;AAC7C;AACA;;AAEA,aAAKE,MAAL,GAAcC,IAAI,CAACC,GAAL,CAAS,KAAKL,UAAd,EAA0B,KAAKE,UAA/B,CAAd;AACD;;AAED,WAAKT,EAAL,GAAUA,EAAV;AACD,KArBD,MAqBO,IAAIJ,OAAO,CAACc,MAAZ,EAAoB;AACzB,WAAKA,MAAL,GAAc,OAAOd,OAAO,CAACc,MAAf,KAA0B,QAA1B,GAAqCG,QAAQ,CAACjB,OAAO,CAACc,MAAT,EAAiB,EAAjB,CAA7C,GAAoEd,OAAO,CAACc,MAA1F;AACA,WAAKV,EAAL,GAAU,KAAKc,cAAL,CAAoBC,SAApB,EAA+BA,SAA/B,CAAV;AACD;;AAED,QAAI,OAAOnB,OAAO,CAACC,IAAf,KAAwB,WAA5B,EAAyC;AACvC,WAAKA,IAAL,GAAY,CAAC,CAACD,OAAO,CAACC,IAAtB;AACD;;AAED,SAAKmB,UAAL,GAAkBpB,OAAO,CAACoB,UAA1B;AACA,SAAKC,MAAL,GAAcrB,OAAO,CAACqB,MAAtB;AACD,GA1CuC,CA0CtC;;;AAGF,MAAI,CAAC,KAAKjB,EAAV,EAAc;AACZ,QAAIT,UAAJ,CAAe,KAAKO,MAApB,EAA4B;AAC1BD,MAAAA,IAAI,EAAE,KAAKA,IADe;AAE1BmB,MAAAA,UAAU,EAAE,KAAKA,UAFS;AAG1BC,MAAAA,MAAM,EAAEhC,IAAI,CAACiC,IAAL,CAAU,IAAV,EAAgB,UAAUC,EAAV,EAAc;AACpC,aAAKnB,EAAL,GAAUmB,EAAE,CAACC,WAAH,MAAoB,SAA9B;;AAEA,aAAKC,WAAL;AACD,OAJO;AAHkB,KAA5B;AASD,GAVD,MAUO;AACL,SAAKA,WAAL;AACD,GAzDuC,CAyDtC;AACF;;AAED,CA5DD;AA6DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA1B,QAAQ,CAAC2B,SAAT,CAAmBD,WAAnB,GAAiC,YAAY;AAC3C,MAAIE,QAAQ,GAAG,KAAKvB,EAAL,CAAQwB,OAAR,CAAgB,IAAhB,EAAsB,GAAtB,EAA2BA,OAA3B,CAAmC,KAAnC,EAA0C,GAA1C,CAAf,CAD2C,CACoB;AAC/D;;AAEA,MAAI,CAACvC,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBH,QAAnB,CAAD,IAAiC,OAAO,KAAKb,MAAZ,KAAuB,WAA5D,EAAyE;AACvEvB,IAAAA,KAAK,CAACwC,QAAN,CAAe;AACbC,MAAAA,MAAM,EAAE,UADK;AAEbC,MAAAA,SAAS,EAAE,IAFE;AAGb;AACAC,MAAAA,IAAI,EAAE,cAAc,KAAK9B,EAAnB,GAAwB,OAJjB;AAKbH,MAAAA,IAAI,EAAE,KAAKA,IALE;AAMbmB,MAAAA,UAAU,EAAE,KAAKA,UANJ;AAObe,MAAAA,QAAQ,EAAE9C,IAAI,CAACiC,IAAL,CAAU,IAAV,EAAgB,UAAUc,MAAV,EAAkB;AAC1C,YAAIA,MAAM,IAAI,CAAC3C,OAAO,CAAC4C,OAAR,CAAgBD,MAAhB,CAAf,EAAwC;AACtC/C,UAAAA,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBH,QAAnB,IAA+BS,MAA/B;AACD;;AAED,aAAKE,SAAL,CAAeX,QAAf;AACD,OANS;AAPG,KAAf;AAeD,GAhBD,MAgBO;AACL,SAAKW,SAAL,CAAeX,QAAf;AACD;AACF,CAvBD;;AAyBA5B,QAAQ,CAAC2B,SAAT,CAAmBY,SAAnB,GAA+B,UAAUX,QAAV,EAAoB;AACjD;;;;AAIA,OAAKY,IAAL,GAAYlD,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBH,QAAnB,CAAZ;;AAEA,MAAI,CAAC,KAAKY,IAAN,IAAc,OAAO,KAAKzB,MAAZ,KAAuB,WAAzC,EAAsD;AACpD,SAAKV,EAAL,GAAU,SAAV;AACA,SAAKmC,IAAL,GAAYlD,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmB,KAAK1B,EAAxB,CAAZ;AACD;;AAED,OAAKoC,eAAL;;AAEA,MAAI,OAAO,KAAK1B,MAAZ,KAAuB,WAAvB,IAAsC,KAAKyB,IAAL,CAAUE,CAApD,EAAuD;AACrD,QAAIC,WAAW,GAAG,KAAKC,kBAAL,CAAwB,KAAKJ,IAAL,CAAUE,CAAlC,CAAlB;AACA;;;;;;AAMA,SAAK3B,MAAL,GAAc,CAACC,IAAI,CAAC6B,GAAL,CAASF,WAAW,CAACG,CAAZ,IAAiB,CAA1B,IAA+B,EAA/B,IAAqCH,WAAW,CAACI,CAAZ,IAAiB,CAAtD,CAAD,IAA6DtD,SAAS,CAACuD,MAAV,CAAiBL,WAAW,CAACG,CAAZ,IAAiB,CAAlC,CAA3E;AACD;;AAED,MAAI,KAAKxB,MAAL,IAAe,OAAO,KAAKA,MAAZ,KAAuB,UAA1C,EAAsD;AACpD,SAAKA,MAAL,CAAY,IAAZ;AACD;AACF,CA5BD;AA6BA;;;AAGAtB,QAAQ,CAACiD,YAAT,GAAwB,UAAUC,OAAV,EAAmBhD,IAAnB,EAAyBkC,QAAzB,EAAmC;AACzD,MAAIe,EAAJ;AAAA,MACIC,GAAG,GAAG,EADV;;AAGA,MAAI,CAACF,OAAL,EAAc;AACZ;AACAE,IAAAA,GAAG,CAACC,IAAJ,CAAS,OAAT;;AAEA,SAAKF,EAAL,IAAW7D,IAAI,CAACwC,IAAL,CAAUwB,SAArB,EAAgC;AAC9B,UAAIhE,IAAI,CAACwC,IAAL,CAAUwB,SAAV,CAAoBH,EAApB,CAAJ,EAA6B;AAC3BC,QAAAA,GAAG,CAACC,IAAJ,CAAS/D,IAAI,CAACwC,IAAL,CAAUwB,SAAV,CAAoBH,EAApB,CAAT;AACD;AACF;;AAED,QAAI,OAAOf,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,MAAAA,QAAQ,CAACgB,GAAD,CAAR;AACD;AACF,GAbD,MAaO;AACL,QAAI,CAAC9D,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBwB,OAAxB,EAAiC;AAC/B/D,MAAAA,KAAK,CAACwC,QAAN,CAAe;AACbC,QAAAA,MAAM,EAAE,UADK;AAEbC,QAAAA,SAAS,EAAE,IAFE;AAGb;AACAC,QAAAA,IAAI,EAAE,uBAJO;AAKbjC,QAAAA,IAAI,EAAEA,IALO;AAMbkC,QAAAA,QAAQ,EAAE9C,IAAI,CAACiC,IAAL,CAAU,IAAV,EAAgB,UAAUc,MAAV,EAAkB;AAC1C,cAAIA,MAAJ,EAAY;AACV/C,YAAAA,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBwB,OAAnB,GAA6BlB,MAA7B;AACD;;AAEDe,UAAAA,GAAG,GAAG9D,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBwB,OAAnB,CAA2BL,OAA3B,CAAN;;AAEA,cAAI,OAAOd,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,YAAAA,QAAQ,CAACgB,GAAD,CAAR;AACD;AACF,SAVS;AANG,OAAf;AAkBD,KAnBD,MAmBO;AACLA,MAAAA,GAAG,GAAG9D,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBwB,OAAnB,CAA2BL,OAA3B,CAAN;;AAEA,UAAI,OAAOd,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,QAAAA,QAAQ,CAACgB,GAAD,CAAR;AACD;AACF;AACF;;AAED,SAAOA,GAAP;AACD,CA/CD;AAgDA;;;;;;;;;;;;;AAaApD,QAAQ,CAACwD,eAAT,GAA2B,UAAUN,OAAV,EAAmBhD,IAAnB,EAAyBoB,MAAzB,EAAiC;AAC1D,MAAI6B,EAAJ;AAAA,MACIC,GAAG,GAAG,EADV;;AAGA,MAAI,OAAOlD,IAAP,KAAgB,SAApB,EAA+B;AAC7BA,IAAAA,IAAI,GAAG,IAAP;AACD;;AAED,MAAIZ,IAAI,CAACwC,IAAL,CAAUwB,SAAV,CAAoBG,MAApB,KAA+B,CAAnC,EAAsC;AACpC,QAAI,OAAOnE,IAAI,CAACoE,KAAZ,KAAsB,WAAtB,IAAqC,OAAOpE,IAAI,CAACoE,KAAL,CAAWC,kBAAlB,KAAyC,UAAlF,EAA8F;AAC5FrE,MAAAA,IAAI,CAACoE,KAAL,CAAWC,kBAAX,CAA8BzD,IAA9B,EAAoC,UAAU0D,IAAV,EAAgB;AAClD,aAAK,IAAIC,GAAT,IAAgBD,IAAhB,EAAsB;AACpB,cAAIE,KAAK,GAAGF,IAAI,CAACC,GAAD,CAAhB;;AAEA,cAAIvE,IAAI,CAACyE,OAAL,CAAaD,KAAb,CAAJ,EAAyB;AACvBA,YAAAA,KAAK,CAACE,OAAN,CAAc,UAAUC,QAAV,EAAoB;AAChC,kBAAIA,QAAQ,IAAIA,QAAQ,CAACC,KAAT,CAAe,WAAf,CAAhB,EAA6C;AAC3C5E,gBAAAA,IAAI,CAACwC,IAAL,CAAUwB,SAAV,CAAoBD,IAApB,CAAyBY,QAAQ,CAACpC,OAAT,CAAiB,aAAjB,EAAgC,EAAhC,EAAoCA,OAApC,CAA4C,SAA5C,EAAuD,EAAvD,CAAzB;AACD;AACF,aAJD;AAKD;AACF;;AAEDuB,QAAAA,GAAG,GAAGpD,QAAQ,CAACiD,YAAT,CAAsBC,OAAtB,EAA+BhD,IAA/B,EAAqCoB,MAArC,CAAN;AACD,OAdD;AAeD,KAhBD,MAgBO;AACL,WAAK6B,EAAL,IAAW7D,IAAI,CAACwC,IAAL,CAAUC,QAArB,EAA+B;AAC7B,YAAIzC,IAAI,CAACwC,IAAL,CAAUC,QAAV,CAAmBoB,EAAnB,CAAJ,EAA4B;AAC1B7D,UAAAA,IAAI,CAACwC,IAAL,CAAUwB,SAAV,CAAoBD,IAApB,CAAyBF,EAAzB;AACD;AACF;;AAEDC,MAAAA,GAAG,GAAGpD,QAAQ,CAACiD,YAAT,CAAsBC,OAAtB,EAA+BhD,IAA/B,EAAqCoB,MAArC,CAAN;AACD;AACF,GA1BD,MA0BO;AACL8B,IAAAA,GAAG,GAAGpD,QAAQ,CAACiD,YAAT,CAAsBC,OAAtB,EAA+BhD,IAA/B,EAAqCoB,MAArC,CAAN;AACD;;AAED,SAAO8B,GAAP;AACD,CAvCD;AAwCA;;;;;;AAMApD,QAAQ,CAAC2B,SAAT,CAAmBwC,KAAnB,GAA2B,YAAY;AACrC,SAAO,KAAK9D,EAAL,CAAQC,QAAR,EAAP;AACD,CAFD;AAGA;;;;;;;;;;;;;;;;;;;;;AAqBAN,QAAQ,CAAC2B,SAAT,CAAmBR,cAAnB,GAAoC,UAAUiD,IAAV,EAAgBC,KAAhB,EAAuB;AACzDA,EAAAA,KAAK,GAAG,KAAKjE,OAAL,IAAgB,OAAO,KAAKoC,IAAZ,KAAqB,WAArC,GAAmD,QAAnD,GAA8D6B,KAAK,IAAI,UAA/E;;AAEA,UAAQA,KAAR;AACE;AACA,SAAK,UAAL;AACE,UAAI,KAAK7B,IAAL,CAAU8B,CAAV,IAAe,KAAK9B,IAAL,CAAU8B,CAAV,KAAgB,KAAnC,EAA0C;AACxC,YAAI,KAAK9B,IAAL,CAAU8B,CAAV,CAAYC,OAAZ,CAAoB,KAApB,MAA+B,CAAC,CAApC,EAAuC;AACrC,cAAIC,MAAM,GAAG,EAAb;AACAA,UAAAA,MAAM,GAAG,KAAKC,cAAL,CAAoBL,IAApB,IAA4B,KAAK5B,IAAL,CAAUkC,CAAV,IAAe,KAAKlC,IAAL,CAAUkC,CAAV,CAAYC,CAAvD,GAA2D,KAAKnC,IAAL,CAAUoC,CAAV,IAAe,KAAKpC,IAAL,CAAUoC,CAAV,CAAYD,CAA/F;AACA,cAAIE,IAAI,GAAG,IAAI9E,OAAJ,CAAY,KAAKyC,IAAL,CAAU8B,CAAtB,CAAX;AACA,iBAAOO,IAAI,CAACC,MAAL,CAAY;AACjBH,YAAAA,CAAC,EAAEH,MAAM,IAAI;AADI,WAAZ,CAAP;AAGD;;AAED,eAAO,KAAKhC,IAAL,CAAU8B,CAAjB;AACD;;AAED,UAAIO,IAAI,GAAG,QAAQ,KAAKrC,IAAL,CAAUE,CAA7B;;AAEA,UAAI,KAAK+B,cAAL,CAAoBL,IAApB,CAAJ,EAA+B;AAC7BS,QAAAA,IAAI,IAAI,MAAM,KAAKrC,IAAL,CAAUkC,CAAV,CAAYK,CAA1B;AACD;;AAED,aAAOF,IAAP;AACA;;AAEF,SAAK,QAAL;AACE,UAAI9D,MAAM,GAAG,KAAKiE,SAAL,CAAeZ,IAAf,CAAb;AAAA,UACI;AACJa,MAAAA,GAAG,GAAG,KAFN;AAAA,UAGIC,IAAI,GAAGnE,MAAM,CAAC+B,CAAP,IAAY,CAHvB;AAAA,UAIIqC,MAAM,GAAGpE,MAAM,CAACgC,CAAP,IAAY,CAJzB;;AAMA,UAAImC,IAAI,KAAK,CAAb,EAAgB;AACdD,QAAAA,GAAG,IAAIC,IAAI,GAAG,CAAP,GAAW,GAAX,GAAiB,GAAxB;;AAEA,YAAIlE,IAAI,CAAC6B,GAAL,CAASqC,IAAT,IAAiB,EAArB,EAAyB;AACvBD,UAAAA,GAAG,IAAI,GAAP;AACD;;AAEDA,QAAAA,GAAG,IAAIC,IAAI,GAAG,CAAP,GAAW,CAACA,IAAZ,GAAmBA,IAA1B;;AAEA,YAAIC,MAAM,GAAG,EAAb,EAAiB;AACfF,UAAAA,GAAG,IAAI,GAAP;AACD;;AAEDA,QAAAA,GAAG,IAAIE,MAAP;AACD;;AAED,aAAOF,GAAP;;AAEF,SAAK,MAAL;AACE,UAAI,KAAKzC,IAAL,CAAU4C,CAAd,EAAiB;AACf,YAAI,KAAK5C,IAAL,CAAU4C,CAAV,CAAYb,OAAZ,CAAoB,KAApB,MAA+B,CAAC,CAApC,EAAuC;AACrC,cAAIc,GAAG,GAAG,KAAKZ,cAAL,CAAoBL,IAApB,IAA4B,UAA5B,GAAyC,UAAnD;AACA,cAAIS,IAAI,GAAG,IAAI9E,OAAJ,CAAY,KAAKyC,IAAL,CAAU4C,CAAtB,CAAX;AACA,iBAAOP,IAAI,CAACC,MAAL,CAAY;AACjBH,YAAAA,CAAC,EAAEU,GAAG,IAAI;AADO,WAAZ,CAAP;AAGD;;AAED,eAAO,KAAK7C,IAAL,CAAU4C,CAAjB;AACD;;AAED,UAAIP,IAAI,GAAG,QAAQ,KAAKrC,IAAL,CAAUE,CAA7B;;AAEA,UAAI,KAAK+B,cAAL,CAAoBL,IAApB,CAAJ,EAA+B;AAC7BS,QAAAA,IAAI,IAAI,MAAM,KAAKrC,IAAL,CAAUkC,CAAV,CAAYK,CAA1B;AACD;;AAED,aAAOF,IAAP;AACA;AAtEJ;AAwED,CA3ED;AA4EA;;;;;;;;;;;AAWA7E,QAAQ,CAAC2B,SAAT,CAAmBiB,kBAAnB,GAAwC,UAAUyC,GAAV,EAAe;AACrD,MAAI1C,WAAW,GAAG,OAAO0C,GAAP,KAAe,QAAf,GAA0BA,GAAG,CAACC,KAAJ,CAAU,GAAV,CAA1B,GAA2C,EAA7D;AAAA,MACIL,GAAG,GAAG;AACRnC,IAAAA,CAAC,EAAE;AADK,GADV;AAAA,MAII+B,IAJJ;;AAMA,MAAIlC,WAAW,CAACc,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BwB,IAAAA,GAAG,CAACnC,CAAJ,GAAQ5B,QAAQ,CAACyB,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAhB;;AAEA,QAAIA,WAAW,CAACc,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BoB,MAAAA,IAAI,GAAG3D,QAAQ,CAACyB,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAf;;AAEA,UAAIkC,IAAJ,EAAU;AACRI,QAAAA,GAAG,CAAClC,CAAJ,GAAQ8B,IAAR;AACD;;AAED,UAAIlC,WAAW,CAACc,MAAZ,GAAqB,CAAzB,EAA4B;AAC1BoB,QAAAA,IAAI,GAAG3D,QAAQ,CAACyB,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAf;;AAEA,YAAIkC,IAAJ,EAAU;AACRI,UAAAA,GAAG,CAACP,CAAJ,GAAQG,IAAR;AACD;AACF;AACF;AACF;;AAED,SAAOI,GAAP;AACD,CA5BD;AA6BA;;;;;;;;;;AAUAjF,QAAQ,CAAC2B,SAAT,CAAmBqD,SAAnB,GAA+B,UAAUZ,IAAV,EAAgB;AAC7C,MAAI,CAACA,IAAL,EAAW;AACT,WAAO,KAAKmB,YAAL,EAAP;AACD;;AAED,MAAIxE,MAAM,GAAG,KAAKyE,eAAL,CAAqBpB,IAArB,IAA6B,KAA1C;AACA,MAAIqB,KAAK,GAAGhG,SAAS,CAACiG,IAAV,CAAe3E,MAAM,GAAG,EAAxB,CAAZ;AAAA,MACI4E,OAAO,GAAG3E,IAAI,CAAC6B,GAAL,CAAS9B,MAAT,IAAmBC,IAAI,CAAC6B,GAAL,CAAS4C,KAAT,IAAkB,EADnD;AAEA,MAAIR,GAAG,GAAG;AACRnC,IAAAA,CAAC,EAAE2C;AADK,GAAV;;AAIA,MAAIE,OAAO,IAAI,CAAf,EAAkB;AAChBV,IAAAA,GAAG,CAAClC,CAAJ,GAAQ4C,OAAR;AACD;;AAED,SAAOV,GAAP;AACD,CAjBD;AAkBA;;;;;;;;;;;;;AAaAjF,QAAQ,CAAC2B,SAAT,CAAmB6D,eAAnB,GAAqC,UAAUpB,IAAV,EAAgB;AACnD,MAAIa,GAAJ,CADmD,CAC1C;AACT;;AAEA,MAAI,KAAK7E,OAAL,IAAgB,OAAOgE,IAAI,CAACwB,GAAZ,KAAoB,WAAxC,EAAqD;AACnD,QAAIC,CAAC,GAAG,CAACzB,IAAD,GAAQ,IAAI5D,IAAJ,EAAR,GAAqB,IAAIA,IAAJ,CAAS4D,IAAI,CAAC0B,eAAL,EAAT,CAA7B;AACA,WAAO,CAACD,CAAC,CAAChF,iBAAF,EAAD,GAAyB,KAAhC;AACD;;AAEDoE,EAAAA,GAAG,GAAG,KAAKlE,MAAX;;AAEA,MAAIqD,IAAI,IAAI,KAAKK,cAAL,CAAoBL,IAApB,CAAZ,EAAuC;AACrCa,IAAAA,GAAG,IAAI,KAAKc,UAAZ;AACD;;AAED,SAAOd,GAAG,GAAG,KAAb;AACD,CAhBD;AAiBA;;;;;;;;;AASAjF,QAAQ,CAAC2B,SAAT,CAAmBqE,wBAAnB,GAA8C,UAAU5B,IAAV,EAAgB;AAC5D,MAAIa,GAAJ;AACAA,EAAAA,GAAG,GAAG,KAAKlE,MAAX;;AAEA,MAAIqD,IAAI,IAAI,KAAKK,cAAL,CAAoBL,IAApB,EAA0B,IAA1B,CAAZ,EAA6C;AAC3Ca,IAAAA,GAAG,IAAI,KAAKc,UAAZ;AACD;;AAED,SAAOd,GAAG,GAAG,KAAb;AACD,CATD;AAUA;;;;;;;;;;AAUAjF,QAAQ,CAAC2B,SAAT,CAAmBsE,YAAnB,GAAkC,UAAU7B,IAAV,EAAgB;AAChD,MAAIrD,MAAM,GAAG,KAAKiE,SAAL,CAAeZ,IAAf,CAAb;AAAA,MACIa,GADJ;AAEAA,EAAAA,GAAG,GAAGlE,MAAM,CAAC+B,CAAb;;AAEA,MAAI,OAAO/B,MAAM,CAACgC,CAAd,KAAoB,WAAxB,EAAqC;AACnCkC,IAAAA,GAAG,IAAI,MAAMlE,MAAM,CAACgC,CAApB;;AAEA,QAAI,OAAOhC,MAAM,CAAC2D,CAAd,KAAoB,WAAxB,EAAqC;AACnCO,MAAAA,GAAG,IAAI,MAAMlE,MAAM,CAAC2D,CAApB;AACD;AACF,GAND,MAMO;AACLO,IAAAA,GAAG,IAAI,IAAP;AACD;;AAED,SAAOA,GAAP;AACD,CAhBD;AAiBA;;;;;;;AAOAjF,QAAQ,CAAC2B,SAAT,CAAmB4D,YAAnB,GAAkC,YAAY;AAC5C,MAAIE,KAAK,GAAGhG,SAAS,CAACiG,IAAV,CAAe,KAAK3E,MAAL,GAAc,EAA7B,CAAZ;AAAA,MACI4E,OAAO,GAAG3E,IAAI,CAAC6B,GAAL,CAAS,KAAK9B,MAAd,IAAwBC,IAAI,CAAC6B,GAAL,CAAS4C,KAAT,IAAkB,EADxD;AAEA,MAAIR,GAAG,GAAG;AACRnC,IAAAA,CAAC,EAAE2C;AADK,GAAV;;AAIA,MAAIE,OAAO,IAAI,CAAf,EAAkB;AAChBV,IAAAA,GAAG,CAAClC,CAAJ,GAAQ4C,OAAR;AACD;;AAED,SAAOV,GAAP;AACD,CAZD;AAaA;;;;;;;;;AASAjF,QAAQ,CAAC2B,SAAT,CAAmBuE,kBAAnB,GAAwC,YAAY;AAClD,SAAO,KAAKnF,MAAL,GAAc,KAArB;AACD,CAFD;AAGA;;;;;;AAMAf,QAAQ,CAAC2B,SAAT,CAAmBwE,eAAnB,GAAqC,YAAY;AAC/C,MAAIC,GAAG,GAAG,KAAKb,YAAL,EAAV;AACA,SAAOa,GAAG,CAACtD,CAAJ,GAAQ,GAAR,IAAesD,GAAG,CAACrD,CAAJ,IAAS,GAAxB,CAAP;AACD,CAHD;AAIA;;;;;;;;AAQA/C,QAAQ,CAAC2B,SAAT,CAAmB0E,aAAnB,GAAmC,YAAY;AAC7C,MAAI,KAAKjG,OAAT,EAAkB;AAChB;AACA;AACA,QAAIkG,OAAO,GAAGtF,IAAI,CAAC6B,GAAL,CAAS,KAAKjC,UAAL,GAAkB,KAAKE,UAAhC,CAAd;AACA,QAAI2E,KAAK,GAAGhG,SAAS,CAACiG,IAAV,CAAeY,OAAO,GAAG,EAAzB,CAAZ;AAAA,QACIX,OAAO,GAAGW,OAAO,GAAGb,KAAK,GAAG,EADhC;AAEA,WAAO;AACL3C,MAAAA,CAAC,EAAE2C,KADE;AAEL1C,MAAAA,CAAC,EAAE4C;AAFE,KAAP;AAID,GAVD,MAUO,IAAI,KAAKnD,IAAL,IAAa,KAAKA,IAAL,CAAUkC,CAA3B,EAA8B;AACnC,WAAO,KAAK9B,kBAAL,CAAwB,KAAKJ,IAAL,CAAUkC,CAAV,CAAYK,CAApC,CAAP,CADmC,CACY;AAChD;;AAED,SAAO;AACLjC,IAAAA,CAAC,EAAE;AADE,GAAP;AAGD,CAlBD;AAmBA;;;;;;;;AAQA9C,QAAQ,CAAC2B,SAAT,CAAmB4E,gBAAnB,GAAsC,YAAY;AAChD,MAAI,KAAKnG,OAAT,EAAkB;AAChB,QAAIkG,OAAO,GAAG,KAAKD,aAAL,EAAd;AACA,WAAOC,OAAO,CAACxD,CAAR,GAAY,GAAZ,GAAkBwD,OAAO,CAACvD,CAAjC;AACD,GAHD,MAGO,IAAI,OAAO,KAAKhC,MAAZ,KAAuB,WAAvB,IAAsC,KAAKyB,IAA3C,IAAmD,KAAKA,IAAL,CAAUkC,CAAjE,EAAoE;AACzE,WAAO,KAAKlC,IAAL,CAAUkC,CAAV,CAAYK,CAAnB,CADyE,CACnD;AACvB;;AAED,SAAO,KAAP;AACD,CATD;AAUA;;;;;;;;;AASA/E,QAAQ,CAAC2B,SAAT,CAAmB6E,cAAnB,GAAoC,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACxD,MAAIC,IAAI,GAAG,GAAX;AAAA,MACIC,OAAO,GAAG,CADd;AAAA,MAEIC,GAFJ;AAAA,MAGIC,MAHJ;AAAA,MAIIC,GAJJ;AAAA,MAKI7B,IAAI,GAAG,CALX;AAAA,MAMIC,MAAM,GAAG,CANb;AAAA,MAOI6B,MAAM,GAAG,CAPb;AAAA,MAQIC,IARJ;AAAA,MASIC,CATJ;;AAWA,MAAI,OAAOT,IAAI,CAACU,CAAZ,KAAkB,WAAtB,EAAmC;AACjCL,IAAAA,MAAM,GAAG,IAAIjH,WAAJ,CAAgB;AACvBuH,MAAAA,SAAS,EAAEX,IAAI,CAACU;AADO,KAAhB,CAAT;AAGD,GAJD,MAIO;AACL,QAAIV,IAAI,CAACY,CAAL,CAAOC,MAAP,CAAc,CAAd,KAAoB,GAApB,IAA2Bb,IAAI,CAACY,CAAL,CAAOC,MAAP,CAAc,CAAd,KAAoB,GAAnD,EAAwD;AACtDP,MAAAA,GAAG,GAAGjH,eAAe,CAAC;AACpB6G,QAAAA,IAAI,EAAE;AADc,OAAD,CAArB,CADsD,CAGlD;;AAEJA,MAAAA,IAAI,GAAGF,IAAI,CAACY,CAAL,CAAOC,MAAP,CAAc,CAAd,CAAP;AACAV,MAAAA,OAAO,GAAG1F,QAAQ,CAACuF,IAAI,CAACY,CAAL,CAAOE,SAAP,CAAiB,CAAjB,CAAD,EAAsB,EAAtB,CAAlB;AACAV,MAAAA,GAAG,GAAGF,IAAI,KAAK,GAAT,GAAeI,GAAG,CAACS,YAAJ,CAAiBf,IAAI,CAAC1D,CAAtB,EAAyB2D,IAAzB,CAAf,GAAgD,CAAtD,CAPsD,CAOG;AACzD;AACA;AACD,KAVD,MAUO;AACLQ,MAAAA,CAAC,GAAGT,IAAI,CAACY,CAAL,CAAO9C,OAAP,CAAe,GAAf,CAAJ;;AAEA,UAAI2C,CAAC,IAAI,CAAC,CAAV,EAAa;AACXA,QAAAA,CAAC,GAAGT,IAAI,CAACY,CAAL,CAAO9C,OAAP,CAAe,GAAf,CAAJ;AACD;;AAED,UAAI2C,CAAC,IAAI,CAAC,CAAV,EAAa;AACXP,QAAAA,IAAI,GAAGF,IAAI,CAACY,CAAL,CAAOC,MAAP,CAAcJ,CAAd,CAAP;AACAN,QAAAA,OAAO,GAAG1F,QAAQ,CAACuF,IAAI,CAACY,CAAL,CAAOE,SAAP,CAAiB,CAAjB,EAAoBL,CAApB,CAAD,EAAyB,EAAzB,CAAlB;AACAL,QAAAA,GAAG,GAAG3F,QAAQ,CAACuF,IAAI,CAACY,CAAL,CAAOE,SAAP,CAAiBL,CAAC,GAAG,CAArB,CAAD,EAA0B,EAA1B,CAAd,CAHW,CAGkC;AAC7C;AACD,OALD,MAKO;AACLL,QAAAA,GAAG,GAAG3F,QAAQ,CAACuF,IAAI,CAACY,CAAN,EAAS,EAAT,CAAd,CADK,CACuB;AAC7B;AACF;;AAED,QAAIZ,IAAI,CAACgB,CAAT,EAAY;AACVR,MAAAA,IAAI,GAAGR,IAAI,CAACgB,CAAL,CAAOnC,KAAP,CAAa,GAAb,CAAP;AACAJ,MAAAA,IAAI,GAAGhE,QAAQ,CAAC+F,IAAI,CAAC,CAAD,CAAL,EAAU,EAAV,CAAf;;AAEA,UAAIA,IAAI,CAACxD,MAAL,GAAc,CAAlB,EAAqB;AACnB0B,QAAAA,MAAM,GAAGjE,QAAQ,CAAC+F,IAAI,CAAC,CAAD,CAAL,EAAU,EAAV,CAAjB;;AAEA,YAAIA,IAAI,CAACxD,MAAL,GAAc,CAAlB,EAAqB;AACnBuD,UAAAA,MAAM,GAAG9F,QAAQ,CAAC+F,IAAI,CAAC,CAAD,CAAL,EAAU,EAAV,CAAjB;AACD;AACF;AACF,KAvCI,CAuCH;;;AAGFH,IAAAA,MAAM,GAAG,IAAIjH,WAAJ,CAAgB;AACvB6G,MAAAA,IAAI,EAAEA,IADiB;AAEvBgB,MAAAA,KAAK,EAAEjB,IAAI,CAAC1D,CAFW;AAGvB8D,MAAAA,GAAG,EAAEA,GAHkB;AAIvB3B,MAAAA,IAAI,EAAEA,IAJiB;AAKvBC,MAAAA,MAAM,EAAEA,MALe;AAMvB6B,MAAAA,MAAM,EAAEA;AANe,KAAhB,CAAT;AAQD,GAlEuD,CAkEtD;;;AAGF,MAAInB,CAAC,GAAGiB,MAAM,CAACa,UAAP,EAAR;;AAEA,UAAQhB,IAAR;AACE,SAAK,GAAL;AACA,SAAK,GAAL;AACE;AACAd,MAAAA,CAAC,GAAGiB,MAAM,CAACc,UAAP,CAAkBhB,OAAlB,CAAJ;AACA;;AAEF,SAAK,GAAL;AACA,SAAK,GAAL;AACE;AACAf,MAAAA,CAAC,GAAGiB,MAAM,CAACe,SAAP,CAAiBjB,OAAjB,CAAJ;AACA;AAXJ;;AAcA,SAAOf,CAAP;AACD,CAtFD;AAuFA;;;;;AAKA7F,QAAQ,CAAC2B,SAAT,CAAmBc,eAAnB,GAAqC,YAAY;AAC/C,MAAIqF,SAAS,GAAG,KAAKzB,aAAL,EAAhB;AACA;;;;;AAKA,OAAKN,UAAL,GAAkB,CAAC/E,IAAI,CAAC6B,GAAL,CAASiF,SAAS,CAAChF,CAAV,IAAe,CAAxB,IAA6B,EAA7B,IAAmCgF,SAAS,CAAC/E,CAAV,IAAe,CAAlD,CAAD,IAAyDtD,SAAS,CAACuD,MAAV,CAAiB8E,SAAS,CAAChF,CAAV,IAAe,CAAhC,CAA3E;AACD,CARD;AASA;;;;;AAKA9C,QAAQ,CAAC2B,SAAT,CAAmBoG,gBAAnB,GAAsC,UAAUrB,IAAV,EAAgB;AACpD;AACA,SAAO,KAAKlE,IAAL,CAAUkC,CAAjB;AACD,CAHD;AAIA;;;;;AAKA1E,QAAQ,CAAC2B,SAAT,CAAmBqG,cAAnB,GAAoC,UAAUtB,IAAV,EAAgB;AAClD;AACA,SAAO,KAAKlE,IAAL,CAAUoC,CAAjB;AACD,CAHD;AAIA;;;;;;;;;;;;;;;;;AAiBA5E,QAAQ,CAAC2B,SAAT,CAAmB8C,cAAnB,GAAoC,UAAUL,IAAV,EAAgB6D,QAAhB,EAA0B;AAC5D,MAAIC,EAAJ,EAAQC,OAAR,EAAiBC,KAAjB,EAAwB1B,IAAxB;;AAEA,MAAI,KAAKtG,OAAT,EAAkB;AAChB;AACA;AACA;AACA,QAAIW,MAAM,GAAG,KAAKA,MAAL,GAAc,KAA3B;;AAEA,QAAI,OAAOqD,IAAI,CAACwB,GAAZ,KAAoB,WAApB,IAAmC,CAACxB,IAAI,CAACwB,GAA7C,EAAkD;AAChD7E,MAAAA,MAAM,IAAI,KAAKgF,UAAL,GAAkB,KAA5B;AACD;;AAED,QAAIF,CAAC,GAAG,IAAIrF,IAAJ,CAAS4D,IAAI,GAAGA,IAAI,CAAC0B,eAAL,KAAyB/E,MAA5B,GAAqCK,SAAlD,CAAR,CAVgB,CAUsD;AACtE;;AAEA,QAAIwE,GAAG,GAAG5E,IAAI,CAACqH,GAAL,CAAS,KAAKzH,UAAd,EAA0B,KAAKE,UAA/B,CAAV;AACA,WAAO,CAAC+E,CAAC,CAAChF,iBAAF,EAAD,KAA2B+E,GAAlC;AACD;;AAED,MAAI,CAACxB,IAAD,IAAS,CAACA,IAAI,CAAC2C,GAAf,IAAsB3C,IAAI,CAAC2C,GAAL,CAASJ,IAAT,KAAkB,WAA5C,EAAyD;AACvD;AACA,QAAIM,IAAI,GAAG7C,IAAI,IAAI,OAAOA,IAAI,CAAC0B,eAAZ,KAAgC,UAAxC,GAAqD1B,IAAI,CAAC0B,eAAL,EAArD,GAA8E1E,SAAzF;AACA8G,IAAAA,EAAE,GAAG,IAAIrI,WAAJ,CAAgB;AACnByI,MAAAA,QAAQ,EAAErB;AADS,KAAhB,EAEFU,UAFE,EAAL;AAGAjB,IAAAA,IAAI,GAAG,IAAIlG,IAAJ,CAASyG,IAAT,EAAesB,cAAf,EAAP;AACD,GAPD,MAOO;AACLL,IAAAA,EAAE,GAAG9D,IAAI,CAAC8D,EAAL,CAAQP,UAAR,EAAL;AACAjB,IAAAA,IAAI,GAAGtC,IAAI,CAACsC,IAAZ;AACD,GA9B2D,CA8B1D;AACF;AACA;;;AAGA,MAAI,CAAC,KAAK8B,eAAL,CAAqB9B,IAArB,CAAL,EAAiC;AAC/B,WAAO,KAAP;AACD,GArC2D,CAqC1D;;;AAGF,MAAI+B,SAAS,GAAG,KAAKV,gBAAL,CAAsBrB,IAAtB,CAAhB;;AAEA,MAAIgC,OAAO,GAAG,KAAKV,cAAL,CAAoBtB,IAApB,CAAd;;AAEAyB,EAAAA,OAAO,GAAG,KAAK3B,cAAL,CAAoBiC,SAApB,EAA+B/B,IAA/B,CAAV;AACA0B,EAAAA,KAAK,GAAG,KAAK5B,cAAL,CAAoBkC,OAApB,EAA6BhC,IAA7B,CAAR;;AAEA,MAAIuB,QAAJ,EAAc;AACZ;AACA;AACAE,IAAAA,OAAO,IAAI,KAAKpC,UAAL,GAAkB,IAA7B;AACD,GAJD,MAIO;AACL;AACA;AACA;AACA;AACAoC,IAAAA,OAAO,IAAI,KAAKpH,MAAL,GAAc,IAAzB,CALK,CAK0B;AAC/B;AACA;;AAEAqH,IAAAA,KAAK,IAAI,CAAC,KAAKrH,MAAL,GAAc,KAAKgF,UAApB,IAAkC,IAA3C;AACD,GA7D2D,CA6D1D;AACF;AACA;AACA;AACA;AACA;;;AAGA,MAAImC,EAAE,GAAGE,KAAL,IAAcA,KAAK,GAAGF,EAAR,IAAc,KAAKnC,UAAL,GAAkB,IAA9C,IAAsD,OAAO3B,IAAI,CAACwB,GAAZ,KAAoB,SAA9E,EAAyF;AACvF;AACA,WAAOxB,IAAI,CAACwB,GAAZ;AACD;;AAED,MAAIuC,OAAO,GAAGC,KAAd,EAAqB;AACnB;AACA,WAAOF,EAAE,IAAIC,OAAN,IAAiBD,EAAE,GAAGE,KAAtB,GAA8B,IAA9B,GAAqC,KAA5C;AACD,GA7E2D,CA6E1D;;;AAGF,SAAOF,EAAE,IAAIC,OAAN,IAAiBD,EAAE,GAAGE,KAAtB,GAA8B,IAA9B,GAAqC,KAA5C;AACD,CAjFD;AAkFA;;;;;;;;;AASApI,QAAQ,CAAC2B,SAAT,CAAmB6G,eAAnB,GAAqC,UAAU9B,IAAV,EAAgB;AACnD;AACA;AACA,SAAO,KAAKtG,OAAL,IAAgB,KAAKQ,UAAL,KAAoB,KAAKE,UAAzC,IAAuD,OAAO,KAAK0B,IAAZ,KAAqB,WAArB,IAAoC,OAAO,KAAKA,IAAL,CAAUkC,CAAjB,KAAuB,WAA3D,IAA0E,OAAO,KAAKlC,IAAL,CAAUoC,CAAjB,KAAuB,WAA/J;AACD,CAJD;AAKA;;;;;;AAMA5E,QAAQ,CAAC2B,SAAT,CAAmBgH,UAAnB,GAAgC,YAAY;AAC1C,SAAO,KAAKnG,IAAL,CAAUmC,CAAjB;AACD,CAFD;;AAIAiE,MAAM,CAACC,OAAP,GAAiB7I,QAAjB","sourcesContent":["\"use strict\";\n\n/*\n * TimeZone.js - Definition of a time zone class\n * \n * Copyright Â© 2012-2015, JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n!depends \nilib.js \nLocale.js\nLocaleInfo.js\nUtils.js\nMathUtils.js\nJSUtils.js\nGregRataDie.js\nIString.js\nCalendarFactory.js\n*/\n// !data localeinfo zoneinfo\nvar ilib = require(\"./ilib.js\");\n\nvar Utils = require(\"./Utils.js\");\n\nvar MathUtils = require(\"./MathUtils.js\");\n\nvar JSUtils = require(\"./JSUtils.js\");\n\nvar Locale = require(\"./Locale.js\");\n\nvar LocaleInfo = require(\"./LocaleInfo.js\");\n\nvar GregRataDie = require(\"./GregRataDie.js\");\n\nvar CalendarFactory = require(\"./CalendarFactory.js\");\n\nvar IString = require(\"./IString.js\");\n/**\n * @class\n * Create a time zone instance. \n * \n * This class reports and transforms\n * information about particular time zones.<p>\n * \n * The options parameter may contain any of the following properties:\n * \n * <ul>\n * <li><i>id</i> - The id of the requested time zone such as \"Europe/London\" or \n * \"America/Los_Angeles\". These are taken from the IANA time zone database. (See\n * http://www.iana.org/time-zones for more information.) <p>\n * \n * There is one special \n * time zone that is not taken from the IANA database called simply \"local\". In\n * this case, this class will attempt to discover the current time zone and\n * daylight savings time settings by calling standard Javascript classes to \n * determine the offsets from UTC. \n * \n * <li><i>locale</i> - The locale for this time zone.\n * \n * <li><i>offset</i> - Choose the time zone based on the offset from UTC given in\n * number of minutes (negative is west, positive is east).\n * \n * <li><i>onLoad</i> - a callback function to call when the data is fully \n * loaded. When the onLoad option is given, this class will attempt to\n * load any missing locale data using the ilib loader callback.\n * When the data is loaded, the onLoad function is called with the current \n * instance as a parameter. \n * \n * <li><i>sync</i> - tell whether to load any missing locale data synchronously or \n * asynchronously. If this option is given as \"false\", then the \"onLoad\"\n * callback must be given, as the instance returned from this constructor will\n * not be usable for a while.\n *  \n * <li><i>loadParams</i> - an object containing parameters to pass to the \n * loader callback function when locale data is missing. The parameters are not\n * interpretted or modified in any way. They are simply passed along. The object \n * may contain any property/value pairs as long as the calling code is in\n * agreement with the loader callback function as to what those parameters mean.\n * </ul>\n * \n * There is currently no way in the ECMAscript\n * standard to tell which exact time zone is currently in use. Choosing the\n * id \"locale\" or specifying an explicit offset will not give a specific time zone, \n * as it is impossible to tell with certainty which zone the offsets \n * match.<p>\n * \n * When the id \"local\" is given or the offset option is specified, this class will\n * have the following behaviours:\n * <ul>\n * <li>The display name will always be given as the RFC822 style, no matter what\n * style is requested\n * <li>The id will also be returned as the RFC822 style display name\n * <li>When the offset is explicitly given, this class will assume the time zone \n * does not support daylight savings time, and the offsets will be calculated \n * the same way year round.\n * <li>When the offset is explicitly given, the inDaylightSavings() method will \n * always return false.\n * <li>When the id \"local\" is given, this class will attempt to determine the \n * daylight savings time settings by examining the offset from UTC on Jan 1\n * and June 1 of the current year. If they are different, this class assumes\n * that the local time zone uses DST. When the offset for a particular date is\n * requested, it will use the built-in Javascript support to determine the \n * offset for that date.\n * </ul> \n * \n * If a more specific time zone is \n * needed with display names and known start/stop times for DST, use the \"id\" \n * property instead to specify the time zone exactly. You can perhaps ask the\n * user which time zone they prefer so that your app does not need to guess.<p>\n * \n * If the id and the offset are both not given, the default time zone for the \n * locale is retrieved from\n * the locale info. If the locale is not specified, the default locale for the\n * library is used.<p>\n * \n * Because this class was designed for use in web sites, and the vast majority\n * of dates and times being formatted are recent date/times, this class is simplified\n * by not implementing historical time zones. That is, when governments change the \n * time zone rules for a particular zone, only the latest such rule is implemented \n * in this class. That means that determining the offset for a date that is prior \n * to the last change may give the wrong result. Historical time zone calculations\n * may be implemented in a later version of iLib if there is enough demand for it,\n * but it would entail a much larger set of time zone data that would have to be\n * loaded.  \n * \n * \n * @constructor\n * @param {Object} options Options guiding the construction of this time zone instance\n */\n\n\nvar TimeZone = function TimeZone(options) {\n  this.sync = true;\n  this.locale = new Locale();\n  this.isLocal = false;\n\n  if (options) {\n    if (options.locale) {\n      this.locale = typeof options.locale === 'string' ? new Locale(options.locale) : options.locale;\n    }\n\n    if (options.id) {\n      var id = options.id.toString();\n\n      if (id === 'local') {\n        this.isLocal = true; // use standard Javascript Date to figure out the time zone offsets\n\n        var now = new Date(),\n            jan1 = new Date(now.getFullYear(), 0, 1),\n            // months in std JS Date object are 0-based\n        jun1 = new Date(now.getFullYear(), 5, 1); // Javascript's method returns the offset backwards, so we have to\n        // take the negative to get the correct offset\n\n        this.offsetJan1 = -jan1.getTimezoneOffset();\n        this.offsetJun1 = -jun1.getTimezoneOffset(); // the offset of the standard time for the time zone is always the one that is closest \n        // to negative infinity of the two, no matter whether you are in the northern or southern \n        // hemisphere, east or west\n\n        this.offset = Math.min(this.offsetJan1, this.offsetJun1);\n      }\n\n      this.id = id;\n    } else if (options.offset) {\n      this.offset = typeof options.offset === 'string' ? parseInt(options.offset, 10) : options.offset;\n      this.id = this.getDisplayName(undefined, undefined);\n    }\n\n    if (typeof options.sync !== 'undefined') {\n      this.sync = !!options.sync;\n    }\n\n    this.loadParams = options.loadParams;\n    this.onLoad = options.onLoad;\n  } //console.log(\"timezone: locale is \" + this.locale);\n\n\n  if (!this.id) {\n    new LocaleInfo(this.locale, {\n      sync: this.sync,\n      loadParams: this.loadParams,\n      onLoad: ilib.bind(this, function (li) {\n        this.id = li.getTimeZone() || \"Etc/UTC\";\n\n        this._loadtzdata();\n      })\n    });\n  } else {\n    this._loadtzdata();\n  } //console.log(\"localeinfo is: \" + JSON.stringify(this.locinfo));\n  //console.log(\"id is: \" + JSON.stringify(this.id));\n\n};\n/*\n * Explanation of the compressed time zone info properties.\n * {\n *     \"o\": \"8:0\",      // offset from UTC\n *     \"f\": \"W{c}T\",    // standard abbreviation. For time zones that observe DST, the {c} replacement is replaced with the \n *                      // letter in the e.c or s.c properties below \n *     \"e\": {           // info about the end of DST\n *         \"j\": 78322.5 // Julian day when the transition happens. Either specify the \"j\" property or all of the \"m\", \"r\", and \n *                      // \"t\" properties, but not both sets.\n *         \"m\": 3,      // month that it ends\n *         \"r\": \"l0\",   // rule for the day it ends \"l\" = \"last\", numbers are Sun=0 through Sat=6. Other syntax is \"0>7\". \n *                      // This means the 0-day (Sun) after the 7th of the month. Other possible operators are <, >, <=, >=\n *         \"t\": \"2:0\",  // time of day that the DST turns off, hours:minutes\n *         \"c\": \"S\"     // character to replace into the abbreviation for standard time \n *     },\n *     \"s\": {           // info about the start of DST\n *         \"j\": 78189.5 // Julian day when the transition happens. Either specify the \"j\" property or all of the \"m\", \"r\", and \n *                      // \"t\" properties, but not both sets.\n *         \"m\": 10,     // month that it starts\n *         \"r\": \"l0\",   // rule for the day it starts \"l\" = \"last\", numbers are Sun=0 through Sat=6. Other syntax is \"0>7\".\n *                      // This means the 0-day (Sun) after the 7th of the month. Other possible operators are <, >, <=, >=\n *         \"t\": \"2:0\",  // time of day that the DST turns on, hours:minutes\n *         \"v\": \"1:0\",  // amount of time saved in hours:minutes\n *         \"c\": \"D\"     // character to replace into the abbreviation for daylight time\n *     },\n *     \"c\": \"AU\",       // ISO code for the country that contains this time zone\n *     \"n\": \"W. Australia {c} Time\"\n *                      // long English name of the zone. The {c} replacement is for the word \"Standard\" or \"Daylight\" as appropriate\n * }\n */\n\n\nTimeZone.prototype._loadtzdata = function () {\n  var zoneName = this.id.replace(/-/g, \"m\").replace(/\\+/g, \"p\"); // console.log(\"id is: \" + JSON.stringify(this.id));\n  // console.log(\"zoneinfo is: \" + JSON.stringify(ilib.data.zoneinfo[zoneName]));\n\n  if (!ilib.data.zoneinfo[zoneName] && typeof this.offset === 'undefined') {\n    Utils.loadData({\n      object: \"TimeZone\",\n      nonlocale: true,\n      // locale independent \n      name: \"zoneinfo/\" + this.id + \".json\",\n      sync: this.sync,\n      loadParams: this.loadParams,\n      callback: ilib.bind(this, function (tzdata) {\n        if (tzdata && !JSUtils.isEmpty(tzdata)) {\n          ilib.data.zoneinfo[zoneName] = tzdata;\n        }\n\n        this._initZone(zoneName);\n      })\n    });\n  } else {\n    this._initZone(zoneName);\n  }\n};\n\nTimeZone.prototype._initZone = function (zoneName) {\n  /** \n   * @private\n   * @type {{o:string,f:string,e:Object.<{m:number,r:string,t:string,z:string}>,s:Object.<{m:number,r:string,t:string,z:string,v:string,c:string}>,c:string,n:string}} \n   */\n  this.zone = ilib.data.zoneinfo[zoneName];\n\n  if (!this.zone && typeof this.offset === 'undefined') {\n    this.id = \"Etc/UTC\";\n    this.zone = ilib.data.zoneinfo[this.id];\n  }\n\n  this._calcDSTSavings();\n\n  if (typeof this.offset === 'undefined' && this.zone.o) {\n    var offsetParts = this._offsetStringToObj(this.zone.o);\n    /**\n     * @private\n     * @type {number} raw offset from UTC without DST, in minutes\n     */\n\n\n    this.offset = (Math.abs(offsetParts.h || 0) * 60 + (offsetParts.m || 0)) * MathUtils.signum(offsetParts.h || 0);\n  }\n\n  if (this.onLoad && typeof this.onLoad === 'function') {\n    this.onLoad(this);\n  }\n};\n/** @private */\n\n\nTimeZone._marshallIds = function (country, sync, callback) {\n  var tz,\n      ids = [];\n\n  if (!country) {\n    // local is a special zone meaning \"the local time zone according to the JS engine we are running upon\"\n    ids.push(\"local\");\n\n    for (tz in ilib.data.timezones) {\n      if (ilib.data.timezones[tz]) {\n        ids.push(ilib.data.timezones[tz]);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(ids);\n    }\n  } else {\n    if (!ilib.data.zoneinfo.zonetab) {\n      Utils.loadData({\n        object: \"TimeZone\",\n        nonlocale: true,\n        // locale independent \n        name: \"zoneinfo/zonetab.json\",\n        sync: sync,\n        callback: ilib.bind(this, function (tzdata) {\n          if (tzdata) {\n            ilib.data.zoneinfo.zonetab = tzdata;\n          }\n\n          ids = ilib.data.zoneinfo.zonetab[country];\n\n          if (typeof callback === 'function') {\n            callback(ids);\n          }\n        })\n      });\n    } else {\n      ids = ilib.data.zoneinfo.zonetab[country];\n\n      if (typeof callback === 'function') {\n        callback(ids);\n      }\n    }\n  }\n\n  return ids;\n};\n/**\n * Return an array of available zone ids that the constructor knows about.\n * The country parameter is optional. If it is not given, all time zones will\n * be returned. If it specifies a country code, then only time zones for that\n * country will be returned.\n * \n * @param {string|undefined} country country code for which time zones are being sought\n * @param {boolean} sync whether to find the available ids synchronously (true) or asynchronously (false)\n * @param {function(Array.<string>)} onLoad callback function to call when the data is finished loading\n * @return {Array.<string>} an array of zone id strings\n */\n\n\nTimeZone.getAvailableIds = function (country, sync, onLoad) {\n  var tz,\n      ids = [];\n\n  if (typeof sync !== 'boolean') {\n    sync = true;\n  }\n\n  if (ilib.data.timezones.length === 0) {\n    if (typeof ilib._load !== 'undefined' && typeof ilib._load.listAvailableFiles === 'function') {\n      ilib._load.listAvailableFiles(sync, function (hash) {\n        for (var dir in hash) {\n          var files = hash[dir];\n\n          if (ilib.isArray(files)) {\n            files.forEach(function (filename) {\n              if (filename && filename.match(/^zoneinfo/)) {\n                ilib.data.timezones.push(filename.replace(/^zoneinfo\\//, \"\").replace(/\\.json$/, \"\"));\n              }\n            });\n          }\n        }\n\n        ids = TimeZone._marshallIds(country, sync, onLoad);\n      });\n    } else {\n      for (tz in ilib.data.zoneinfo) {\n        if (ilib.data.zoneinfo[tz]) {\n          ilib.data.timezones.push(tz);\n        }\n      }\n\n      ids = TimeZone._marshallIds(country, sync, onLoad);\n    }\n  } else {\n    ids = TimeZone._marshallIds(country, sync, onLoad);\n  }\n\n  return ids;\n};\n/**\n * Return the id used to uniquely identify this time zone.\n * @return {string} a unique id for this time zone\n */\n\n\nTimeZone.prototype.getId = function () {\n  return this.id.toString();\n};\n/**\n * Return the abbreviation that is used for the current time zone on the given date.\n * The date may be in DST or during standard time, and many zone names have different\n * abbreviations depending on whether or not the date is falls within DST.<p>\n * \n * There are two styles that are supported:\n * \n * <ol>\n * <li>standard - returns the 3 to 5 letter abbreviation of the time zone name such \n * as \"CET\" for \"Central European Time\" or \"PDT\" for \"Pacific Daylight Time\"\n * <li>rfc822 - returns an RFC 822 style time zone specifier, which specifies more\n * explicitly what the offset is from UTC\n * <li>long - returns the long name of the zone in English\n * </ol>\n *  \n * @param {IDate=} date a date to determine if it is in daylight time or standard time\n * @param {string=} style one of \"standard\" or \"rfc822\". Default if not specified is \"standard\"\n * @return {string} the name of the time zone, abbreviated according to the style \n */\n\n\nTimeZone.prototype.getDisplayName = function (date, style) {\n  style = this.isLocal || typeof this.zone === 'undefined' ? \"rfc822\" : style || \"standard\";\n\n  switch (style) {\n    default:\n    case 'standard':\n      if (this.zone.f && this.zone.f !== \"zzz\") {\n        if (this.zone.f.indexOf(\"{c}\") !== -1) {\n          var letter = \"\";\n          letter = this.inDaylightTime(date) ? this.zone.s && this.zone.s.c : this.zone.e && this.zone.e.c;\n          var temp = new IString(this.zone.f);\n          return temp.format({\n            c: letter || \"\"\n          });\n        }\n\n        return this.zone.f;\n      }\n\n      var temp = \"GMT\" + this.zone.o;\n\n      if (this.inDaylightTime(date)) {\n        temp += \"+\" + this.zone.s.v;\n      }\n\n      return temp;\n      break;\n\n    case 'rfc822':\n      var offset = this.getOffset(date),\n          // includes the DST if applicable\n      ret = \"UTC\",\n          hour = offset.h || 0,\n          minute = offset.m || 0;\n\n      if (hour !== 0) {\n        ret += hour > 0 ? \"+\" : \"-\";\n\n        if (Math.abs(hour) < 10) {\n          ret += \"0\";\n        }\n\n        ret += hour < 0 ? -hour : hour;\n\n        if (minute < 10) {\n          ret += \"0\";\n        }\n\n        ret += minute;\n      }\n\n      return ret;\n\n    case 'long':\n      if (this.zone.n) {\n        if (this.zone.n.indexOf(\"{c}\") !== -1) {\n          var str = this.inDaylightTime(date) ? \"Daylight\" : \"Standard\";\n          var temp = new IString(this.zone.n);\n          return temp.format({\n            c: str || \"\"\n          });\n        }\n\n        return this.zone.n;\n      }\n\n      var temp = \"GMT\" + this.zone.o;\n\n      if (this.inDaylightTime(date)) {\n        temp += \"+\" + this.zone.s.v;\n      }\n\n      return temp;\n      break;\n  }\n};\n/**\n * Convert the offset string to an object with an h, m, and possibly s property\n * to indicate the hours, minutes, and seconds.\n * \n * @private\n * @param {string} str the offset string to convert to an object\n * @return {Object.<{h:number,m:number,s:number}>} an object giving the offset for the zone at \n * the given date/time, in hours, minutes, and seconds\n */\n\n\nTimeZone.prototype._offsetStringToObj = function (str) {\n  var offsetParts = typeof str === 'string' ? str.split(\":\") : [],\n      ret = {\n    h: 0\n  },\n      temp;\n\n  if (offsetParts.length > 0) {\n    ret.h = parseInt(offsetParts[0], 10);\n\n    if (offsetParts.length > 1) {\n      temp = parseInt(offsetParts[1], 10);\n\n      if (temp) {\n        ret.m = temp;\n      }\n\n      if (offsetParts.length > 2) {\n        temp = parseInt(offsetParts[2], 10);\n\n        if (temp) {\n          ret.s = temp;\n        }\n      }\n    }\n  }\n\n  return ret;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving.\n * @param {IDate=} date the date for which the offset is needed\n * @return {Object.<{h:number,m:number}>} an object giving the offset for the zone at \n * the given date/time, in hours, minutes, and seconds  \n */\n\n\nTimeZone.prototype.getOffset = function (date) {\n  if (!date) {\n    return this.getRawOffset();\n  }\n\n  var offset = this.getOffsetMillis(date) / 60000;\n  var hours = MathUtils.down(offset / 60),\n      minutes = Math.abs(offset) - Math.abs(hours) * 60;\n  var ret = {\n    h: hours\n  };\n\n  if (minutes != 0) {\n    ret.m = minutes;\n  }\n\n  return ret;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time expressed in \n * milliseconds. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving. Negative numbers indicate offsets west\n * of UTC and conversely, positive numbers indicate offset east of UTC.\n *  \n * @param {IDate=} date the date for which the offset is needed, or null for the\n * present date\n * @return {number} the number of milliseconds of offset from UTC that the given date is\n */\n\n\nTimeZone.prototype.getOffsetMillis = function (date) {\n  var ret; // check if the dst property is defined -- the intrinsic JS Date object doesn't work so\n  // well if we are in the overlap time at the end of DST\n\n  if (this.isLocal && typeof date.dst === 'undefined') {\n    var d = !date ? new Date() : new Date(date.getTimeExtended());\n    return -d.getTimezoneOffset() * 60000;\n  }\n\n  ret = this.offset;\n\n  if (date && this.inDaylightTime(date)) {\n    ret += this.dstSavings;\n  }\n\n  return ret * 60000;\n};\n/**\n * Return the offset in milliseconds when the date has an RD number in wall\n * time rather than in UTC time.\n * @protected\n * @param date the date to check in wall time\n * @returns {number} the number of milliseconds of offset from UTC that the given date is\n */\n\n\nTimeZone.prototype._getOffsetMillisWallTime = function (date) {\n  var ret;\n  ret = this.offset;\n\n  if (date && this.inDaylightTime(date, true)) {\n    ret += this.dstSavings;\n  }\n\n  return ret * 60000;\n};\n/**\n * Returns the offset of this time zone from UTC at the given date/time. If daylight saving \n * time is in effect at the given date/time, this method will return the offset value \n * adjusted by the amount of daylight saving.\n * @param {IDate=} date the date for which the offset is needed\n * @return {string} the offset for the zone at the given date/time as a string in the \n * format \"h:m:s\" \n */\n\n\nTimeZone.prototype.getOffsetStr = function (date) {\n  var offset = this.getOffset(date),\n      ret;\n  ret = offset.h;\n\n  if (typeof offset.m !== 'undefined') {\n    ret += \":\" + offset.m;\n\n    if (typeof offset.s !== 'undefined') {\n      ret += \":\" + offset.s;\n    }\n  } else {\n    ret += \":0\";\n  }\n\n  return ret;\n};\n/**\n * Gets the offset from UTC for this time zone.\n * @return {Object.<{h:number,m:number,s:number}>} an object giving the offset from \n * UTC for this time zone, in hours, minutes, and seconds \n */\n\n\nTimeZone.prototype.getRawOffset = function () {\n  var hours = MathUtils.down(this.offset / 60),\n      minutes = Math.abs(this.offset) - Math.abs(hours) * 60;\n  var ret = {\n    h: hours\n  };\n\n  if (minutes != 0) {\n    ret.m = minutes;\n  }\n\n  return ret;\n};\n/**\n * Gets the offset from UTC for this time zone expressed in milliseconds. Negative numbers\n * indicate zones west of UTC, and positive numbers indicate zones east of UTC.\n * \n * @return {number} an number giving the offset from \n * UTC for this time zone in milliseconds \n */\n\n\nTimeZone.prototype.getRawOffsetMillis = function () {\n  return this.offset * 60000;\n};\n/**\n * Gets the offset from UTC for this time zone without DST savings.\n * @return {string} the offset from UTC for this time zone, in the format \"h:m:s\" \n */\n\n\nTimeZone.prototype.getRawOffsetStr = function () {\n  var off = this.getRawOffset();\n  return off.h + \":\" + (off.m || \"0\");\n};\n/**\n * Return the amount of time in hours:minutes that the clock is advanced during\n * daylight savings time.\n * @return {Object.<{h:number,m:number,s:number}>} the amount of time that the \n * clock advances for DST in hours, minutes, and seconds \n */\n\n\nTimeZone.prototype.getDSTSavings = function () {\n  if (this.isLocal) {\n    // take the absolute because the difference in the offsets may be positive or\n    // negative, depending on the hemisphere\n    var savings = Math.abs(this.offsetJan1 - this.offsetJun1);\n    var hours = MathUtils.down(savings / 60),\n        minutes = savings - hours * 60;\n    return {\n      h: hours,\n      m: minutes\n    };\n  } else if (this.zone && this.zone.s) {\n    return this._offsetStringToObj(this.zone.s.v); // this.zone.start.savings\n  }\n\n  return {\n    h: 0\n  };\n};\n/**\n * Return the amount of time in hours:minutes that the clock is advanced during\n * daylight savings time.\n * @return {string} the amount of time that the clock advances for DST in the\n * format \"h:m:s\"\n */\n\n\nTimeZone.prototype.getDSTSavingsStr = function () {\n  if (this.isLocal) {\n    var savings = this.getDSTSavings();\n    return savings.h + \":\" + savings.m;\n  } else if (typeof this.offset !== 'undefined' && this.zone && this.zone.s) {\n    return this.zone.s.v; // this.zone.start.savings\n  }\n\n  return \"0:0\";\n};\n/**\n * return the rd of the start of DST transition for the given year\n * @protected\n * @param {Object} rule set of rules\n * @param {number} year year to check\n * @return {number} the rd of the start of DST for the year\n */\n\n\nTimeZone.prototype._calcRuleStart = function (rule, year) {\n  var type = \"=\",\n      weekday = 0,\n      day,\n      refDay,\n      cal,\n      hour = 0,\n      minute = 0,\n      second = 0,\n      time,\n      i;\n\n  if (typeof rule.j !== 'undefined') {\n    refDay = new GregRataDie({\n      julianday: rule.j\n    });\n  } else {\n    if (rule.r.charAt(0) == 'l' || rule.r.charAt(0) == 'f') {\n      cal = CalendarFactory({\n        type: \"gregorian\"\n      }); // can be synchronous\n\n      type = rule.r.charAt(0);\n      weekday = parseInt(rule.r.substring(1), 10);\n      day = type === 'l' ? cal.getMonLength(rule.m, year) : 1; //console.log(\"_calcRuleStart: Calculating the \" + \n      //\t\t(rule.r.charAt(0) == 'f' ? \"first \" : \"last \") + weekday + \n      //\t\t\" of month \" + rule.m);\n    } else {\n      i = rule.r.indexOf('<');\n\n      if (i == -1) {\n        i = rule.r.indexOf('>');\n      }\n\n      if (i != -1) {\n        type = rule.r.charAt(i);\n        weekday = parseInt(rule.r.substring(0, i), 10);\n        day = parseInt(rule.r.substring(i + 1), 10); //console.log(\"_calcRuleStart: Calculating the \" + weekday + \n        //\t\ttype + day + \" of month \" + rule.m);\n      } else {\n        day = parseInt(rule.r, 10); //console.log(\"_calcRuleStart: Calculating the \" + day + \" of month \" + rule.m);\n      }\n    }\n\n    if (rule.t) {\n      time = rule.t.split(\":\");\n      hour = parseInt(time[0], 10);\n\n      if (time.length > 1) {\n        minute = parseInt(time[1], 10);\n\n        if (time.length > 2) {\n          second = parseInt(time[2], 10);\n        }\n      }\n    } //console.log(\"calculating rd of \" + year + \"/\" + rule.m + \"/\" + day);\n\n\n    refDay = new GregRataDie({\n      year: year,\n      month: rule.m,\n      day: day,\n      hour: hour,\n      minute: minute,\n      second: second\n    });\n  } //console.log(\"refDay is \" + JSON.stringify(refDay));\n\n\n  var d = refDay.getRataDie();\n\n  switch (type) {\n    case 'l':\n    case '<':\n      //console.log(\"returning \" + refDay.onOrBefore(rd, weekday));\n      d = refDay.onOrBefore(weekday);\n      break;\n\n    case 'f':\n    case '>':\n      //console.log(\"returning \" + refDay.onOrAfterRd(rd, weekday));\n      d = refDay.onOrAfter(weekday);\n      break;\n  }\n\n  return d;\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._calcDSTSavings = function () {\n  var saveParts = this.getDSTSavings();\n  /**\n   * @private\n   * @type {number} savings in minutes when DST is in effect \n   */\n\n  this.dstSavings = (Math.abs(saveParts.h || 0) * 60 + (saveParts.m || 0)) * MathUtils.signum(saveParts.h || 0);\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._getDSTStartRule = function (year) {\n  // TODO: update this when historic/future zones are supported\n  return this.zone.s;\n};\n/**\n * @private\n */\n\n\nTimeZone.prototype._getDSTEndRule = function (year) {\n  // TODO: update this when historic/future zones are supported\n  return this.zone.e;\n};\n/**\n * Returns whether or not the given date is in daylight saving time for the current\n * zone. Note that daylight savings time is observed for the summer. Because\n * the seasons are reversed, daylight savings time in the southern hemisphere usually\n * runs from the end of the year through New Years into the first few months of the\n * next year. This method will correctly calculate the start and end of DST for any\n * location.\n * \n * @param {IDate=} date a date for which the info about daylight time is being sought,\n * or undefined to tell whether we are currently in daylight savings time\n * @param {boolean=} wallTime if true, then the given date is in wall time. If false or\n * undefined, it is in the usual UTC time.\n * @return {boolean} true if the given date is in DST for the current zone, and false\n * otherwise.\n */\n\n\nTimeZone.prototype.inDaylightTime = function (date, wallTime) {\n  var rd, startRd, endRd, year;\n\n  if (this.isLocal) {\n    // check if the dst property is defined -- the intrinsic JS Date object doesn't work so\n    // well if we are in the overlap time at the end of DST, so we have to work around that\n    // problem by adding in the savings ourselves\n    var offset = this.offset * 60000;\n\n    if (typeof date.dst !== 'undefined' && !date.dst) {\n      offset += this.dstSavings * 60000;\n    }\n\n    var d = new Date(date ? date.getTimeExtended() - offset : undefined); // the DST offset is always the one that is closest to positive infinity, no matter \n    // if you are in the northern or southern hemisphere, east or west\n\n    var dst = Math.max(this.offsetJan1, this.offsetJun1);\n    return -d.getTimezoneOffset() === dst;\n  }\n\n  if (!date || !date.cal || date.cal.type !== \"gregorian\") {\n    // convert to Gregorian so that we can tell if it is in DST or not\n    var time = date && typeof date.getTimeExtended === 'function' ? date.getTimeExtended() : undefined;\n    rd = new GregRataDie({\n      unixtime: time\n    }).getRataDie();\n    year = new Date(time).getUTCFullYear();\n  } else {\n    rd = date.rd.getRataDie();\n    year = date.year;\n  } // rd should be a Gregorian RD number now, in UTC\n  // if we aren't using daylight time in this zone for the given year, then we are \n  // not in daylight time\n\n\n  if (!this.useDaylightTime(year)) {\n    return false;\n  } // these calculate the start/end in local wall time\n\n\n  var startrule = this._getDSTStartRule(year);\n\n  var endrule = this._getDSTEndRule(year);\n\n  startRd = this._calcRuleStart(startrule, year);\n  endRd = this._calcRuleStart(endrule, year);\n\n  if (wallTime) {\n    // rd is in wall time, so we have to make sure to skip the missing time\n    // at the start of DST when standard time ends and daylight time begins\n    startRd += this.dstSavings / 1440;\n  } else {\n    // rd is in UTC, so we have to convert the start/end to UTC time so \n    // that they can be compared directly to the UTC rd number of the date\n    // when DST starts, time is standard time already, so we only have\n    // to subtract the offset to get to UTC and not worry about the DST savings\n    startRd -= this.offset / 1440; // when DST ends, time is in daylight time already, so we have to\n    // subtract the DST savings to get back to standard time, then the\n    // offset to get to UTC\n\n    endRd -= (this.offset + this.dstSavings) / 1440;\n  } // In the northern hemisphere, the start comes first some time in spring (Feb-Apr), \n  // then the end some time in the fall (Sept-Nov). In the southern\n  // hemisphere, it is the other way around because the seasons are reversed. Standard\n  // time is still in the winter, but the winter months are May-Aug, and daylight \n  // savings time usually starts Aug-Oct of one year and runs through Mar-May of the \n  // next year.\n\n\n  if (rd < endRd && endRd - rd <= this.dstSavings / 1440 && typeof date.dst === 'boolean') {\n    // take care of the magic overlap time at the end of DST\n    return date.dst;\n  }\n\n  if (startRd < endRd) {\n    // northern hemisphere\n    return rd >= startRd && rd < endRd ? true : false;\n  } // southern hemisphere\n\n\n  return rd >= startRd || rd < endRd ? true : false;\n};\n/**\n * Returns true if this time zone switches to daylight savings time at some point\n * in the year, and false otherwise.\n * @param {number} year Whether or not the time zone uses daylight time in the given year. If\n * this parameter is not given, the current year is assumed.\n * @return {boolean} true if the time zone uses daylight savings time\n */\n\n\nTimeZone.prototype.useDaylightTime = function (year) {\n  // this zone uses daylight savings time iff there is a rule defining when to start\n  // and when to stop the DST\n  return this.isLocal && this.offsetJan1 !== this.offsetJun1 || typeof this.zone !== 'undefined' && typeof this.zone.s !== 'undefined' && typeof this.zone.e !== 'undefined';\n};\n/**\n * Returns the ISO 3166 code of the country for which this time zone is defined.\n * @return {string} the ISO 3166 code of the country for this zone\n */\n\n\nTimeZone.prototype.getCountry = function () {\n  return this.zone.c;\n};\n\nmodule.exports = TimeZone;"]},"metadata":{},"sourceType":"module"}